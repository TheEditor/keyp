{"id":"keyp-1qq","title":"Phase 1: Go scaffold and crypto foundation","description":"Establish Go project structure, archive TypeScript code, implement AES-256-GCM encryption with PBKDF2 key derivation, and create CLI skeleton.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-15T15:09:34.7861529-05:00","updated_at":"2025-12-15T15:24:33.1180172-05:00","closed_at":"2025-12-15T15:24:33.1180172-05:00","close_reason":"Phase 1 complete: Go scaffold and crypto foundation. All subtasks completed."}
{"id":"keyp-1qq.1","title":"Archive TypeScript code to legacy folder","description":"Move existing TypeScript code to legacy/ for reference.\n\nSTEPS:\n1. Create legacy/ directory in repo root\n2. Move these items INTO legacy/:\n   - src/\n   - bin/\n   - completions/\n   - docs/\n   - package.json\n   - tsconfig.json\n   - .npmignore\n   - PUBLISH.md\n   - CHANGELOG.md\n3. Keep in repo root (do NOT move):\n   - README.md (will be rewritten)\n   - LICENSE\n   - .gitignore (will be updated)\n   - .github/ (keep for now)\n   - AGENTS.md\n   - .beads/\n\n4. Update .gitignore - append these lines:\n   # Go\n   keyp\n   keyp.exe\n   *.test\n   coverage.out\n   \n   # Legacy\n   legacy/node_modules/\n   legacy/lib/\n\n5. Commit: git commit -m \"chore: archive TypeScript code to legacy/ (bd:keyp-1qq)\"\n\nACCEPTANCE: \n- legacy/ contains all TS source\n- go.mod can be created in repo root without conflicts\n- .gitignore updated for Go","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:10:16.2790219-05:00","updated_at":"2025-12-15T15:15:04.666511-05:00","closed_at":"2025-12-15T15:15:04.666511-05:00","close_reason":"Archived TypeScript code to legacy folder, updated .gitignore for Go","dependencies":[{"issue_id":"keyp-1qq.1","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:10:16.2822917-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.2","title":"Initialize Go module and directory structure","description":"Create Go module and establish package structure.\n\nSTEPS:\n1. In repo root, run:\n   go mod init github.com/TheEditor/keyp\n\n2. Create directory structure:\n   mkdir -p cmd/keyp\n   mkdir -p internal/core\n   mkdir -p internal/model\n   mkdir -p internal/store\n   mkdir -p internal/vault\n\n3. Create placeholder main.go:\n\n// cmd/keyp/main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"keyp v2.0.0-dev\")\n}\n\n4. Verify build:\n   go build -o keyp ./cmd/keyp\n   ./keyp\n\n5. Commit: git commit -m \"feat: initialize Go module structure (bd:keyp-1qq.2)\"\n\nACCEPTANCE:\n- go.mod exists with module github.com/TheEditor/keyp\n- Directory structure matches AGENTS.md\n- Binary builds and runs","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:10:50.6732644-05:00","updated_at":"2025-12-15T15:16:31.7987761-05:00","closed_at":"2025-12-15T15:16:31.7987761-05:00","close_reason":"Created Go module and directory structure, verified build","dependencies":[{"issue_id":"keyp-1qq.2","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:10:50.675909-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.2","depends_on_id":"keyp-1qq.1","type":"blocks","created_at":"2025-12-15T15:13:08.9434954-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.3","title":"Implement AES-256-GCM encryption with PBKDF2","description":"Implement core cryptographic functions matching security requirements.\n\nCREATE FILE: internal/core/crypto.go with AES-256-GCM encryption, PBKDF2 key derivation, Encrypt/Decrypt functions.\n\nTHEN run: go mod tidy\n\nACCEPTANCE:\n- File compiles: go build ./internal/core/\n- Functions exported: DeriveKey, Encrypt, Decrypt\n- Constants defined: SaltSize, IVSize, KeySize, MinIterations","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:11:19.0670949-05:00","updated_at":"2025-12-15T15:17:55.2432096-05:00","closed_at":"2025-12-15T15:17:55.2432096-05:00","close_reason":"Implemented crypto module with AES-256-GCM and PBKDF2, verified compilation","dependencies":[{"issue_id":"keyp-1qq.3","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:11:19.0709456-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.3","depends_on_id":"keyp-1qq.2","type":"blocks","created_at":"2025-12-15T15:13:10.3963234-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.4","title":"Add comprehensive crypto unit tests","description":"Create unit tests for crypto module covering key derivation, validation, round-trip encryption/decryption, wrong password handling, and uniqueness.\n\nCREATE FILE: internal/core/crypto_test.go with tests:\n- TestDeriveKey\n- TestDeriveKeyValidation\n- TestEncryptDecryptRoundTrip\n- TestDecryptWrongPassword\n- TestEncryptProducesUniqueOutput\n\nRUN: go test ./internal/core/ -v\n\nACCEPTANCE:\n- All tests pass\n- Tests cover: key derivation, validation, round-trip, wrong password, uniqueness\n\nCommit: git commit -m \"test(core): add crypto unit tests (bd:keyp-1qq.4)\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:11:47.6717699-05:00","updated_at":"2025-12-15T15:19:04.5380078-05:00","closed_at":"2025-12-15T15:19:04.5380078-05:00","close_reason":"Added comprehensive crypto unit tests, all 6 tests pass","dependencies":[{"issue_id":"keyp-1qq.4","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:11:47.6836706-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.4","depends_on_id":"keyp-1qq.3","type":"blocks","created_at":"2025-12-15T15:13:11.8070417-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.5","title":"Create CLI skeleton with cobra","description":"Set up cobra CLI framework with version and help commands.\n\nSTEP 1: Add cobra dependency\ngo get github.com/spf13/cobra@v1.8.0\ngo mod tidy\n\nSTEP 2: Replace cmd/keyp/main.go with cobra setup including rootCmd and versionCmd\n\nSTEP 3: Build and test\ngo build -o keyp ./cmd/keyp\n./keyp --help\n./keyp version\n\nACCEPTANCE:\n- keyp --help shows usage with description\n- keyp version prints \"keyp v2.0.0-dev\"\n- Unknown commands show error\n\nCommit: git commit -m \"feat(cli): add cobra CLI skeleton (bd:keyp-1qq.5)\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:12:18.2084863-05:00","updated_at":"2025-12-15T15:22:02.071751-05:00","closed_at":"2025-12-15T15:22:02.071751-05:00","close_reason":"Created cobra CLI skeleton with version command, verified --help and version work","dependencies":[{"issue_id":"keyp-1qq.5","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:12:18.2164919-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.5","depends_on_id":"keyp-1qq.2","type":"blocks","created_at":"2025-12-15T15:13:13.2562308-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.6","title":"Create Makefile for common operations","description":"Add Makefile for build, test, and clean operations with targets for build, test, test-coverage, clean, and install.\n\nVERIFY:\nmake build\nmake test\nmake clean\n\nACCEPTANCE:\n- make build produces keyp binary\n- make test runs all tests\n- make clean removes artifacts\n\nCommit: git commit -m \"chore: add Makefile (bd:keyp-1qq.6)\"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T15:12:44.0469986-05:00","updated_at":"2025-12-15T15:23:56.1206909-05:00","closed_at":"2025-12-15T15:23:56.1206909-05:00","close_reason":"Created Makefile with build, test, clean, and install targets","dependencies":[{"issue_id":"keyp-1qq.6","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:12:44.0496396-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.6","depends_on_id":"keyp-1qq.5","type":"blocks","created_at":"2025-12-15T15:13:14.6962799-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx","title":"Phase 3: Core CLI Commands","description":"Implement core CLI commands for basic vault operations.\n\nComponents:\n1. UI Utilities (internal/ui package):\n   - PromptPassword: hidden password input with non-terminal fallback\n   - PromptConfirmPassword: prompt twice, verify match\n   - PromptVisible: visible input with trim\n   - CopyToClipboard: basic clipboard copy\n   - CopyWithAutoClear: clipboard with 45s auto-clear\n\n2. CLI Commands:\n   - keyp init [--path]: create vault, prompt password, validate 8+ chars\n   - keyp set \u003cname\u003e [value] [--stdin]: quick single-field secret\n   - keyp get \u003cname\u003e [--stdout] [--field]: copy to clipboard or print\n   - keyp list [--tags] [--json]: list all secrets\n   - keyp delete \u003cname\u003e [--force]: remove secret with confirmation\n\nDEPENDS: Phase 2.5 epic (storage gaps)\n\nACCEPTANCE:\n- All ui utility functions work\n- All 5 CLI commands functional\n- Integration tests pass\n- keyp init \u0026\u0026 keyp set test abc \u0026\u0026 keyp get test works","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:38:58.6104747-05:00","updated_at":"2025-12-17T01:38:58.6104747-05:00","dependencies":[{"issue_id":"keyp-2fx","depends_on_id":"keyp-nlk","type":"blocks","created_at":"2025-12-17T09:07:49.1167039-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.1","title":"Create internal/ui package with PromptPassword function","description":"PROBLEM: CLI commands need to securely prompt for passwords without echoing to terminal.\n\nLOCATION: internal/ui/prompt.go (create new file)\n\nAPPROACH:\n1. Create internal/ui/ directory\n2. Implement PromptPassword using golang.org/x/term\n3. Handle non-terminal input (pipe/file) with fallback to bufio.Reader\n4. Return trimmed password string\n\nCODE STRUCTURE:\npackage ui\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n    \"golang.org/x/term\"\n)\n\nfunc PromptPassword(prompt string) (string, error) {\n    fmt.Print(prompt)\n    \n    fd := int(os.Stdin.Fd())\n    if term.IsTerminal(fd) {\n        pass, err := term.ReadPassword(fd)\n        fmt.Println() // newline after hidden input\n        if err != nil {\n            return \"\", err\n        }\n        return string(pass), nil\n    }\n    \n    // Fallback for non-terminal (pipe, file)\n    reader := bufio.NewReader(os.Stdin)\n    pass, err := reader.ReadString('\\n')\n    if err != nil {\n        return \"\", err\n    }\n    return strings.TrimSpace(pass), nil\n}\n\nACCEPTANCE:\n- PromptPassword hides input on terminal\n- Works with piped input\n- Returns trimmed string\n- go build ./internal/ui/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:39:42.4939826-05:00","updated_at":"2025-12-17T01:39:42.4939826-05:00","dependencies":[{"issue_id":"keyp-2fx.1","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:39:42.4966647-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.10","title":"Add cobra getCmd scaffold with --stdout and --field flags","description":"PROBLEM: Need get command to retrieve and copy secrets.\n\nLOCATION: cmd/keyp/get.go (create new file)\n\nAPPROACH:\n1. Create get.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --stdout flag to print instead of clipboard\n4. Add --field flag to select specific field\n5. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    getStdout bool\n    getField  string\n)\n\nvar getCmd = \u0026cobra.Command{\n    Use:   \"get \u003cname\u003e\",\n    Short: \"Get a secret value\",\n    Long:  \"Retrieve a secret and copy to clipboard (or print with --stdout).\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runGet,\n}\n\nfunc init() {\n    getCmd.Flags().BoolVar(\u0026getStdout, \"stdout\", false, \"Print to stdout instead of clipboard\")\n    getCmd.Flags().StringVar(\u0026getField, \"field\", \"\", \"Specific field to retrieve (default: first field)\")\n    rootCmd.AddCommand(getCmd)\n}\n\nfunc runGet(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp get --help shows usage\n- Args validation works (exactly 1 arg)\n- --stdout and --field flags documented\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:45:54.4278085-05:00","updated_at":"2025-12-17T01:45:54.4278085-05:00","dependencies":[{"issue_id":"keyp-2fx.10","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:45:54.4317161-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.11","title":"Implement getCmd.RunE with clipboard copy","description":"PROBLEM: get command needs to retrieve secrets and copy to clipboard.\n\nLOCATION: cmd/keyp/get.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Get secret by name\n3. Find field (--field or first field)\n4. Copy to clipboard (or print with --stdout)\n\nfunc runGet(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Get secret\n    secret, err := v.Store().GetByName(cmd.Context(), name)\n    if err != nil {\n        if errors.Is(err, store.ErrNotFound) {\n            return fmt.Errorf(\"secret '%s' not found\", name)\n        }\n        return fmt.Errorf(\"failed to get secret: %w\", err)\n    }\n    \n    // Find field\n    var value string\n    if getField != \"\" {\n        for _, f := range secret.Fields {\n            if f.Label == getField {\n                value = f.Value\n                break\n            }\n        }\n        if value == \"\" {\n            return fmt.Errorf(\"field '%s' not found\", getField)\n        }\n    } else if len(secret.Fields) \u003e 0 {\n        value = secret.Fields[0].Value\n    } else {\n        return fmt.Errorf(\"secret has no fields\")\n    }\n    \n    // Output\n    if getStdout {\n        fmt.Println(value)\n    } else {\n        if err := ui.CopyWithAutoClear(value, ui.DefaultClearDuration); err != nil {\n            return fmt.Errorf(\"failed to copy to clipboard: %w\", err)\n        }\n        fmt.Printf(\"Copied to clipboard (clears in 45s)\\n\")\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Copies first field to clipboard by default\n- --field selects specific field\n- --stdout prints instead of copying\n- Clipboard auto-clears after 45s\n- Prints confirmation message","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:46:55.0773523-05:00","updated_at":"2025-12-17T01:46:55.0773523-05:00","dependencies":[{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:46:55.0806131-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx.10","type":"blocks","created_at":"2025-12-17T08:59:32.7428241-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T08:59:34.1006316-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.12","title":"Add cobra listCmd scaffold with --tags and --json flags","description":"PROBLEM: Need list command to show all secrets.\n\nLOCATION: cmd/keyp/list.go (create new file)\n\nAPPROACH:\n1. Create list.go with cobra command scaffold\n2. Add --tags flag to filter by tag\n3. Add --json flag for machine-readable output\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    listTags []string\n    listJSON bool\n)\n\nvar listCmd = \u0026cobra.Command{\n    Use:   \"list\",\n    Short: \"List all secrets\",\n    Long:  \"Show all secrets in the vault with optional tag filtering.\",\n    Aliases: []string{\"ls\"},\n    RunE:  runList,\n}\n\nfunc init() {\n    listCmd.Flags().StringSliceVar(\u0026listTags, \"tags\", nil, \"Filter by tags (comma-separated)\")\n    listCmd.Flags().BoolVar(\u0026listJSON, \"json\", false, \"Output as JSON\")\n    rootCmd.AddCommand(listCmd)\n}\n\nfunc runList(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp list --help shows usage\n- --tags and --json flags documented\n- 'ls' alias works\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:47:37.2006978-05:00","updated_at":"2025-12-17T01:47:37.2006978-05:00","dependencies":[{"issue_id":"keyp-2fx.12","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:47:37.2038965-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.13","title":"Implement listCmd.RunE with formatted output","description":"PROBLEM: list command needs to display all secrets.\n\nLOCATION: cmd/keyp/list.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. List all secrets\n3. Filter by tags if --tags provided\n4. Format output (table or JSON)\n\nfunc runList(cmd *cobra.Command, args []string) error {\n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // List secrets\n    secrets, err := v.Store().List(cmd.Context())\n    if err != nil {\n        return fmt.Errorf(\"failed to list secrets: %w\", err)\n    }\n    \n    // Filter by tags\n    if len(listTags) \u003e 0 {\n        filtered := make([]*model.SecretObject, 0)\n        for _, s := range secrets {\n            if hasAnyTag(s.Tags, listTags) {\n                filtered = append(filtered, s)\n            }\n        }\n        secrets = filtered\n    }\n    \n    // Output\n    if listJSON {\n        // JSON output with redacted values\n        redacted := make([]*model.SecretObject, len(secrets))\n        for i, s := range secrets {\n            redacted[i] = s.Redacted()\n        }\n        enc := json.NewEncoder(os.Stdout)\n        enc.SetIndent(\"\", \"  \")\n        return enc.Encode(redacted)\n    }\n    \n    // Table output\n    if len(secrets) == 0 {\n        fmt.Println(\"No secrets found\")\n        return nil\n    }\n    \n    fmt.Printf(\"%-30s %-20s %s\\n\", \"NAME\", \"TAGS\", \"UPDATED\")\n    for _, s := range secrets {\n        tags := strings.Join(s.Tags, \", \")\n        updated := s.UpdatedAt.Format(\"2006-01-02 15:04\")\n        fmt.Printf(\"%-30s %-20s %s\\n\", s.Name, tags, updated)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Lists all secrets with name, tags, updated time\n- --tags filters results\n- --json outputs JSON array\n- Empty vault shows 'No secrets found'","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:48:36.8191984-05:00","updated_at":"2025-12-17T01:48:36.8191984-05:00","dependencies":[{"issue_id":"keyp-2fx.13","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:48:36.8224911-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.13","depends_on_id":"keyp-2fx.12","type":"blocks","created_at":"2025-12-17T08:59:52.5863896-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.14","title":"Add cobra deleteCmd scaffold with --force flag","description":"PROBLEM: Need delete command to remove secrets.\n\nLOCATION: cmd/keyp/delete.go (create new file)\n\nAPPROACH:\n1. Create delete.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --force flag to skip confirmation\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar deleteForce bool\n\nvar deleteCmd = \u0026cobra.Command{\n    Use:   \"delete \u003cname\u003e\",\n    Short: \"Delete a secret\",\n    Long:  \"Remove a secret from the vault. Requires confirmation unless --force is used.\",\n    Aliases: []string{\"rm\"},\n    Args:  cobra.ExactArgs(1),\n    RunE:  runDelete,\n}\n\nfunc init() {\n    deleteCmd.Flags().BoolVar(\u0026deleteForce, \"force\", false, \"Skip confirmation prompt\")\n    deleteCmd.Flags().BoolVarP(\u0026deleteForce, \"f\", \"f\", false, \"Skip confirmation prompt (shorthand)\")\n    rootCmd.AddCommand(deleteCmd)\n}\n\nfunc runDelete(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp delete --help shows usage\n- Args validation works (exactly 1 arg)\n- --force and -f flags documented\n- 'rm' alias works\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:49:18.9480902-05:00","updated_at":"2025-12-17T01:49:18.9480902-05:00","dependencies":[{"issue_id":"keyp-2fx.14","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:49:18.9513365-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.15","title":"Implement deleteCmd.RunE with confirmation","description":"PROBLEM: delete command needs confirmation and actual deletion.\n\nLOCATION: cmd/keyp/delete.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Verify secret exists\n3. Confirm deletion (unless --force)\n4. Delete secret\n5. Print confirmation\n\nfunc runDelete(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Verify exists\n    _, err = v.Store().GetByName(cmd.Context(), name)\n    if err != nil {\n        if errors.Is(err, store.ErrNotFound) {\n            return fmt.Errorf(\"secret '%s' not found\", name)\n        }\n        return fmt.Errorf(\"failed to get secret: %w\", err)\n    }\n    \n    // Confirm deletion\n    if !deleteForce {\n        confirm, err := ui.PromptVisible(fmt.Sprintf(\"Type '%s' to confirm deletion: \", name))\n        if err != nil {\n            return err\n        }\n        if confirm != name {\n            return fmt.Errorf(\"deletion cancelled\")\n        }\n    }\n    \n    // Delete\n    if err := v.Store().Delete(cmd.Context(), name); err != nil {\n        return fmt.Errorf(\"failed to delete secret: %w\", err)\n    }\n    \n    fmt.Printf(\"Secret '%s' deleted\\n\", name)\n    return nil\n}\n\nACCEPTANCE:\n- Prompts for confirmation by typing name\n- --force skips confirmation\n- Deletes secret from vault\n- Prints confirmation message\n- Shows error if secret doesn't exist","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:50:11.7156371-05:00","updated_at":"2025-12-17T01:50:11.7156371-05:00","dependencies":[{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:50:11.7182876-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx.14","type":"blocks","created_at":"2025-12-17T08:59:53.7994841-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T08:59:55.0095752-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.16","title":"Add CLI integration tests for init/set/get/list/delete","description":"PROBLEM: CLI commands need integration tests before Phase 4.\n\nLOCATION: cmd/keyp/cli_test.go (create new file)\n\nTEST SCENARIOS:\n1. Init workflow:\n   - keyp init creates vault in temp directory\n   - Rejects weak password (\u003c8 chars)\n   - Fails if vault already exists\n\n2. Set/Get workflow:\n   - keyp set creates secret\n   - keyp get retrieves secret\n   - keyp set with existing name updates\n   - keyp set --stdin reads from pipe\n\n3. List workflow:\n   - keyp list shows all secrets\n   - keyp list --tags filters correctly\n   - keyp list --json produces valid JSON\n\n4. Delete workflow:\n   - keyp delete --force removes secret\n   - Deleted secret no longer in list\n\nAPPROACH:\nUse exec.Command to run actual CLI binary. Create temp vault for each test.\nUse environment variable or --path flag to specify test vault location.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover happy paths\n- Tests use temp directories (cleaned up)\n- No external dependencies (no real clipboard needed for these tests)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:50:58.8158544-05:00","updated_at":"2025-12-17T01:50:58.8158544-05:00","dependencies":[{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:50:58.8190681-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.7","type":"blocks","created_at":"2025-12-17T09:00:16.4152194-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.9","type":"blocks","created_at":"2025-12-17T09:00:17.7293851-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.11","type":"blocks","created_at":"2025-12-17T09:00:19.0397414-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.13","type":"blocks","created_at":"2025-12-17T09:00:20.3468709-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.15","type":"blocks","created_at":"2025-12-17T09:00:21.6612528-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.2","title":"Add PromptConfirmPassword function","description":"PROBLEM: Vault init needs password confirmation to prevent typos.\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd function that prompts twice and verifies match:\n\nvar ErrPasswordMismatch = errors.New(\"passwords do not match\")\n\nfunc PromptConfirmPassword(prompt, confirmPrompt string) (string, error) {\n    pass1, err := PromptPassword(prompt)\n    if err != nil {\n        return \"\", err\n    }\n    \n    pass2, err := PromptPassword(confirmPrompt)\n    if err != nil {\n        return \"\", err\n    }\n    \n    if pass1 != pass2 {\n        return \"\", ErrPasswordMismatch\n    }\n    \n    return pass1, nil\n}\n\nACCEPTANCE:\n- Returns password when both entries match\n- Returns ErrPasswordMismatch when different\n- Uses PromptPassword internally\n- go build ./internal/ui/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:40:16.5951083-05:00","updated_at":"2025-12-17T01:40:16.5951083-05:00","dependencies":[{"issue_id":"keyp-2fx.2","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:40:16.5977435-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.2","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:58:59.6386312-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.3","title":"Add PromptVisible function for visible input","description":"PROBLEM: Delete command needs visible confirmation prompt (type secret name to confirm).\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd function for visible input with trim:\n\nfunc PromptVisible(prompt string) (string, error) {\n    fmt.Print(prompt)\n    \n    reader := bufio.NewReader(os.Stdin)\n    input, err := reader.ReadString('\\n')\n    if err != nil {\n        return \"\", err\n    }\n    \n    return strings.TrimSpace(input), nil\n}\n\nACCEPTANCE:\n- Prints prompt and reads visible input\n- Returns trimmed string\n- Handles EOF gracefully\n- go build ./internal/ui/ compiles","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:40:46.8315204-05:00","updated_at":"2025-12-17T01:40:46.8315204-05:00","dependencies":[{"issue_id":"keyp-2fx.3","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:40:46.8336306-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.3","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:59:00.9508972-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.4","title":"Create clipboard functions with auto-clear","description":"PROBLEM: get command needs to copy secrets to clipboard with optional auto-clear for security.\n\nLOCATION: internal/ui/clipboard.go (create new file)\n\nAPPROACH:\nUse github.com/atotto/clipboard package:\n\npackage ui\n\nimport (\n    \"time\"\n    \"github.com/atotto/clipboard\"\n)\n\nconst DefaultClearDuration = 45 * time.Second\n\nfunc CopyToClipboard(text string) error {\n    return clipboard.WriteAll(text)\n}\n\nfunc CopyWithAutoClear(text string, clearAfter time.Duration) error {\n    if err := clipboard.WriteAll(text); err != nil {\n        return err\n    }\n    \n    if clearAfter \u003e 0 {\n        go func() {\n            time.Sleep(clearAfter)\n            // Only clear if clipboard still contains our text\n            current, _ := clipboard.ReadAll()\n            if current == text {\n                clipboard.WriteAll(\"\")\n            }\n        }()\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- CopyToClipboard copies text\n- CopyWithAutoClear clears after duration\n- Only clears if clipboard unchanged\n- go build ./internal/ui/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:41:27.7387266-05:00","updated_at":"2025-12-17T01:41:27.7387266-05:00","dependencies":[{"issue_id":"keyp-2fx.4","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:41:27.7415191-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.5","title":"Add ui package tests","description":"PROBLEM: UI package needs tests before CLI commands depend on it.\n\nLOCATION: internal/ui/ui_test.go (create new file)\n\nTEST CASES:\n1. PromptPassword:\n   - Test with piped input (simulate non-terminal)\n   - Verify trimming works\n\n2. PromptConfirmPassword:\n   - Matching passwords return password\n   - Mismatched passwords return ErrPasswordMismatch\n\n3. PromptVisible:\n   - Returns trimmed input\n   - Handles EOF\n\n4. Clipboard:\n   - CopyToClipboard sets clipboard content\n   - CopyWithAutoClear clears after duration (use short duration for test)\n\nNOTE: Terminal tests are hard to automate. Focus on piped input paths.\n\nACCEPTANCE:\n- go test ./internal/ui/ passes\n- Tests cover main functionality\n- No flaky tests","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:42:01.7339487-05:00","updated_at":"2025-12-17T01:42:01.7339487-05:00","dependencies":[{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:42:01.7366184-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.2","type":"blocks","created_at":"2025-12-17T08:59:02.2613511-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T08:59:03.5676428-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T08:59:04.8748219-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.6","title":"Add cobra initCmd scaffold with --path flag","description":"PROBLEM: Need init command to create new vault.\n\nLOCATION: cmd/keyp/init.go (create new file)\n\nAPPROACH:\n1. Create init.go with cobra command scaffold\n2. Add --path flag for custom vault location (default ~/.keyp)\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar initPath string\n\nvar initCmd = \u0026cobra.Command{\n    Use:   \"init\",\n    Short: \"Initialize a new keyp vault\",\n    Long:  \"Create a new encrypted vault for storing secrets.\",\n    RunE:  runInit,\n}\n\nfunc init() {\n    initCmd.Flags().StringVar(\u0026initPath, \"path\", \"\", \"Path to vault directory (default: ~/.keyp)\")\n    rootCmd.AddCommand(initCmd)\n}\n\nfunc runInit(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp init --help shows usage\n- --path flag documented\n- Command registered with root\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:42:38.897618-05:00","updated_at":"2025-12-17T01:42:38.897618-05:00","dependencies":[{"issue_id":"keyp-2fx.6","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:42:38.9008104-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.7","title":"Implement initCmd.RunE with password validation","description":"PROBLEM: init command needs to create vault with password.\n\nLOCATION: cmd/keyp/init.go\n\nAPPROACH:\nImplement runInit function:\n1. Resolve vault path (--path or default ~/.keyp)\n2. Check if vault already exists\n3. Prompt for password with confirmation (use ui.PromptConfirmPassword)\n4. Validate password length (minimum 8 characters)\n5. Call vault.Init with path and password\n\nfunc runInit(cmd *cobra.Command, args []string) error {\n    path := initPath\n    if path == \"\" {\n        home, err := os.UserHomeDir()\n        if err != nil {\n            return fmt.Errorf(\"cannot find home directory: %w\", err)\n        }\n        path = filepath.Join(home, \".keyp\")\n    }\n    \n    // Check if exists\n    if _, err := os.Stat(path); err == nil {\n        return fmt.Errorf(\"vault already exists at %s\", path)\n    }\n    \n    // Prompt for password\n    password, err := ui.PromptConfirmPassword(\n        \"Enter vault password: \",\n        \"Confirm password: \",\n    )\n    if err != nil {\n        return err\n    }\n    \n    // Validate length\n    if len(password) \u003c 8 {\n        return fmt.Errorf(\"password must be at least 8 characters\")\n    }\n    \n    // Create vault\n    if err := vault.Init(path, password); err != nil {\n        return fmt.Errorf(\"failed to initialize vault: %w\", err)\n    }\n    \n    fmt.Printf(\"Vault initialized at %s\\n\", path)\n    return nil\n}\n\nACCEPTANCE:\n- Creates vault directory and database\n- Rejects weak passwords\n- Shows error if vault exists\n- Successful init prints confirmation","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:43:30.9546738-05:00","updated_at":"2025-12-17T01:43:30.9546738-05:00","dependencies":[{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:43:30.9578583-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx.6","type":"blocks","created_at":"2025-12-17T08:59:27.3120535-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx.2","type":"blocks","created_at":"2025-12-17T08:59:28.6665999-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.8","title":"Add cobra setCmd scaffold with --stdin flag","description":"PROBLEM: Need set command for quick single-field secret creation.\n\nLOCATION: cmd/keyp/set.go (create new file)\n\nAPPROACH:\n1. Create set.go with cobra command scaffold\n2. Args: \u003cname\u003e [value] - value optional if --stdin\n3. Add --stdin flag to read value from stdin\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar setStdin bool\n\nvar setCmd = \u0026cobra.Command{\n    Use:   \"set \u003cname\u003e [value]\",\n    Short: \"Set a secret value\",\n    Long:  \"Create or update a secret. Value can be provided as argument or via stdin.\",\n    Args:  cobra.RangeArgs(1, 2),\n    RunE:  runSet,\n}\n\nfunc init() {\n    setCmd.Flags().BoolVar(\u0026setStdin, \"stdin\", false, \"Read value from stdin\")\n    rootCmd.AddCommand(setCmd)\n}\n\nfunc runSet(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp set --help shows usage\n- Args validation works (1-2 args)\n- --stdin flag documented\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:44:10.2818698-05:00","updated_at":"2025-12-17T01:44:10.2818698-05:00","dependencies":[{"issue_id":"keyp-2fx.8","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:44:10.2845014-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.9","title":"Implement setCmd.RunE for single-field secrets","description":"PROBLEM: set command needs to create/update single-field secrets.\n\nLOCATION: cmd/keyp/set.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Get value from arg or stdin\n3. Create SecretObject with single 'value' field\n4. If secret exists, update; otherwise create\n\nfunc runSet(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Get value\n    var value string\n    if setStdin {\n        bytes, err := io.ReadAll(os.Stdin)\n        if err != nil {\n            return fmt.Errorf(\"failed to read stdin: %w\", err)\n        }\n        value = strings.TrimSpace(string(bytes))\n    } else if len(args) \u003e 1 {\n        value = args[1]\n    } else {\n        // Prompt for value\n        var err error\n        value, err = ui.PromptPassword(\"Enter value: \")\n        if err != nil {\n            return err\n        }\n    }\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Create secret with single field\n    secret := model.NewSecret(name)\n    secret.AddField(\"value\", value, true, \"password\")\n    \n    // Try create, if exists then update\n    if err := v.Store().Create(cmd.Context(), secret); err != nil {\n        if errors.Is(err, store.ErrAlreadyExists) {\n            // Update existing\n            existing, _ := v.Store().GetByName(cmd.Context(), name)\n            existing.Fields = secret.Fields\n            if err := v.Store().Update(cmd.Context(), existing); err != nil {\n                return fmt.Errorf(\"failed to update secret: %w\", err)\n            }\n        } else {\n            return fmt.Errorf(\"failed to create secret: %w\", err)\n        }\n    }\n    \n    fmt.Printf(\"Secret '%s' saved\\n\", name)\n    return nil\n}\n\nACCEPTANCE:\n- Creates new secret with value field\n- Updates existing secret\n- Reads from stdin with --stdin\n- Prompts if no value provided\n- Prints confirmation","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:45:11.6596176-05:00","updated_at":"2025-12-17T01:45:11.6596176-05:00","dependencies":[{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:45:11.6633437-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx.8","type":"blocks","created_at":"2025-12-17T08:59:30.0370607-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:59:31.3928086-05:00","created_by":"daemon"}]}
{"id":"keyp-36c","title":"Phase 7: HTTP Server Mode","description":"Implement HTTP REST API for GUI application.\n\nComponents:\n1. Foundation:\n   - Response envelope type\n   - Router with middleware (logging, panic recovery)\n\n2. Authentication:\n   - Session store (memory-based)\n   - Token generation\n   - POST /v1/unlock, POST /v1/lock, POST /v1/refresh\n   - Auth middleware\n\n3. Public Endpoints (no auth):\n   - GET /health\n   - GET /version\n\n4. Protected Endpoints (require auth):\n   - GET/POST /v1/secrets\n   - GET/PUT/DELETE /v1/secrets/:name\n   - GET /v1/search?q=\n   - POST /v1/secrets/:name/clipboard\n\n5. Server Lifecycle:\n   - keyp serve command\n   - Graceful shutdown\n\nDEPENDS: Phase 3 epic, Phase 6 epic (VaultHandle)\n\nACCEPTANCE:\n- All endpoints respond correctly\n- Auth flow works\n- Integration tests pass\n- keyp serve starts and handles requests","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:37:38.0669699-05:00","updated_at":"2025-12-17T08:37:38.0669699-05:00","dependencies":[{"issue_id":"keyp-36c","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:54.5095599-05:00","created_by":"daemon"},{"issue_id":"keyp-36c","depends_on_id":"keyp-elp","type":"blocks","created_at":"2025-12-17T09:07:55.8597843-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.1","title":"Define API response envelope in internal/server/types.go","description":"PROBLEM: Need consistent JSON response format for API.\n\nLOCATION: internal/server/types.go (create new file and directory)\n\nAPPROACH:\nCreate response envelope types:\n\npackage server\n\n// Response is the standard API response envelope\ntype Response struct {\n    OK    bool        `json:\"ok\"`\n    Data  interface{} `json:\"data,omitempty\"`\n    Error *APIError   `json:\"error,omitempty\"`\n}\n\n// APIError represents an error response\ntype APIError struct {\n    Code    string `json:\"code\"`\n    Message string `json:\"message\"`\n}\n\n// Common error codes\nconst (\n    ErrCodeUnauthorized    = \"UNAUTHORIZED\"\n    ErrCodeNotFound        = \"NOT_FOUND\"\n    ErrCodeBadRequest      = \"BAD_REQUEST\"\n    ErrCodeConflict        = \"CONFLICT\"\n    ErrCodeInternalError   = \"INTERNAL_ERROR\"\n)\n\n// Helper functions\nfunc SuccessResponse(data interface{}) Response {\n    return Response{OK: true, Data: data}\n}\n\nfunc ErrorResponse(code, message string) Response {\n    return Response{OK: false, Error: \u0026APIError{Code: code, Message: message}}\n}\n\nACCEPTANCE:\n- Response struct defined with json tags\n- APIError struct defined\n- Error code constants defined\n- Helper functions for creating responses\n- go build ./internal/server/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:38:22.9492552-05:00","updated_at":"2025-12-17T08:38:22.9492552-05:00","dependencies":[{"issue_id":"keyp-36c.1","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:38:22.9519135-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.10","title":"Implement POST /v1/refresh handler","description":"PROBLEM: Need endpoint to extend session without re-entering password.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\nPOST /v1/refresh\nAuthorization: Bearer \u003ctoken\u003e\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"expires_at\": \"2025-01-01T13:00:00Z\"}}\n\nAPPROACH:\ntype RefreshResponse struct {\n    ExpiresAt time.Time `json:\"expires_at\"`\n}\n\nfunc (s *Server) handleRefresh(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    \n    // Extend session expiry (not VaultHandle timeout)\n    if err := s.sessions.Refresh(session.Token, s.sessionTimeout); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to refresh session\"))\n        return\n    }\n    \n    // Get updated session\n    session, _ = s.sessions.Get(session.Token)\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(RefreshResponse{\n        ExpiresAt: session.ExpiresAt,\n    }))\n}\n\nACCEPTANCE:\n- Extends session expiry\n- Returns new expiry time\n- Requires auth (via middleware)\n- Does NOT extend VaultHandle timeout (that's separate)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:44:33.8667073-05:00","updated_at":"2025-12-17T08:44:33.8667073-05:00","dependencies":[{"issue_id":"keyp-36c.10","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:44:33.8693638-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.10","depends_on_id":"keyp-36c.8","type":"blocks","created_at":"2025-12-17T09:04:38.0546522-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.11","title":"Implement GET /health endpoint","description":"PROBLEM: Need health check endpoint for monitoring.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"status\": \"ok\"}}\n\nAPPROACH:\ntype HealthResponse struct {\n    Status string `json:\"status\"`\n}\n\nfunc (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {\n    writeJSON(w, http.StatusOK, SuccessResponse(HealthResponse{\n        Status: \"ok\",\n    }))\n}\n\nACCEPTANCE:\n- Returns 200 with status ok\n- No auth required\n- Simple and fast","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:45:02.9347428-05:00","updated_at":"2025-12-17T08:45:02.9347428-05:00","dependencies":[{"issue_id":"keyp-36c.11","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:45:02.9373949-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.11","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:04:39.5091411-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.12","title":"Implement GET /version endpoint","description":"PROBLEM: Need version endpoint for client compatibility checking.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"version\": \"2.0.0\", \"go_version\": \"go1.21\", \"build_time\": \"2025-01-01T00:00:00Z\"}}\n\nAPPROACH:\nvar (\n    Version   = \"dev\"\n    GoVersion = runtime.Version()\n    BuildTime = \"unknown\"\n)\n\ntype VersionResponse struct {\n    Version   string `json:\"version\"`\n    GoVersion string `json:\"go_version\"`\n    BuildTime string `json:\"build_time\"`\n}\n\nfunc (s *Server) handleVersion(w http.ResponseWriter, r *http.Request) {\n    writeJSON(w, http.StatusOK, SuccessResponse(VersionResponse{\n        Version:   Version,\n        GoVersion: GoVersion,\n        BuildTime: BuildTime,\n    }))\n}\n\nACCEPTANCE:\n- Returns version info\n- No auth required\n- Variables can be set via ldflags at build time","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:45:38.3794434-05:00","updated_at":"2025-12-17T08:45:38.3794434-05:00","dependencies":[{"issue_id":"keyp-36c.12","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:45:38.3827034-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.12","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:56.3639769-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.13","title":"Define SecretListItem and SecretDetail types for API responses","description":"PROBLEM: Need response types for secrets endpoints.\n\nLOCATION: internal/server/types.go\n\nAPPROACH:\nAdd API response types:\n\n// SecretListItem is used in list responses (minimal info)\ntype SecretListItem struct {\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\n// SecretDetail is used in get responses (full info, redacted by default)\ntype SecretDetail struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    Fields    []Field   `json:\"fields\"`\n    Notes     string    `json:\"notes\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\n// Field matches model.Field\ntype Field struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type\"`\n}\n\n// Conversion helpers\nfunc ToSecretListItem(s *model.SecretObject) SecretListItem { ... }\nfunc ToSecretDetail(s *model.SecretObject, redact bool) SecretDetail { ... }\n\nACCEPTANCE:\n- List item type with minimal fields\n- Detail type with all fields\n- Conversion helpers from model types\n- Uses SecretObject.Redacted() for masking","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:46:25.0289477-05:00","updated_at":"2025-12-17T08:46:25.0289477-05:00","dependencies":[{"issue_id":"keyp-36c.13","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:46:25.0316077-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.13","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:57.5402347-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.14","title":"Implement GET /v1/secrets endpoint","description":"PROBLEM: Need endpoint to list all secrets.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": [{\"name\": \"github\", \"tags\": [\"dev\"], \"created_at\": \"...\", \"updated_at\": \"...\"}]}\n\nAPPROACH:\nfunc (s *Server) handleListSecrets(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    secrets, err := store.List(r.Context())\n    if err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to list secrets\"))\n        return\n    }\n    \n    // Convert to API types\n    items := make([]SecretListItem, len(secrets))\n    for i, s := range secrets {\n        items[i] = ToSecretListItem(s)\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(items))\n}\n\nACCEPTANCE:\n- Returns list of secrets\n- Uses SecretListItem (minimal fields)\n- Requires auth\n- Empty list returns []","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:47:03.1925642-05:00","updated_at":"2025-12-17T08:47:03.1925642-05:00","dependencies":[{"issue_id":"keyp-36c.14","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:47:03.1951859-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.14","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:05:19.7783138-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.14","depends_on_id":"keyp-nlk.6","type":"blocks","created_at":"2025-12-17T09:05:21.1308442-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.15","title":"Implement GET /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to get secret details.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc\", \"name\": \"github\", \"tags\": [], \"fields\": [{\"label\": \"value\", \"value\": \"********\", \"sensitive\": true}], ...}}\n\nAPPROACH:\nfunc (s *Server) handleGetSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Return redacted by default (sensitive values masked)\n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusOK, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Returns secret with all fields\n- Sensitive values masked by default\n- Returns 404 if not found\n- Uses path parameter for name","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:47:45.5559366-05:00","updated_at":"2025-12-17T08:47:45.5559366-05:00","dependencies":[{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:47:45.5586131-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:22.4832394-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:05:23.856098-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.16","title":"Define CreateSecretRequest and UpdateSecretRequest types","description":"PROBLEM: Need request types for POST/PUT secrets.\n\nLOCATION: internal/server/types.go\n\nAPPROACH:\nAdd request types:\n\ntype CreateSecretRequest struct {\n    Name   string        `json:\"name\"`\n    Tags   []string      `json:\"tags,omitempty\"`\n    Fields []FieldInput  `json:\"fields\"`\n    Notes  string        `json:\"notes,omitempty\"`\n}\n\ntype FieldInput struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type,omitempty\"` // defaults to \"text\"\n}\n\ntype UpdateSecretRequest struct {\n    Tags   *[]string     `json:\"tags,omitempty\"`\n    Fields *[]FieldInput `json:\"fields,omitempty\"`\n    Notes  *string       `json:\"notes,omitempty\"`\n}\n\n// Conversion helper\nfunc (r *CreateSecretRequest) ToSecretObject() *model.SecretObject { ... }\n\nNOTE: UpdateSecretRequest uses pointers to distinguish \"not provided\" from \"empty\"\n\nACCEPTANCE:\n- CreateSecretRequest for POST\n- UpdateSecretRequest for PUT (partial updates)\n- Conversion helpers to model types\n- go build ./internal/server/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:48:39.0236809-05:00","updated_at":"2025-12-17T08:48:39.0236809-05:00","dependencies":[{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:48:39.0263219-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:25.2038743-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:05:26.5640479-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.17","title":"Implement POST /v1/secrets endpoint","description":"PROBLEM: Need endpoint to create secrets.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\n{\"name\": \"github\", \"fields\": [{\"label\": \"token\", \"value\": \"ghp_xxx\", \"sensitive\": true}]}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc123\", \"name\": \"github\", ...}}\n\nAPPROACH:\nfunc (s *Server) handleCreateSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    var req CreateSecretRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Validate\n    if req.Name == \"\" {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Name is required\"))\n        return\n    }\n    if len(req.Fields) == 0 {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"At least one field is required\"))\n        return\n    }\n    \n    // Convert and create\n    secret := req.ToSecretObject()\n    if err := store.Create(r.Context(), secret); err != nil {\n        if errors.Is(err, storeErr.ErrAlreadyExists) {\n            writeJSON(w, http.StatusConflict, ErrorResponse(ErrCodeConflict, \"Secret already exists\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to create secret\"))\n        return\n    }\n    \n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusCreated, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Creates secret from JSON body\n- Returns 201 on success\n- Returns 409 if name exists\n- Validates required fields","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:49:30.7083884-05:00","updated_at":"2025-12-17T08:49:30.7083884-05:00","dependencies":[{"issue_id":"keyp-36c.17","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:49:30.7110385-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.17","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:05:50.851562-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.18","title":"Implement PUT /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to update secrets.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\n{\"tags\": [\"new-tag\"], \"fields\": [{\"label\": \"token\", \"value\": \"new-value\", \"sensitive\": true}]}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc123\", \"name\": \"github\", ...}}\n\nAPPROACH:\nfunc (s *Server) handleUpdateSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    // Get existing secret\n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Parse update request\n    var req UpdateSecretRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Apply updates (only non-nil fields)\n    if req.Tags != nil {\n        secret.Tags = *req.Tags\n    }\n    if req.Fields != nil {\n        secret.Fields = convertFields(*req.Fields)\n    }\n    if req.Notes != nil {\n        secret.Notes = *req.Notes\n    }\n    \n    // Update\n    if err := store.Update(r.Context(), secret); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to update secret\"))\n        return\n    }\n    \n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusOK, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Updates existing secret\n- Partial updates (only provided fields)\n- Returns 404 if not found\n- Uses store.Update","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:50:25.1305792-05:00","updated_at":"2025-12-17T08:50:25.1305792-05:00","dependencies":[{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:50:25.133196-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:52.2463093-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c.17","type":"blocks","created_at":"2025-12-17T09:05:53.6780741-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.19","title":"Implement DELETE /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to delete secrets.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE: 204 No Content\n\nAPPROACH:\nfunc (s *Server) handleDeleteSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    if err := store.Delete(r.Context(), name); err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to delete secret\"))\n        return\n    }\n    \n    w.WriteHeader(http.StatusNoContent)\n}\n\nACCEPTANCE:\n- Deletes secret by name\n- Returns 204 on success (no body)\n- Returns 404 if not found\n- Requires auth","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:51:00.1925796-05:00","updated_at":"2025-12-17T08:51:00.1925796-05:00","dependencies":[{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:51:00.1952043-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:55.1217952-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c.17","type":"blocks","created_at":"2025-12-17T09:05:56.5408558-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T09:05:57.9559246-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.2","title":"Create internal/server/router.go with middleware chain","description":"PROBLEM: Need HTTP router with middleware support.\n\nLOCATION: internal/server/router.go (create new file)\n\nAPPROACH:\nUse stdlib http.ServeMux or chi router:\n\npackage server\n\nimport (\n    \"net/http\"\n)\n\ntype Server struct {\n    mux     *http.ServeMux\n    address string\n    vault   *vault.VaultHandle\n    sessions *SessionStore\n}\n\nfunc NewServer(address string, vaultPath string) *Server {\n    s := \u0026Server{\n        mux:      http.NewServeMux(),\n        address:  address,\n        sessions: NewSessionStore(),\n    }\n    \n    s.setupRoutes()\n    return s\n}\n\nfunc (s *Server) setupRoutes() {\n    // Public routes\n    s.mux.HandleFunc(\"GET /health\", s.handleHealth)\n    s.mux.HandleFunc(\"GET /version\", s.handleVersion)\n    \n    // Auth routes\n    s.mux.HandleFunc(\"POST /v1/unlock\", s.handleUnlock)\n    s.mux.HandleFunc(\"POST /v1/lock\", s.withAuth(s.handleLock))\n    s.mux.HandleFunc(\"POST /v1/refresh\", s.withAuth(s.handleRefresh))\n    \n    // Protected routes\n    s.mux.HandleFunc(\"GET /v1/secrets\", s.withAuth(s.handleListSecrets))\n    s.mux.HandleFunc(\"POST /v1/secrets\", s.withAuth(s.handleCreateSecret))\n    s.mux.HandleFunc(\"GET /v1/secrets/{name}\", s.withAuth(s.handleGetSecret))\n    s.mux.HandleFunc(\"PUT /v1/secrets/{name}\", s.withAuth(s.handleUpdateSecret))\n    s.mux.HandleFunc(\"DELETE /v1/secrets/{name}\", s.withAuth(s.handleDeleteSecret))\n    s.mux.HandleFunc(\"GET /v1/search\", s.withAuth(s.handleSearch))\n    s.mux.HandleFunc(\"POST /v1/secrets/{name}/clipboard\", s.withAuth(s.handleClipboard))\n}\n\n// Handler returns the http.Handler with middleware\nfunc (s *Server) Handler() http.Handler {\n    return s.withLogging(s.withRecovery(s.mux))\n}\n\nACCEPTANCE:\n- Server struct with router\n- Routes registered for all endpoints\n- Middleware chain applied\n- go build ./internal/server/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:39:16.3544757-05:00","updated_at":"2025-12-17T08:39:16.3544757-05:00","dependencies":[{"issue_id":"keyp-36c.2","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:39:16.3570956-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.2","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:03:57.8937505-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.20","title":"Implement GET /v1/search endpoint","description":"PROBLEM: Need endpoint for full-text search.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST: GET /v1/search?q=github\n\nRESPONSE:\n{\"ok\": true, \"data\": [{\"name\": \"github\", \"tags\": [\"dev\"], ...}]}\n\nAPPROACH:\nfunc (s *Server) handleSearch(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    query := r.URL.Query().Get(\"q\")\n    if query == \"\" {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Query parameter 'q' is required\"))\n        return\n    }\n    \n    results, err := store.Search(r.Context(), query, storeTypes.SearchOptions{})\n    if err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Search failed\"))\n        return\n    }\n    \n    // Convert to list items\n    items := make([]SecretListItem, len(results))\n    for i, s := range results {\n        items[i] = ToSecretListItem(s)\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(items))\n}\n\nACCEPTANCE:\n- Searches via query parameter q\n- Returns matching secrets as list items\n- Returns 400 if q missing\n- Uses store.Search (FTS5)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:51:44.2089116-05:00","updated_at":"2025-12-17T08:51:44.2089116-05:00","dependencies":[{"issue_id":"keyp-36c.20","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:51:44.2121709-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.20","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:59.3741497-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.21","title":"Implement POST /v1/secrets/:name/clipboard endpoint","description":"PROBLEM: Need endpoint to copy secret field to server clipboard.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST: POST /v1/secrets/:name/clipboard\n{\"field\": \"password\"}\n\nRESPONSE:\n{\"ok\": true}\n\nAPPROACH:\ntype ClipboardRequest struct {\n    Field string `json:\"field,omitempty\"` // defaults to first field\n}\n\nfunc (s *Server) handleClipboard(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    // Get secret\n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Parse request\n    var req ClipboardRequest\n    json.NewDecoder(r.Body).Decode(\u0026req) // OK if empty\n    \n    // Find field value\n    var value string\n    if req.Field != \"\" {\n        for _, f := range secret.Fields {\n            if f.Label == req.Field {\n                value = f.Value\n                break\n            }\n        }\n        if value == \"\" {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Field not found\"))\n            return\n        }\n    } else if len(secret.Fields) \u003e 0 {\n        value = secret.Fields[0].Value\n    }\n    \n    // Copy to clipboard (server-side)\n    if err := ui.CopyWithAutoClear(value, ui.DefaultClearDuration); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to copy to clipboard\"))\n        return\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(nil))\n}\n\nACCEPTANCE:\n- Copies field value to server clipboard\n- Optional field parameter (defaults to first)\n- Auto-clears after 45s\n- Returns 404 if secret/field not found","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:52:39.1152053-05:00","updated_at":"2025-12-17T08:52:39.1152053-05:00","dependencies":[{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:52:39.1178804-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:06:24.1863955-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:06:25.4986847-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T09:06:26.8134145-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.22","title":"Add cobra serveCmd scaffold with --port, --bind, --timeout flags","description":"PROBLEM: Need serve command to start HTTP server.\n\nLOCATION: cmd/keyp/serve.go (create new file)\n\nAPPROACH:\nCreate serve command:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    servePort    int\n    serveBind    string\n    serveTimeout string\n)\n\nvar serveCmd = \u0026cobra.Command{\n    Use:   \"serve\",\n    Short: \"Start HTTP server\",\n    Long:  \"Start the keyp HTTP server for GUI access.\",\n    RunE:  runServe,\n}\n\nfunc init() {\n    serveCmd.Flags().IntVar(\u0026servePort, \"port\", 9999, \"Port to listen on\")\n    serveCmd.Flags().StringVar(\u0026serveBind, \"bind\", \"127.0.0.1\", \"Address to bind to\")\n    serveCmd.Flags().StringVar(\u0026serveTimeout, \"timeout\", \"15m\", \"Session timeout\")\n    rootCmd.AddCommand(serveCmd)\n}\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp serve --help shows usage\n- --port, --bind, --timeout flags documented\n- Defaults: port 9999, bind 127.0.0.1, timeout 15m\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:53:27.7235439-05:00","updated_at":"2025-12-17T08:53:27.7235439-05:00","dependencies":[{"issue_id":"keyp-36c.22","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:53:27.7256425-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.22","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:06:28.1145986-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.22","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T09:06:29.4234222-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.23","title":"Implement Server.Start to begin listening","description":"PROBLEM: Need to start HTTP server.\n\nLOCATION: internal/server/server.go and cmd/keyp/serve.go\n\nAPPROACH:\nIn internal/server/server.go:\n\nfunc (s *Server) Start() error {\n    s.httpServer = \u0026http.Server{\n        Addr:    s.address,\n        Handler: s.Handler(),\n    }\n    \n    log.Printf(\"Starting server on %s\", s.address)\n    \n    if err := s.httpServer.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n        return fmt.Errorf(\"server error: %w\", err)\n    }\n    \n    return nil\n}\n\nIn cmd/keyp/serve.go:\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    timeout, err := time.ParseDuration(serveTimeout)\n    if err != nil {\n        return fmt.Errorf(\"invalid timeout: %w\", err)\n    }\n    \n    address := fmt.Sprintf(\"%s:%d\", serveBind, servePort)\n    \n    srv := server.NewServer(address, getVaultPath())\n    srv.SetSessionTimeout(timeout)\n    \n    fmt.Printf(\"Server starting on http://%s\\n\", address)\n    fmt.Println(\"Press Ctrl+C to stop\")\n    \n    return srv.Start()\n}\n\nACCEPTANCE:\n- Server binds to specified address\n- Logs startup message\n- ListenAndServe blocks until stopped\n- Returns error on bind failure","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:54:17.0767352-05:00","updated_at":"2025-12-17T08:54:17.0767352-05:00","dependencies":[{"issue_id":"keyp-36c.23","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:54:17.0793499-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.24","title":"Implement Server.Shutdown for graceful termination","description":"PROBLEM: Need graceful shutdown on SIGINT/SIGTERM.\n\nLOCATION: internal/server/server.go and cmd/keyp/serve.go\n\nAPPROACH:\nIn internal/server/server.go:\n\nfunc (s *Server) Shutdown(ctx context.Context) error {\n    log.Println(\"Shutting down server...\")\n    \n    // Lock all active sessions' vault handles\n    s.sessions.LockAll()\n    \n    // Shutdown HTTP server\n    if err := s.httpServer.Shutdown(ctx); err != nil {\n        return fmt.Errorf(\"shutdown error: %w\", err)\n    }\n    \n    log.Println(\"Server stopped\")\n    return nil\n}\n\nIn cmd/keyp/serve.go (update runServe):\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    // ... server setup ...\n    \n    // Setup signal handling\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n    \n    // Start server in goroutine\n    errCh := make(chan error, 1)\n    go func() {\n        errCh \u003c- srv.Start()\n    }()\n    \n    // Wait for signal or error\n    select {\n    case \u003c-sigCh:\n        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n        defer cancel()\n        return srv.Shutdown(ctx)\n    case err := \u003c-errCh:\n        return err\n    }\n}\n\nACCEPTANCE:\n- Handles SIGINT and SIGTERM\n- Graceful shutdown with timeout\n- Locks all vault handles before exit\n- Drains active connections","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:55:00.4936526-05:00","updated_at":"2025-12-17T08:55:00.4936526-05:00","dependencies":[{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:55:00.4962735-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.23","type":"blocks","created_at":"2025-12-17T09:06:56.3838534-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:06:57.9010309-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.15","type":"blocks","created_at":"2025-12-17T09:06:59.4237107-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.16","type":"blocks","created_at":"2025-12-17T09:07:00.9544806-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.18","type":"blocks","created_at":"2025-12-17T09:07:02.4887928-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.19","type":"blocks","created_at":"2025-12-17T09:07:04.0108349-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.20","type":"blocks","created_at":"2025-12-17T09:07:05.5583031-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.21","type":"blocks","created_at":"2025-12-17T09:07:07.1621527-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.22","type":"blocks","created_at":"2025-12-17T09:07:08.6800679-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.25","title":"Add HTTP server integration tests","description":"PROBLEM: HTTP server needs integration tests.\n\nLOCATION: internal/server/server_test.go (create new file)\n\nTEST SCENARIOS:\n1. Auth Flow:\n   - POST /v1/unlock with correct password returns token\n   - POST /v1/unlock with wrong password returns 401\n   - Protected endpoints without token return 401\n   - Protected endpoints with invalid token return 401\n   - POST /v1/lock invalidates session\n   - POST /v1/refresh extends session\n\n2. Public Endpoints:\n   - GET /health returns ok\n   - GET /version returns version info\n\n3. CRUD Operations:\n   - POST /v1/secrets creates secret\n   - GET /v1/secrets lists secrets\n   - GET /v1/secrets/:name returns secret\n   - PUT /v1/secrets/:name updates secret\n   - DELETE /v1/secrets/:name deletes secret\n   - Operations on non-existent return 404\n\n4. Search:\n   - GET /v1/search?q=... returns matches\n   - Empty query returns 400\n\n5. Error Handling:\n   - Invalid JSON returns 400\n   - Missing required fields returns 400\n\nAPPROACH:\nUse httptest.Server for testing. Create test vault.\n\nACCEPTANCE:\n- go test ./internal/server/ passes\n- Tests cover auth flow, CRUD, search, errors\n- Tests clean up resources","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:55:54.7428142-05:00","updated_at":"2025-12-17T08:55:54.7428142-05:00","dependencies":[{"issue_id":"keyp-36c.25","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:55:54.7454534-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.25","depends_on_id":"keyp-36c.24","type":"blocks","created_at":"2025-12-17T09:07:26.2824306-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.3","title":"Add request logging middleware","description":"PROBLEM: Need to log HTTP requests for debugging.\n\nLOCATION: internal/server/middleware.go (create new file)\n\nAPPROACH:\nCreate logging middleware:\n\npackage server\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"time\"\n)\n\n// responseWriter wraps http.ResponseWriter to capture status code\ntype responseWriter struct {\n    http.ResponseWriter\n    status int\n}\n\nfunc (rw *responseWriter) WriteHeader(code int) {\n    rw.status = code\n    rw.ResponseWriter.WriteHeader(code)\n}\n\nfunc (s *Server) withLogging(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        \n        rw := \u0026responseWriter{ResponseWriter: w, status: http.StatusOK}\n        next.ServeHTTP(rw, r)\n        \n        duration := time.Since(start)\n        log.Printf(\"%s %s %d %v\", r.Method, r.URL.Path, rw.status, duration)\n    })\n}\n\nACCEPTANCE:\n- Logs method, path, status, duration\n- Captures actual status code\n- Doesn't interfere with response\n- go build ./internal/server/ compiles","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:39:55.2852505-05:00","updated_at":"2025-12-17T08:39:55.2852505-05:00","dependencies":[{"issue_id":"keyp-36c.3","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:39:55.2873559-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.3","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:03:59.0989926-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.4","title":"Add panic recovery middleware","description":"PROBLEM: Need to catch panics and return 500 error.\n\nLOCATION: internal/server/middleware.go\n\nAPPROACH:\nAdd recovery middleware:\n\nfunc (s *Server) withRecovery(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"panic: %v\", err)\n                \n                w.Header().Set(\"Content-Type\", \"application/json\")\n                w.WriteHeader(http.StatusInternalServerError)\n                \n                resp := ErrorResponse(ErrCodeInternalError, \"Internal server error\")\n                json.NewEncoder(w).Encode(resp)\n            }\n        }()\n        \n        next.ServeHTTP(w, r)\n    })\n}\n\nACCEPTANCE:\n- Catches panics\n- Returns 500 with error envelope\n- Logs panic for debugging\n- Doesn't crash server\n- go build ./internal/server/ compiles","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:40:29.7426079-05:00","updated_at":"2025-12-17T08:40:29.7426079-05:00","dependencies":[{"issue_id":"keyp-36c.4","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:40:29.7452896-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.4","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:00.3162976-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.5","title":"Define SessionStore interface and MemorySessionStore","description":"PROBLEM: Need session management for API authentication.\n\nLOCATION: internal/server/session.go (create new file)\n\nAPPROACH:\nCreate session store with in-memory implementation:\n\npackage server\n\nimport (\n    \"sync\"\n    \"time\"\n    \"github.com/TheEditor/keyp/internal/vault\"\n)\n\ntype Session struct {\n    Token     string\n    Handle    *vault.VaultHandle\n    CreatedAt time.Time\n    ExpiresAt time.Time\n}\n\ntype SessionStore interface {\n    Create(handle *vault.VaultHandle, expiry time.Duration) (*Session, error)\n    Get(token string) (*Session, error)\n    Delete(token string) error\n    Refresh(token string, expiry time.Duration) error\n    Cleanup() // Remove expired sessions\n}\n\ntype MemorySessionStore struct {\n    mu       sync.RWMutex\n    sessions map[string]*Session\n}\n\nfunc NewSessionStore() *MemorySessionStore {\n    store := \u0026MemorySessionStore{\n        sessions: make(map[string]*Session),\n    }\n    \n    // Start cleanup goroutine\n    go store.cleanupLoop()\n    \n    return store\n}\n\nfunc (m *MemorySessionStore) cleanupLoop() {\n    ticker := time.NewTicker(time.Minute)\n    for range ticker.C {\n        m.Cleanup()\n    }\n}\n\nACCEPTANCE:\n- Session struct with token, handle, timestamps\n- SessionStore interface defined\n- MemorySessionStore implements interface\n- Thread-safe with mutex\n- go build ./internal/server/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:41:11.265588-05:00","updated_at":"2025-12-17T08:41:11.265588-05:00","dependencies":[{"issue_id":"keyp-36c.5","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:41:11.2677233-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.6","title":"Add token generation using crypto/rand","description":"PROBLEM: Need secure token generation for sessions.\n\nLOCATION: internal/server/session.go\n\nAPPROACH:\nAdd token generation function:\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n)\n\nconst TokenBytes = 32 // 256 bits\n\nfunc generateToken() (string, error) {\n    bytes := make([]byte, TokenBytes)\n    if _, err := rand.Read(bytes); err != nil {\n        return \"\", fmt.Errorf(\"failed to generate token: %w\", err)\n    }\n    return hex.EncodeToString(bytes), nil\n}\n\n// Used in SessionStore.Create\nfunc (m *MemorySessionStore) Create(handle *vault.VaultHandle, expiry time.Duration) (*Session, error) {\n    token, err := generateToken()\n    if err != nil {\n        return nil, err\n    }\n    \n    session := \u0026Session{\n        Token:     token,\n        Handle:    handle,\n        CreatedAt: time.Now(),\n        ExpiresAt: time.Now().Add(expiry),\n    }\n    \n    m.mu.Lock()\n    m.sessions[token] = session\n    m.mu.Unlock()\n    \n    return session, nil\n}\n\nACCEPTANCE:\n- Generates 32 bytes (256 bits) of randomness\n- Returns hex-encoded string (64 chars)\n- Uses crypto/rand (not math/rand)\n- go build ./internal/server/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:41:51.2034473-05:00","updated_at":"2025-12-17T08:41:51.2034473-05:00","dependencies":[{"issue_id":"keyp-36c.6","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:41:51.207313-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.6","depends_on_id":"keyp-36c.5","type":"blocks","created_at":"2025-12-17T09:04:29.1142115-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.6","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:04:30.5675369-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.7","title":"Implement POST /v1/unlock handler","description":"PROBLEM: Need endpoint to unlock vault and get session token.\n\nLOCATION: internal/server/handlers.go (create new file)\n\nREQUEST:\nPOST /v1/unlock\n{\"password\": \"vault-password\"}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"token\": \"abc123...\", \"expires_at\": \"2025-01-01T12:00:00Z\"}}\n\nAPPROACH:\ntype UnlockRequest struct {\n    Password string `json:\"password\"`\n}\n\ntype UnlockResponse struct {\n    Token     string    `json:\"token\"`\n    ExpiresAt time.Time `json:\"expires_at\"`\n}\n\nfunc (s *Server) handleUnlock(w http.ResponseWriter, r *http.Request) {\n    var req UnlockRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Create vault handle and unlock\n    handle := vault.NewHandle(s.vaultPath)\n    if err := handle.Unlock(req.Password); err != nil {\n        writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Invalid password\"))\n        return\n    }\n    \n    // Create session\n    session, err := s.sessions.Create(handle, s.sessionTimeout)\n    if err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to create session\"))\n        return\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(UnlockResponse{\n        Token:     session.Token,\n        ExpiresAt: session.ExpiresAt,\n    }))\n}\n\nACCEPTANCE:\n- Accepts password in JSON body\n- Returns token and expiry on success\n- Returns 401 for wrong password\n- Creates session in store","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:42:38.7991609-05:00","updated_at":"2025-12-17T08:42:38.7991609-05:00","dependencies":[{"issue_id":"keyp-36c.7","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:42:38.8018168-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.7","depends_on_id":"keyp-36c.6","type":"blocks","created_at":"2025-12-17T09:04:32.0172146-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.8","title":"Implement POST /v1/lock handler","description":"PROBLEM: Need endpoint to lock vault and invalidate session.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\nPOST /v1/lock\nAuthorization: Bearer \u003ctoken\u003e\n\nRESPONSE:\n{\"ok\": true}\n\nAPPROACH:\nfunc (s *Server) handleLock(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    \n    // Lock the vault handle\n    if err := session.Handle.Lock(); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to lock vault\"))\n        return\n    }\n    \n    // Delete session\n    if err := s.sessions.Delete(session.Token); err != nil {\n        // Log but don't fail - vault is locked\n        log.Printf(\"failed to delete session: %v\", err)\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(nil))\n}\n\nACCEPTANCE:\n- Locks vault handle\n- Deletes session from store\n- Returns 200 on success\n- Requires auth (via middleware)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:43:14.3927604-05:00","updated_at":"2025-12-17T08:43:14.3927604-05:00","dependencies":[{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:43:14.3953804-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c.7","type":"blocks","created_at":"2025-12-17T09:04:33.5700584-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:35.0897039-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.9","title":"Add auth middleware for Bearer token extraction","description":"PROBLEM: Protected endpoints need auth verification.\n\nLOCATION: internal/server/middleware.go\n\nAPPROACH:\nCreate auth middleware:\n\ntype contextKey string\n\nconst sessionKey contextKey = \"session\"\n\nfunc (s *Server) withAuth(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Extract Bearer token\n        auth := r.Header.Get(\"Authorization\")\n        if !strings.HasPrefix(auth, \"Bearer \") {\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Missing or invalid Authorization header\"))\n            return\n        }\n        \n        token := strings.TrimPrefix(auth, \"Bearer \")\n        \n        // Lookup session\n        session, err := s.sessions.Get(token)\n        if err != nil {\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Invalid or expired token\"))\n            return\n        }\n        \n        // Check expiry\n        if time.Now().After(session.ExpiresAt) {\n            s.sessions.Delete(token)\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Session expired\"))\n            return\n        }\n        \n        // Add session to context\n        ctx := context.WithValue(r.Context(), sessionKey, session)\n        next.ServeHTTP(w, r.WithContext(ctx))\n    }\n}\n\nfunc getSessionFromContext(ctx context.Context) *Session {\n    return ctx.Value(sessionKey).(*Session)\n}\n\nACCEPTANCE:\n- Extracts Bearer token from Authorization header\n- Looks up session in store\n- Returns 401 for invalid/expired tokens\n- Adds session to request context\n- Helper to get session from context","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:43:58.5758484-05:00","updated_at":"2025-12-17T08:43:58.5758484-05:00","dependencies":[{"issue_id":"keyp-36c.9","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:43:58.5786207-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.9","depends_on_id":"keyp-36c.8","type":"blocks","created_at":"2025-12-17T09:04:36.5743545-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy","title":"Phase 2: SQLite storage and data model","description":"Implement SecretObject/Field model types, SQLite storage with FTS5 full-text search, and vault lifecycle management.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-15T15:53:33.8534241-05:00","updated_at":"2025-12-15T16:06:09.3011272-05:00","closed_at":"2025-12-15T16:06:09.3011272-05:00","close_reason":"Phase 2 complete: SQLite storage and data model. All model, store, vault, and sync components implemented."}
{"id":"keyp-8wy.1","title":"Implement SecretObject and Field model types","description":"Create domain model types for structured secrets with SecretObject containing Fields, plus factory functions and helper methods.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:54:00.3436226-05:00","updated_at":"2025-12-15T15:58:28.0239955-05:00","closed_at":"2025-12-15T15:58:28.0239955-05:00","close_reason":"Implemented model types with SecretObject and Field, factory functions, and JSON serialization","dependencies":[{"issue_id":"keyp-8wy.1","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:00.346373-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.2","title":"Implement SQLite store with FTS5 search","description":"Create SQLite storage layer with full-text search using FTS5 virtual table, schema initialization, CRUD operations, and search functionality.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:54:28.0531579-05:00","updated_at":"2025-12-15T16:01:42.808729-05:00","closed_at":"2025-12-15T16:01:42.808729-05:00","close_reason":"Implemented SQLite store with FTS5, schema initialization, CRUD operations, and full-text search","dependencies":[{"issue_id":"keyp-8wy.2","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:28.057009-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.2","depends_on_id":"keyp-8wy.1","type":"blocks","created_at":"2025-12-15T15:56:07.4203974-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.3","title":"Add store unit tests","description":"Create comprehensive tests for SQLite store covering create, get, list, search, delete operations and error cases.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:54:53.5112156-05:00","updated_at":"2025-12-15T16:02:44.8984634-05:00","closed_at":"2025-12-15T16:02:44.8984634-05:00","close_reason":"Added comprehensive store tests covering create, get, list, search, delete and error cases","dependencies":[{"issue_id":"keyp-8wy.3","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:53.5138695-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.3","depends_on_id":"keyp-8wy.2","type":"blocks","created_at":"2025-12-15T15:56:08.9283899-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.4","title":"Implement vault lifecycle manager","description":"Create vault manager handling init, unlock, lock operations with store lifecycle and locked state checking.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:55:18.7213627-05:00","updated_at":"2025-12-15T16:03:57.6889325-05:00","closed_at":"2025-12-15T16:03:57.6889325-05:00","close_reason":"Implemented vault lifecycle manager with init, open, lock, and store delegation","dependencies":[{"issue_id":"keyp-8wy.4","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:55:18.7235388-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.4","depends_on_id":"keyp-8wy.2","type":"blocks","created_at":"2025-12-15T15:56:10.4521036-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.5","title":"Define git sync interface with placeholder implementation","description":"Create sync interface to isolate future git dependency with NoopSyncer placeholder implementation.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T15:55:44.9482487-05:00","updated_at":"2025-12-15T16:05:18.5312202-05:00","closed_at":"2025-12-15T16:05:18.5312202-05:00","close_reason":"Implemented sync interface with NoopSyncer placeholder for Phase 3 git implementation","dependencies":[{"issue_id":"keyp-8wy.5","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:55:44.9508875-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.5","depends_on_id":"keyp-8wy.4","type":"blocks","created_at":"2025-12-15T15:56:11.9399496-05:00","created_by":"daemon"}]}
{"id":"keyp-elp","title":"Phase 6: Vault Lock/Unlock UX","description":"Implement VaultHandle for persistent unlock and CLI lock/unlock commands.\n\nComponents:\n1. VaultHandle struct (shared by CLI and HTTP server):\n   - Holds open db, derived key, unlock timestamp\n   - Unlock/Lock/IsExpired methods\n\n2. CLI Commands:\n   - keyp unlock [--timeout]: unlock vault, keep handle\n   - keyp lock: explicitly lock vault\n   - Auto-lock: check expiry before each command\n\nDEPENDS: Phase 3 epic (core CLI)\n\nACCEPTANCE:\n- VaultHandle manages unlock state\n- unlock/lock commands work\n- Auto-lock after timeout works\n- Unit and integration tests pass","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:29:58.9695451-05:00","updated_at":"2025-12-17T08:29:58.9695451-05:00","dependencies":[{"issue_id":"keyp-elp","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:53.1615882-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.1","title":"Define VaultHandle struct in internal/vault/handle.go","description":"PROBLEM: Need shared handle for persistent vault unlock state.\n\nLOCATION: internal/vault/handle.go (create new file)\n\nAPPROACH:\nCreate VaultHandle struct:\n\npackage vault\n\nimport (\n    \"sync\"\n    \"time\"\n    \"github.com/TheEditor/keyp/internal/store\"\n)\n\ntype VaultHandle struct {\n    mu        sync.RWMutex\n    store     *store.SQLiteStore\n    key       []byte // Derived encryption key\n    unlockedAt time.Time\n    path      string\n}\n\n// New creates unlocked handle (call Unlock to actually unlock)\nfunc NewHandle(path string) *VaultHandle {\n    return \u0026VaultHandle{path: path}\n}\n\n// Path returns the vault path\nfunc (h *VaultHandle) Path() string {\n    return h.path\n}\n\n// Store returns the store (nil if locked)\nfunc (h *VaultHandle) Store() *store.SQLiteStore {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    return h.store\n}\n\n// IsUnlocked returns true if vault is currently unlocked\nfunc (h *VaultHandle) IsUnlocked() bool {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    return h.store != nil\n}\n\nACCEPTANCE:\n- VaultHandle struct defined\n- Basic accessors implemented\n- Thread-safe with mutex\n- go build ./internal/vault/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:30:40.4152864-05:00","updated_at":"2025-12-17T08:30:40.4152864-05:00","dependencies":[{"issue_id":"keyp-elp.1","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:30:40.4227006-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.10","title":"Add CLI lock/unlock integration tests","description":"PROBLEM: Lock/unlock functionality needs integration tests.\n\nLOCATION: cmd/keyp/cli_test.go (add to existing)\n\nTEST SCENARIOS:\n1. Unlock:\n   - Unlocks vault with correct password\n   - Fails with wrong password\n   - Subsequent commands don't prompt\n\n2. Lock:\n   - Locks unlocked vault\n   - No error if already locked\n   - Commands prompt after lock\n\n3. Auto-lock:\n   - Vault auto-locks after timeout\n   - User prompted on next command\n\n4. Session persistence:\n   - Multiple commands use same session\n   - Session extended on each use\n\nAPPROACH:\nUse test vault and simulate multiple command invocations.\nMay need to mock time for timeout tests.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover lock/unlock/auto-lock scenarios\n- Tests verify security behavior","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:36:52.0305462-05:00","updated_at":"2025-12-17T08:36:52.0305462-05:00","dependencies":[{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:36:52.0337055-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.7","type":"blocks","created_at":"2025-12-17T09:03:36.8612075-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.6","type":"blocks","created_at":"2025-12-17T09:03:38.3222935-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.9","type":"blocks","created_at":"2025-12-17T09:03:39.7708399-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.2","title":"Add VaultHandle.Unlock method","description":"PROBLEM: Need to unlock vault with password.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement Unlock method:\n\nfunc (h *VaultHandle) Unlock(password string) error {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    \n    if h.store != nil {\n        return nil // Already unlocked\n    }\n    \n    // Derive key from password\n    key, err := core.DeriveKey(password, h.getSalt())\n    if err != nil {\n        return fmt.Errorf(\"failed to derive key: %w\", err)\n    }\n    \n    // Open store with derived key\n    dbPath := filepath.Join(h.path, \"vault.db\")\n    s, err := store.Open(dbPath, key)\n    if err != nil {\n        // Zero key memory on failure\n        for i := range key {\n            key[i] = 0\n        }\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    \n    h.store = s\n    h.key = key\n    h.unlockedAt = time.Now()\n    \n    return nil\n}\n\n// Helper to get salt from vault\nfunc (h *VaultHandle) getSalt() []byte {\n    saltPath := filepath.Join(h.path, \"salt\")\n    salt, _ := os.ReadFile(saltPath)\n    return salt\n}\n\nACCEPTANCE:\n- Derives key from password\n- Opens store connection\n- Stores unlock timestamp\n- Returns nil if already unlocked\n- Zeros key on failure","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:31:23.3708923-05:00","updated_at":"2025-12-17T08:31:23.3708923-05:00","dependencies":[{"issue_id":"keyp-elp.2","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:31:23.379507-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.2","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:55.0328153-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.3","title":"Add VaultHandle.Lock method","description":"PROBLEM: Need to securely lock vault.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement Lock method that securely clears sensitive data:\n\nfunc (h *VaultHandle) Lock() error {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    \n    if h.store == nil {\n        return nil // Already locked\n    }\n    \n    // Close store connection\n    if err := h.store.Close(); err != nil {\n        return fmt.Errorf(\"failed to close store: %w\", err)\n    }\n    \n    // Zero key memory\n    for i := range h.key {\n        h.key[i] = 0\n    }\n    \n    // Clear state\n    h.store = nil\n    h.key = nil\n    h.unlockedAt = time.Time{}\n    \n    return nil\n}\n\nACCEPTANCE:\n- Closes database connection\n- Zeros key memory\n- Clears all sensitive state\n- Returns nil if already locked\n- Thread-safe","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:31:57.7955119-05:00","updated_at":"2025-12-17T08:31:57.7955119-05:00","dependencies":[{"issue_id":"keyp-elp.3","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:31:57.7993021-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.3","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:56.3923926-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.4","title":"Add VaultHandle.IsExpired method for timeout check","description":"PROBLEM: Need to check if vault unlock has expired.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement IsExpired method:\n\nconst DefaultTimeout = 15 * time.Minute\n\nfunc (h *VaultHandle) IsExpired(timeout time.Duration) bool {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    \n    if h.store == nil {\n        return true // Locked is considered expired\n    }\n    \n    if timeout \u003c= 0 {\n        timeout = DefaultTimeout\n    }\n    \n    return time.Since(h.unlockedAt) \u003e timeout\n}\n\n// UnlockedAt returns when vault was unlocked\nfunc (h *VaultHandle) UnlockedAt() time.Time {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    return h.unlockedAt\n}\n\n// RefreshUnlock resets the unlock timestamp (extends session)\nfunc (h *VaultHandle) RefreshUnlock() {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    if h.store != nil {\n        h.unlockedAt = time.Now()\n    }\n}\n\nACCEPTANCE:\n- IsExpired returns true if timeout exceeded\n- Locked vault returns true (expired)\n- Uses default 15m timeout if not specified\n- RefreshUnlock extends session\n- Thread-safe","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:32:38.4766338-05:00","updated_at":"2025-12-17T08:32:38.4766338-05:00","dependencies":[{"issue_id":"keyp-elp.4","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:32:38.4797944-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.4","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:57.7499191-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.5","title":"Add vault handle unit tests","description":"PROBLEM: VaultHandle needs unit tests.\n\nLOCATION: internal/vault/handle_test.go (create new file)\n\nTEST CASES:\n1. NewHandle:\n   - Creates handle with correct path\n   - Initially locked (IsUnlocked returns false)\n\n2. Unlock:\n   - Returns nil on success\n   - Sets unlock timestamp\n   - IsUnlocked returns true after unlock\n   - Returns nil if already unlocked\n\n3. Lock:\n   - Returns nil on success\n   - IsUnlocked returns false after lock\n   - Returns nil if already locked\n   - Key memory zeroed\n\n4. IsExpired:\n   - Returns true if locked\n   - Returns false immediately after unlock\n   - Returns true after timeout\n   - Respects custom timeout\n\n5. RefreshUnlock:\n   - Resets expiry timer\n\nAPPROACH:\nUse test vault with known password.\nMock time for expiry tests if needed.\n\nACCEPTANCE:\n- go test ./internal/vault/ passes\n- Tests cover all methods\n- Tests verify security (key zeroing)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:33:20.3099971-05:00","updated_at":"2025-12-17T08:33:20.3099971-05:00","dependencies":[{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:33:20.3137725-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.2","type":"blocks","created_at":"2025-12-17T09:02:59.1078021-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.3","type":"blocks","created_at":"2025-12-17T09:03:00.473616-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.4","type":"blocks","created_at":"2025-12-17T09:03:01.845018-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.6","title":"Add cobra unlockCmd with --timeout flag","description":"PROBLEM: Need unlock command for persistent vault session.\n\nLOCATION: cmd/keyp/unlock.go (create new file)\n\nAPPROACH:\nCreate unlock command that stores VaultHandle:\n\npackage main\n\nimport (\n    \"time\"\n    \"github.com/spf13/cobra\"\n)\n\nvar unlockTimeout string\n\nvar unlockCmd = \u0026cobra.Command{\n    Use:   \"unlock\",\n    Short: \"Unlock the vault\",\n    Long:  \"Unlock the vault and keep it unlocked for subsequent commands.\",\n    RunE:  runUnlock,\n}\n\nfunc init() {\n    unlockCmd.Flags().StringVar(\u0026unlockTimeout, \"timeout\", \"15m\", \"Auto-lock timeout (e.g., 15m, 1h)\")\n    rootCmd.AddCommand(unlockCmd)\n}\n\nfunc runUnlock(cmd *cobra.Command, args []string) error {\n    // Parse timeout\n    timeout, err := time.ParseDuration(unlockTimeout)\n    if err != nil {\n        return fmt.Errorf(\"invalid timeout: %w\", err)\n    }\n    \n    // Prompt for password\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    // Get or create handle\n    handle := getVaultHandle()\n    if err := handle.Unlock(password); err != nil {\n        return err\n    }\n    \n    // Store handle for subsequent commands\n    // (implementation depends on session storage mechanism)\n    \n    fmt.Printf(\"Vault unlocked (auto-locks in %s)\\n\", timeout)\n    return nil\n}\n\nACCEPTANCE:\n- Prompts for password\n- Unlocks vault handle\n- --timeout configures auto-lock duration\n- Prints confirmation","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:34:12.6000713-05:00","updated_at":"2025-12-17T08:34:12.6000713-05:00","dependencies":[{"issue_id":"keyp-elp.6","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:34:12.6032678-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.6","depends_on_id":"keyp-elp.2","type":"blocks","created_at":"2025-12-17T09:03:29.542914-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.7","title":"Add cobra lockCmd","description":"PROBLEM: Need lock command to explicitly lock vault.\n\nLOCATION: cmd/keyp/lock.go (create new file)\n\nAPPROACH:\nCreate lock command:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar lockCmd = \u0026cobra.Command{\n    Use:   \"lock\",\n    Short: \"Lock the vault\",\n    Long:  \"Explicitly lock the vault, clearing all sensitive data from memory.\",\n    RunE:  runLock,\n}\n\nfunc init() {\n    rootCmd.AddCommand(lockCmd)\n}\n\nfunc runLock(cmd *cobra.Command, args []string) error {\n    handle := getVaultHandle()\n    \n    if !handle.IsUnlocked() {\n        fmt.Println(\"Vault is already locked\")\n        return nil\n    }\n    \n    if err := handle.Lock(); err != nil {\n        return fmt.Errorf(\"failed to lock vault: %w\", err)\n    }\n    \n    fmt.Println(\"Vault locked\")\n    return nil\n}\n\nACCEPTANCE:\n- Calls VaultHandle.Lock\n- Clears stored handle\n- Prints confirmation\n- No error if already locked","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:34:48.9451038-05:00","updated_at":"2025-12-17T08:34:48.9451038-05:00","dependencies":[{"issue_id":"keyp-elp.7","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:34:48.9531251-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.7","depends_on_id":"keyp-elp.3","type":"blocks","created_at":"2025-12-17T09:03:31.0202439-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.8","title":"Refactor CLI commands to use stored VaultHandle","description":"PROBLEM: CLI commands should use stored handle instead of prompting each time.\n\nLOCATION: cmd/keyp/*.go (multiple files)\n\nAPPROACH:\n1. Create shared function to get vault handle:\n\nfunc getOrUnlockVault(cmd *cobra.Command) (*vault.VaultHandle, error) {\n    handle := getVaultHandle()\n    \n    // Check if already unlocked and valid\n    if handle.IsUnlocked() \u0026\u0026 !handle.IsExpired(getTimeout()) {\n        handle.RefreshUnlock() // Extend session\n        return handle, nil\n    }\n    \n    // Need to unlock - prompt for password\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return nil, err\n    }\n    \n    if err := handle.Unlock(password); err != nil {\n        return nil, err\n    }\n    \n    return handle, nil\n}\n\n2. Update all commands (get, set, list, delete, show, edit, search, tag):\n   - Replace individual vault.Open calls with getOrUnlockVault\n   - Remove defer v.Close() (handle manages lifecycle)\n\nACCEPTANCE:\n- Commands use stored handle if valid\n- Prompt only when locked/expired\n- Session extended on each use\n- All commands still work correctly","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:35:32.2537456-05:00","updated_at":"2025-12-17T08:35:32.2537456-05:00","dependencies":[{"issue_id":"keyp-elp.8","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:35:32.2622006-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.8","depends_on_id":"keyp-elp.6","type":"blocks","created_at":"2025-12-17T09:03:32.4728044-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.9","title":"Add CLI auto-lock: check expiry before each command","description":"PROBLEM: Need to auto-lock when timeout expires.\n\nLOCATION: cmd/keyp/root.go or cmd/keyp/vault.go\n\nAPPROACH:\nAdd pre-run hook to check expiry and lock if needed:\n\n// In root.go, add PersistentPreRunE\nvar rootCmd = \u0026cobra.Command{\n    Use:   \"keyp\",\n    Short: \"A local-first secret manager\",\n    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n        // Skip for commands that don't need vault\n        if cmd.Name() == \"init\" || cmd.Name() == \"version\" || cmd.Name() == \"help\" {\n            return nil\n        }\n        \n        handle := getVaultHandle()\n        if handle.IsUnlocked() \u0026\u0026 handle.IsExpired(getTimeout()) {\n            // Auto-lock expired session\n            if err := handle.Lock(); err \\!= nil {\n                return fmt.Errorf(\"failed to auto-lock: %w\", err)\n            }\n            // Don't print message - user will be prompted to unlock\n        }\n        \n        return nil\n    },\n}\n\nACCEPTANCE:\n- Checks expiry before each command\n- Auto-locks if expired\n- Doesn't interfere with init/version/help\n- User prompted to unlock on next command","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:36:15.4580328-05:00","updated_at":"2025-12-17T08:36:15.4580328-05:00","dependencies":[{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:36:15.4622541-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp.8","type":"blocks","created_at":"2025-12-17T09:03:33.9432025-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp.4","type":"blocks","created_at":"2025-12-17T09:03:35.4118516-05:00","created_by":"daemon"}]}
{"id":"keyp-laz","title":"Phase 4: Multi-Field Secrets \u0026 Search","description":"Implement advanced CLI commands for multi-field secrets, display, editing, search, and tags.\n\nComponents:\n1. Interactive Secret Creation:\n   - PromptLoop helper for multi-field input\n   - keyp add \u003cname\u003e: interactive multi-field creation\n\n2. Secret Display \u0026 Editing:\n   - keyp show \u003cname\u003e [--reveal]: display all fields (mask sensitive)\n   - keyp edit \u003cname\u003e [--field]: modify fields\n\n3. Search \u0026 Tags:\n   - keyp search \u003cquery\u003e: FTS5 full-text search\n   - keyp tag add|rm|list: manage tags\n\nDEPENDS: Phase 3 epic (core CLI), Phase 2.5 store.Update and store.Search\n\nACCEPTANCE:\n- All commands functional\n- Integration tests pass\n- Multi-field secrets work correctly\n- Search returns relevant results","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:51:42.6646528-05:00","updated_at":"2025-12-17T01:51:42.6646528-05:00","dependencies":[{"issue_id":"keyp-laz","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:50.4655177-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.1","title":"Add PromptLoop helper for multi-field input","description":"PROBLEM: add command needs to prompt for multiple fields until user is done.\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd helper function that repeatedly prompts for input until empty line or max count:\n\nconst MaxFields = 20\n\ntype FieldInput struct {\n    Label     string\n    Value     string\n    Sensitive bool\n    Type      string\n}\n\nfunc PromptLoop(maxFields int) ([]FieldInput, error) {\n    if maxFields \u003c= 0 {\n        maxFields = MaxFields\n    }\n    \n    var fields []FieldInput\n    \n    for i := 0; i \u003c maxFields; i++ {\n        // Prompt for label\n        label, err := PromptVisible(fmt.Sprintf(\"Field %d label (empty to finish): \", i+1))\n        if err != nil {\n            return nil, err\n        }\n        if label == \"\" {\n            break\n        }\n        \n        // Prompt for type\n        fieldType, err := PromptVisible(\"  Type [text/password/pin/url] (default: text): \")\n        if err != nil {\n            return nil, err\n        }\n        if fieldType == \"\" {\n            fieldType = \"text\"\n        }\n        \n        // Prompt for sensitive\n        sensStr, err := PromptVisible(\"  Sensitive? [y/N]: \")\n        if err != nil {\n            return nil, err\n        }\n        sensitive := strings.ToLower(sensStr) == \"y\" || strings.ToLower(sensStr) == \"yes\"\n        \n        // Prompt for value\n        var value string\n        if sensitive {\n            value, err = PromptPassword(\"  Value: \")\n        } else {\n            value, err = PromptVisible(\"  Value: \")\n        }\n        if err != nil {\n            return nil, err\n        }\n        \n        fields = append(fields, FieldInput{\n            Label:     label,\n            Value:     value,\n            Sensitive: sensitive,\n            Type:      fieldType,\n        })\n    }\n    \n    return fields, nil\n}\n\nACCEPTANCE:\n- Prompts for fields until empty label\n- Collects label, type, sensitive, value for each\n- Respects maxFields limit\n- Uses hidden input for sensitive values\n- go build ./internal/ui/ compiles","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:52:45.9465837-05:00","updated_at":"2025-12-17T01:52:45.9465837-05:00","dependencies":[{"issue_id":"keyp-laz.1","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T01:52:45.9493904-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.1","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T09:00:47.0245382-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.10","title":"Add cobra tagCmd scaffold with add/rm/list subcommands","description":"PROBLEM: Need tag command with subcommands to manage secret tags.\n\nLOCATION: cmd/keyp/tag.go (create new file)\n\nAPPROACH:\n1. Create tag.go with cobra command scaffold\n2. Add subcommands: add, rm, list\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar tagCmd = \u0026cobra.Command{\n    Use:   \"tag\",\n    Short: \"Manage secret tags\",\n    Long:  \"Add, remove, or list tags on secrets.\",\n}\n\nvar tagAddCmd = \u0026cobra.Command{\n    Use:   \"add \u003csecret\u003e \u003ctag\u003e\",\n    Short: \"Add a tag to a secret\",\n    Args:  cobra.ExactArgs(2),\n    RunE:  runTagAdd,\n}\n\nvar tagRmCmd = \u0026cobra.Command{\n    Use:   \"rm \u003csecret\u003e \u003ctag\u003e\",\n    Short: \"Remove a tag from a secret\",\n    Args:  cobra.ExactArgs(2),\n    RunE:  runTagRm,\n}\n\nvar tagListCmd = \u0026cobra.Command{\n    Use:   \"list [secret]\",\n    Short: \"List tags (all or for specific secret)\",\n    Args:  cobra.MaximumNArgs(1),\n    RunE:  runTagList,\n}\n\nfunc init() {\n    tagCmd.AddCommand(tagAddCmd)\n    tagCmd.AddCommand(tagRmCmd)\n    tagCmd.AddCommand(tagListCmd)\n    rootCmd.AddCommand(tagCmd)\n}\n\nACCEPTANCE:\n- keyp tag --help shows subcommands\n- keyp tag add --help shows usage\n- keyp tag rm --help shows usage\n- keyp tag list --help shows usage\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:20:12.7781974-05:00","updated_at":"2025-12-17T08:20:12.7781974-05:00","dependencies":[{"issue_id":"keyp-laz.10","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:20:12.7861603-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.11","title":"Implement tagCmd subcommands for tag management","description":"PROBLEM: tag subcommands need to modify secret.Tags array.\n\nLOCATION: cmd/keyp/tag.go\n\nAPPROACH:\nImplement all three tag subcommands:\n\nfunc runTagAdd(cmd *cobra.Command, args []string) error {\n    name, tag := args[0], args[1]\n    \n    password, _ := ui.PromptPassword(\"Vault password: \")\n    v, _ := vault.Open(getVaultPath(), password)\n    defer v.Close()\n    \n    secret, err := v.Store().GetByName(cmd.Context(), name)\n    if err != nil {\n        return fmt.Errorf(\"secret '%s' not found\", name)\n    }\n    \n    // Check if tag already exists\n    for _, t := range secret.Tags {\n        if t == tag {\n            return fmt.Errorf(\"tag '%s' already exists on '%s'\", tag, name)\n        }\n    }\n    \n    secret.Tags = append(secret.Tags, tag)\n    if err := v.Store().Update(cmd.Context(), secret); err != nil {\n        return err\n    }\n    \n    fmt.Printf(\"Added tag '%s' to '%s'\\n\", tag, name)\n    return nil\n}\n\nfunc runTagRm(cmd *cobra.Command, args []string) error {\n    name, tag := args[0], args[1]\n    \n    // Similar pattern - find and remove tag from slice\n    // Use store.Update to save\n}\n\nfunc runTagList(cmd *cobra.Command, args []string) error {\n    // If arg given, show tags for that secret\n    // If no arg, list all unique tags across all secrets\n}\n\nACCEPTANCE:\n- tag add appends tag to secret.Tags\n- tag add rejects duplicate tags\n- tag rm removes tag from secret.Tags\n- tag list shows tags for specific secret\n- tag list (no args) shows all unique tags","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:21:07.6373528-05:00","updated_at":"2025-12-17T08:21:07.6373528-05:00","dependencies":[{"issue_id":"keyp-laz.11","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:21:07.6458323-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.11","depends_on_id":"keyp-laz.10","type":"blocks","created_at":"2025-12-17T09:01:25.4355434-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.12","title":"Add Phase 4 integration tests","description":"PROBLEM: Phase 4 commands need integration tests.\n\nLOCATION: cmd/keyp/cli_test.go (add to existing)\n\nTEST SCENARIOS:\n1. Add workflow:\n   - keyp add creates multi-field secret\n   - Requires at least one field\n   - Rejects duplicate names\n\n2. Show workflow:\n   - keyp show displays all fields\n   - Sensitive fields masked by default\n   - --reveal shows actual values\n\n3. Edit workflow:\n   - keyp edit modifies field values\n   - --field targets specific field\n   - Empty input preserves value\n\n4. Search workflow:\n   - keyp search finds by name\n   - keyp search finds by tag\n   - No results shows message\n\n5. Tag workflow:\n   - keyp tag add adds tag\n   - keyp tag rm removes tag\n   - keyp tag list shows tags\n\nAPPROACH:\nExtend existing cli_test.go with new test cases.\nUse test vault from Phase 3 tests.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover Phase 4 commands\n- Tests are independent (can run in any order)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:21:50.2737891-05:00","updated_at":"2025-12-17T08:21:50.2737891-05:00","dependencies":[{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:21:50.2817433-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.3","type":"blocks","created_at":"2025-12-17T09:01:26.8794201-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.5","type":"blocks","created_at":"2025-12-17T09:01:28.3256598-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.7","type":"blocks","created_at":"2025-12-17T09:01:29.7935864-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.9","type":"blocks","created_at":"2025-12-17T09:01:31.2809868-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.11","type":"blocks","created_at":"2025-12-17T09:01:32.737488-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.2","title":"Add cobra addCmd scaffold for interactive multi-field creation","description":"PROBLEM: Need add command for creating secrets with multiple fields interactively.\n\nLOCATION: cmd/keyp/add.go (create new file)\n\nAPPROACH:\n1. Create add.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar addCmd = \u0026cobra.Command{\n    Use:   \"add \u003cname\u003e\",\n    Short: \"Add a new secret with multiple fields\",\n    Long:  \"Create a new secret with interactive prompts for multiple fields.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runAdd,\n}\n\nfunc init() {\n    rootCmd.AddCommand(addCmd)\n}\n\nfunc runAdd(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp add --help shows usage\n- Args validation works (exactly 1 arg)\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:13:07.3526239-05:00","updated_at":"2025-12-17T08:13:07.3526239-05:00","dependencies":[{"issue_id":"keyp-laz.2","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:13:07.3555759-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.3","title":"Implement addCmd.RunE with PromptLoop for multi-field secrets","description":"PROBLEM: add command needs to create secrets with multiple fields.\n\nLOCATION: cmd/keyp/add.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Use PromptLoop to collect fields\n3. Create SecretObject with all fields\n4. Save to store\n\nfunc runAdd(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Check if exists\n    _, err = v.Store().GetByName(cmd.Context(), name)\n    if err == nil {\n        return fmt.Errorf(\"secret '%s' already exists (use 'edit' to modify)\", name)\n    }\n    \n    fmt.Printf(\"Creating secret '%s'\\n\", name)\n    fmt.Println(\"Enter fields (empty label to finish):\")\n    \n    // Collect fields\n    fieldInputs, err := ui.PromptLoop(0)\n    if err != nil {\n        return err\n    }\n    \n    if len(fieldInputs) == 0 {\n        return fmt.Errorf(\"at least one field required\")\n    }\n    \n    // Create secret\n    secret := model.NewSecret(name)\n    for _, f := range fieldInputs {\n        secret.AddField(f.Label, f.Value, f.Sensitive, f.Type)\n    }\n    \n    if err := v.Store().Create(cmd.Context(), secret); err != nil {\n        return fmt.Errorf(\"failed to create secret: %w\", err)\n    }\n    \n    fmt.Printf(\"Secret '%s' created with %d fields\\n\", name, len(fieldInputs))\n    return nil\n}\n\nACCEPTANCE:\n- Creates multi-field secrets interactively\n- Requires at least one field\n- Rejects duplicate names\n- Shows field count on success","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:14:13.0126999-05:00","updated_at":"2025-12-17T08:14:13.0126999-05:00","dependencies":[{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:14:13.0164305-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz.2","type":"blocks","created_at":"2025-12-17T09:00:48.4335535-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz.1","type":"blocks","created_at":"2025-12-17T09:00:49.8383852-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.4","title":"Add cobra showCmd scaffold with --reveal flag","description":"PROBLEM: Need show command to display all fields of a secret.\n\nLOCATION: cmd/keyp/show.go (create new file)\n\nAPPROACH:\n1. Create show.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --reveal flag to show sensitive values\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar showReveal bool\n\nvar showCmd = \u0026cobra.Command{\n    Use:   \"show \u003cname\u003e\",\n    Short: \"Show secret details\",\n    Long:  \"Display all fields of a secret. Sensitive values are masked unless --reveal is used.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runShow,\n}\n\nfunc init() {\n    showCmd.Flags().BoolVar(\u0026showReveal, \"reveal\", false, \"Show sensitive values (default: masked)\")\n    rootCmd.AddCommand(showCmd)\n}\n\nfunc runShow(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp show --help shows usage\n- Args validation works (exactly 1 arg)\n- --reveal flag documented\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:14:54.2563816-05:00","updated_at":"2025-12-17T08:14:54.2563816-05:00","dependencies":[{"issue_id":"keyp-laz.4","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:14:54.259061-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.5","title":"Implement showCmd.RunE with field display","description":"PROBLEM: show command needs to display all secret fields.\n\nLOCATION: cmd/keyp/show.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Get secret by name\n3. Display all fields, masking sensitive unless --reveal\n\nfunc runShow(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Get secret\n    secret, err := v.Store().GetByName(cmd.Context(), name)\n    if err != nil {\n        if errors.Is(err, store.ErrNotFound) {\n            return fmt.Errorf(\"secret '%s' not found\", name)\n        }\n        return fmt.Errorf(\"failed to get secret: %w\", err)\n    }\n    \n    // Use redacted unless --reveal\n    display := secret\n    if !showReveal {\n        display = secret.Redacted()\n    }\n    \n    // Display header\n    fmt.Printf(\"Name: %s\\n\", display.Name)\n    if len(display.Tags) \u003e 0 {\n        fmt.Printf(\"Tags: %s\\n\", strings.Join(display.Tags, \", \"))\n    }\n    fmt.Printf(\"Created: %s\\n\", display.CreatedAt.Format(time.RFC3339))\n    fmt.Printf(\"Updated: %s\\n\", display.UpdatedAt.Format(time.RFC3339))\n    \n    // Display fields\n    fmt.Println(\"\\nFields:\")\n    for i, f := range display.Fields {\n        sensIndicator := \"\"\n        if f.Sensitive {\n            sensIndicator = \" [sensitive]\"\n        }\n        fmt.Printf(\"  %d. %s (%s)%s: %s\\n\", i+1, f.Label, f.Type, sensIndicator, f.Value)\n    }\n    \n    if display.Notes != \"\" {\n        fmt.Printf(\"\\nNotes:\\n%s\\n\", display.Notes)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Shows all secret metadata\n- Displays fields with labels and types\n- Masks sensitive values by default\n- --reveal shows actual values\n- Shows notes if present","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:16:00.5883855-05:00","updated_at":"2025-12-17T08:16:00.5883855-05:00","dependencies":[{"issue_id":"keyp-laz.5","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:16:00.5921014-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.5","depends_on_id":"keyp-laz.4","type":"blocks","created_at":"2025-12-17T09:00:51.2412371-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.6","title":"Add cobra editCmd scaffold with --field flag","description":"PROBLEM: Need edit command to modify existing secrets.\n\nLOCATION: cmd/keyp/edit.go (create new file)\n\nAPPROACH:\n1. Create edit.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --field flag to target specific field\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar editField string\n\nvar editCmd = \u0026cobra.Command{\n    Use:   \"edit \u003cname\u003e\",\n    Short: \"Edit an existing secret\",\n    Long:  \"Modify fields of an existing secret. Use --field to target a specific field.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runEdit,\n}\n\nfunc init() {\n    editCmd.Flags().StringVar(\u0026editField, \"field\", \"\", \"Specific field to edit (by label)\")\n    rootCmd.AddCommand(editCmd)\n}\n\nfunc runEdit(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp edit --help shows usage\n- Args validation works (exactly 1 arg)\n- --field flag documented\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:16:42.0215277-05:00","updated_at":"2025-12-17T08:16:42.0215277-05:00","dependencies":[{"issue_id":"keyp-laz.6","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:16:42.0241515-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.7","title":"Implement editCmd.RunE with store.Update","description":"PROBLEM: edit command needs to modify secrets using store.Update.\n\nLOCATION: cmd/keyp/edit.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Get existing secret\n3. If --field, edit just that field; otherwise show menu\n4. Call store.Update with modified secret\n\nfunc runEdit(cmd *cobra.Command, args []string) error {\n    name := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Get secret\n    secret, err := v.Store().GetByName(cmd.Context(), name)\n    if err != nil {\n        if errors.Is(err, store.ErrNotFound) {\n            return fmt.Errorf(\"secret '%s' not found\", name)\n        }\n        return fmt.Errorf(\"failed to get secret: %w\", err)\n    }\n    \n    // Show current state\n    fmt.Printf(\"Editing '%s'\\n\", name)\n    \n    if editField != \"\" {\n        // Edit specific field\n        idx := -1\n        for i, f := range secret.Fields {\n            if f.Label == editField {\n                idx = i\n                break\n            }\n        }\n        if idx == -1 {\n            return fmt.Errorf(\"field '%s' not found\", editField)\n        }\n        \n        f := \u0026secret.Fields[idx]\n        var newValue string\n        if f.Sensitive {\n            newValue, err = ui.PromptPassword(fmt.Sprintf(\"New value for '%s': \", f.Label))\n        } else {\n            newValue, err = ui.PromptVisible(fmt.Sprintf(\"New value for '%s': \", f.Label))\n        }\n        if err != nil {\n            return err\n        }\n        f.Value = newValue\n    } else {\n        // Interactive edit - prompt for each field\n        for i := range secret.Fields {\n            f := \u0026secret.Fields[i]\n            fmt.Printf(\"\\nField: %s (current: %s)\\n\", f.Label, maskIfSensitive(f))\n            \n            var newValue string\n            if f.Sensitive {\n                newValue, err = ui.PromptPassword(\"  New value (empty to keep): \")\n            } else {\n                newValue, err = ui.PromptVisible(\"  New value (empty to keep): \")\n            }\n            if err != nil {\n                return err\n            }\n            if newValue != \"\" {\n                f.Value = newValue\n            }\n        }\n    }\n    \n    // Update\n    if err := v.Store().Update(cmd.Context(), secret); err != nil {\n        return fmt.Errorf(\"failed to update secret: %w\", err)\n    }\n    \n    fmt.Printf(\"Secret '%s' updated\\n\", name)\n    return nil\n}\n\nACCEPTANCE:\n- Edits specific field with --field\n- Interactive edit prompts for each field without --field\n- Empty input keeps existing value\n- Uses store.Update to save changes","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:18:06.1261221-05:00","updated_at":"2025-12-17T08:18:06.1261221-05:00","dependencies":[{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:18:06.1302615-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz.6","type":"blocks","created_at":"2025-12-17T09:00:52.6633133-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz.5","type":"blocks","created_at":"2025-12-17T09:00:54.1403571-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T09:00:55.5503164-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.8","title":"Add cobra searchCmd scaffold using FTS5","description":"PROBLEM: Need search command for full-text search.\n\nLOCATION: cmd/keyp/search.go (create new file)\n\nAPPROACH:\n1. Create search.go with cobra command scaffold\n2. Args: \u003cquery\u003e - required\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar searchCmd = \u0026cobra.Command{\n    Use:   \"search \u003cquery\u003e\",\n    Short: \"Search secrets\",\n    Long:  \"Full-text search across secret names, tags, and notes.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runSearch,\n}\n\nfunc init() {\n    rootCmd.AddCommand(searchCmd)\n}\n\nfunc runSearch(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp search --help shows usage\n- Args validation works (exactly 1 arg)\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:18:40.6463336-05:00","updated_at":"2025-12-17T08:18:40.6463336-05:00","dependencies":[{"issue_id":"keyp-laz.8","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:18:40.6547949-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.9","title":"Implement searchCmd.RunE with store.Search","description":"PROBLEM: search command needs to query FTS5 via store.Search.\n\nLOCATION: cmd/keyp/search.go\n\nAPPROACH:\n1. Open vault (prompt for password)\n2. Call store.Search with query\n3. Display matching secrets\n\nfunc runSearch(cmd *cobra.Command, args []string) error {\n    query := args[0]\n    \n    // Open vault\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    v, err := vault.Open(getVaultPath(), password)\n    if err != nil {\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    defer v.Close()\n    \n    // Search\n    results, err := v.Store().Search(cmd.Context(), query, store.SearchOptions{})\n    if err != nil {\n        return fmt.Errorf(\"search failed: %w\", err)\n    }\n    \n    if len(results) == 0 {\n        fmt.Printf(\"No secrets matching '%s'\\n\", query)\n        return nil\n    }\n    \n    fmt.Printf(\"Found %d secrets matching '%s':\\n\\n\", len(results), query)\n    \n    for _, s := range results {\n        fmt.Printf(\"  %s\", s.Name)\n        if len(s.Tags) \u003e 0 {\n            fmt.Printf(\" [%s]\", strings.Join(s.Tags, \", \"))\n        }\n        fmt.Println()\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Searches name, tags, notes via FTS5\n- Shows matching secret names and tags\n- Shows count of results\n- No matches shows appropriate message","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:19:29.2487384-05:00","updated_at":"2025-12-17T08:19:29.2487384-05:00","dependencies":[{"issue_id":"keyp-laz.9","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:19:29.2519189-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.9","depends_on_id":"keyp-laz.8","type":"blocks","created_at":"2025-12-17T09:01:22.5169298-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.9","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T09:01:23.9685646-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz","title":"Phase 5: Git Sync","description":"Implement git-based sync for vault data using exec.Command.\n\nComponents:\n1. GitExecSyncer implementing Syncer interface from Phase 2\n2. Git operations: init, add-remote, commit, push, pull, status\n3. CLI commands: keyp sync init/push/pull/status\n\nDEPENDS: Phase 3 epic (core CLI)\n\nACCEPTANCE:\n- GitExecSyncer implements all Syncer methods\n- sync commands work with git repositories\n- Integration tests pass (requires git installed)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:22:28.559086-05:00","updated_at":"2025-12-17T08:22:28.559086-05:00","dependencies":[{"issue_id":"keyp-mrz","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:51.8154526-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.1","title":"Implement GitExecSyncer using exec.Command","description":"PROBLEM: Need git sync implementation using exec.Command.\n\nLOCATION: internal/sync/gitexec.go (create new file)\n\nAPPROACH:\nCreate GitExecSyncer struct that wraps git CLI commands:\n\npackage sync\n\nimport (\n    \"os/exec\"\n    \"path/filepath\"\n)\n\ntype GitExecSyncer struct {\n    vaultPath string\n}\n\nfunc NewGitExecSyncer(vaultPath string) *GitExecSyncer {\n    return \u0026GitExecSyncer{vaultPath: vaultPath}\n}\n\n// Helper to run git commands in vault directory\nfunc (g *GitExecSyncer) git(args ...string) (string, error) {\n    cmd := exec.Command(\"git\", args...)\n    cmd.Dir = g.vaultPath\n    output, err := cmd.CombinedOutput()\n    return string(output), err\n}\n\n// Verify it implements Syncer interface\nvar _ Syncer = (*GitExecSyncer)(nil)\n\nACCEPTANCE:\n- GitExecSyncer struct created\n- Helper git() method works\n- Implements Syncer interface\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:23:04.9414371-05:00","updated_at":"2025-12-17T08:23:04.9414371-05:00","dependencies":[{"issue_id":"keyp-mrz.1","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:23:04.9494857-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.2","title":"Add GitExecSyncer.Init for git init and .gitignore","description":"PROBLEM: Need to initialize git repository in vault directory.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Init method:\n\nfunc (g *GitExecSyncer) Init() error {\n    // Run git init\n    if _, err := g.git(\"init\"); err != nil {\n        return fmt.Errorf(\"git init failed: %w\", err)\n    }\n    \n    // Create .gitignore to exclude database file\n    gitignore := filepath.Join(g.vaultPath, \".gitignore\")\n    content := []byte(\"# Exclude SQLite database (encrypted data is in exported files)\\n*.db\\n*.db-journal\\n*.db-wal\\n*.db-shm\\n\")\n    if err := os.WriteFile(gitignore, content, 0644); err != nil {\n        return fmt.Errorf(\"failed to create .gitignore: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Creates .git directory in vault path\n- Creates .gitignore excluding *.db files\n- Returns error if git not installed\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:23:44.3607305-05:00","updated_at":"2025-12-17T08:23:44.3607305-05:00","dependencies":[{"issue_id":"keyp-mrz.2","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:23:44.3644288-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.2","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:54.3093841-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.3","title":"Add GitExecSyncer.AddRemote for git remote add","description":"PROBLEM: Need to add remote repository for push/pull.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement AddRemote method:\n\nfunc (g *GitExecSyncer) AddRemote(name, url string) error {\n    if name == \"\" {\n        name = \"origin\"\n    }\n    \n    if _, err := g.git(\"remote\", \"add\", name, url); err != nil {\n        return fmt.Errorf(\"git remote add failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (g *GitExecSyncer) RemoveRemote(name string) error {\n    if _, err := g.git(\"remote\", \"remove\", name); err != nil {\n        return fmt.Errorf(\"git remote remove failed: %w\", err)\n    }\n    return nil\n}\n\nfunc (g *GitExecSyncer) GetRemoteURL(name string) (string, error) {\n    output, err := g.git(\"remote\", \"get-url\", name)\n    if err != nil {\n        return \"\", fmt.Errorf(\"git remote get-url failed: %w\", err)\n    }\n    return strings.TrimSpace(output), nil\n}\n\nACCEPTANCE:\n- AddRemote adds named remote\n- Defaults to 'origin' if name empty\n- RemoveRemote removes remote\n- GetRemoteURL returns remote URL\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:24:32.39602-05:00","updated_at":"2025-12-17T08:24:32.39602-05:00","dependencies":[{"issue_id":"keyp-mrz.3","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:24:32.4039886-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.3","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:55.6260973-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.4","title":"Add GitExecSyncer.Commit for git add and commit","description":"PROBLEM: Need to commit changes to local repository.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Commit method:\n\nfunc (g *GitExecSyncer) Commit(message string) error {\n    // Stage all changes\n    if _, err := g.git(\"add\", \".\"); err != nil {\n        return fmt.Errorf(\"git add failed: %w\", err)\n    }\n    \n    // Check if there are changes to commit\n    output, _ := g.git(\"status\", \"--porcelain\")\n    if strings.TrimSpace(output) == \"\" {\n        return nil // Nothing to commit\n    }\n    \n    // Commit\n    if message == \"\" {\n        message = \"keyp: sync vault\"\n    }\n    if _, err := g.git(\"commit\", \"-m\", message); err != nil {\n        return fmt.Errorf(\"git commit failed: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Stages all changes with git add .\n- Commits with provided message\n- Uses default message if empty\n- Returns nil if nothing to commit\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:25:14.0839693-05:00","updated_at":"2025-12-17T08:25:14.0839693-05:00","dependencies":[{"issue_id":"keyp-mrz.4","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:25:14.0877165-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.4","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:56.9514091-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.5","title":"Add GitExecSyncer.Push and Pull methods","description":"PROBLEM: Need to sync with remote repository.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Push and Pull methods:\n\nfunc (g *GitExecSyncer) Push(remote, branch string) error {\n    if remote == \"\" {\n        remote = \"origin\"\n    }\n    if branch == \"\" {\n        branch = \"main\"\n    }\n    \n    if _, err := g.git(\"push\", remote, branch); err != nil {\n        return fmt.Errorf(\"git push failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (g *GitExecSyncer) Pull(remote, branch string) error {\n    if remote == \"\" {\n        remote = \"origin\"\n    }\n    if branch == \"\" {\n        branch = \"main\"\n    }\n    \n    if _, err := g.git(\"pull\", remote, branch); err != nil {\n        return fmt.Errorf(\"git pull failed: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Push sends commits to remote\n- Pull fetches and merges from remote\n- Defaults to origin/main\n- Returns descriptive errors\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:25:57.6473165-05:00","updated_at":"2025-12-17T08:25:57.6473165-05:00","dependencies":[{"issue_id":"keyp-mrz.5","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:25:57.6511177-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.5","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:58.2561954-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.6","title":"Add GitExecSyncer.Status for repository state","description":"PROBLEM: Need to check git repository status.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Status method that parses git status output:\n\ntype SyncStatus struct {\n    IsRepo      bool\n    HasChanges  bool\n    Branch      string\n    Ahead       int\n    Behind      int\n    Remote      string\n}\n\nfunc (g *GitExecSyncer) Status() (*SyncStatus, error) {\n    status := \u0026SyncStatus{}\n    \n    // Check if it's a git repo\n    if _, err := os.Stat(filepath.Join(g.vaultPath, \".git\")); os.IsNotExist(err) {\n        return status, nil\n    }\n    status.IsRepo = true\n    \n    // Get current branch\n    output, err := g.git(\"branch\", \"--show-current\")\n    if err == nil {\n        status.Branch = strings.TrimSpace(output)\n    }\n    \n    // Check for uncommitted changes\n    output, _ = g.git(\"status\", \"--porcelain\")\n    status.HasChanges = strings.TrimSpace(output) != \"\"\n    \n    // Check ahead/behind\n    output, err = g.git(\"rev-list\", \"--left-right\", \"--count\", \"@{upstream}...HEAD\")\n    if err == nil {\n        parts := strings.Fields(output)\n        if len(parts) == 2 {\n            status.Behind, _ = strconv.Atoi(parts[0])\n            status.Ahead, _ = strconv.Atoi(parts[1])\n        }\n    }\n    \n    // Get remote URL\n    status.Remote, _ = g.GetRemoteURL(\"origin\")\n    \n    return status, nil\n}\n\nACCEPTANCE:\n- Returns SyncStatus with repo state\n- Detects uncommitted changes\n- Shows ahead/behind counts\n- Works even if no upstream set\n- go build ./internal/sync/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:26:49.6120632-05:00","updated_at":"2025-12-17T08:26:49.6120632-05:00","dependencies":[{"issue_id":"keyp-mrz.6","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:26:49.6158593-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.6","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:59.5649665-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.7","title":"Add cobra syncCmd scaffold with init/push/pull/status subcommands","description":"PROBLEM: Need sync command with subcommands for git operations.\n\nLOCATION: cmd/keyp/sync.go (create new file)\n\nAPPROACH:\nCreate sync.go with cobra command and subcommands:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar syncCmd = \u0026cobra.Command{\n    Use:   \"sync\",\n    Short: \"Sync vault with git\",\n    Long:  \"Initialize, push, pull, or check status of vault git repository.\",\n}\n\nvar syncInitCmd = \u0026cobra.Command{\n    Use:   \"init [remote-url]\",\n    Short: \"Initialize git sync\",\n    Args:  cobra.MaximumNArgs(1),\n    RunE:  runSyncInit,\n}\n\nvar syncPushCmd = \u0026cobra.Command{\n    Use:   \"push\",\n    Short: \"Push vault to remote\",\n    RunE:  runSyncPush,\n}\n\nvar syncPullCmd = \u0026cobra.Command{\n    Use:   \"pull\",\n    Short: \"Pull vault from remote\",\n    RunE:  runSyncPull,\n}\n\nvar syncStatusCmd = \u0026cobra.Command{\n    Use:   \"status\",\n    Short: \"Show sync status\",\n    RunE:  runSyncStatus,\n}\n\nfunc init() {\n    syncCmd.AddCommand(syncInitCmd)\n    syncCmd.AddCommand(syncPushCmd)\n    syncCmd.AddCommand(syncPullCmd)\n    syncCmd.AddCommand(syncStatusCmd)\n    rootCmd.AddCommand(syncCmd)\n}\n\nACCEPTANCE:\n- keyp sync --help shows subcommands\n- All subcommand --help shows usage\n- go build ./cmd/keyp/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:27:31.6576474-05:00","updated_at":"2025-12-17T08:27:31.6576474-05:00","dependencies":[{"issue_id":"keyp-mrz.7","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:27:31.6625665-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.8","title":"Wire syncCmd subcommands to GitExecSyncer methods","description":"PROBLEM: sync subcommands need to call GitExecSyncer methods.\n\nLOCATION: cmd/keyp/sync.go\n\nAPPROACH:\nImplement all subcommand RunE functions:\n\nfunc runSyncInit(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    if err := syncer.Init(); err != nil {\n        return err\n    }\n    \n    if len(args) \u003e 0 {\n        if err := syncer.AddRemote(\"origin\", args[0]); err != nil {\n            return err\n        }\n        fmt.Printf(\"Git sync initialized with remote: %s\\n\", args[0])\n    } else {\n        fmt.Println(\"Git sync initialized (no remote configured)\")\n    }\n    \n    return nil\n}\n\nfunc runSyncPush(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    // Commit any pending changes\n    if err := syncer.Commit(\"\"); err != nil {\n        return err\n    }\n    \n    if err := syncer.Push(\"\", \"\"); err != nil {\n        return err\n    }\n    \n    fmt.Println(\"Vault pushed to remote\")\n    return nil\n}\n\nfunc runSyncPull(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    if err := syncer.Pull(\"\", \"\"); err != nil {\n        return err\n    }\n    \n    fmt.Println(\"Vault pulled from remote\")\n    return nil\n}\n\nfunc runSyncStatus(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    status, err := syncer.Status()\n    if err != nil {\n        return err\n    }\n    \n    if !status.IsRepo {\n        fmt.Println(\"Not initialized (run 'keyp sync init')\")\n        return nil\n    }\n    \n    fmt.Printf(\"Branch: %s\\n\", status.Branch)\n    if status.Remote != \"\" {\n        fmt.Printf(\"Remote: %s\\n\", status.Remote)\n    }\n    if status.HasChanges {\n        fmt.Println(\"Status: Uncommitted changes\")\n    }\n    if status.Ahead \u003e 0 {\n        fmt.Printf(\"Ahead: %d commits\\n\", status.Ahead)\n    }\n    if status.Behind \u003e 0 {\n        fmt.Printf(\"Behind: %d commits\\n\", status.Behind)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- sync init creates repo and optionally adds remote\n- sync push commits and pushes\n- sync pull fetches and merges\n- sync status shows repo state\n- All commands print appropriate messages","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T08:28:38.9700527-05:00","updated_at":"2025-12-17T08:28:38.9700527-05:00","dependencies":[{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:28:38.9732184-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.7","type":"blocks","created_at":"2025-12-17T09:02:23.3082077-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.2","type":"blocks","created_at":"2025-12-17T09:02:24.7160624-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.3","type":"blocks","created_at":"2025-12-17T09:02:26.1237082-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.4","type":"blocks","created_at":"2025-12-17T09:02:27.5341322-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.5","type":"blocks","created_at":"2025-12-17T09:02:28.9478339-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.6","type":"blocks","created_at":"2025-12-17T09:02:30.3577768-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.9","title":"Add git sync integration tests","description":"PROBLEM: Git sync commands need integration tests.\n\nLOCATION: internal/sync/sync_test.go (create new file)\n\nTEST SCENARIOS:\n1. Init:\n   - Creates .git directory\n   - Creates .gitignore with *.db\n\n2. AddRemote:\n   - Adds remote to repository\n   - GetRemoteURL returns correct URL\n\n3. Commit:\n   - Stages and commits changes\n   - No-op if nothing to commit\n\n4. Push/Pull:\n   - Requires remote repository (may skip in CI)\n\n5. Status:\n   - Returns correct branch name\n   - Detects uncommitted changes\n   - Shows ahead/behind counts\n\nAPPROACH:\nUse temp directories for test repositories.\nSome tests may need to be skipped if git not installed.\n\nACCEPTANCE:\n- go test ./internal/sync/ passes\n- Tests work in local environment\n- Gracefully skip if git not available","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T08:29:16.7019783-05:00","updated_at":"2025-12-17T08:29:16.7019783-05:00","dependencies":[{"issue_id":"keyp-mrz.9","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:29:16.7057616-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.9","depends_on_id":"keyp-mrz.8","type":"blocks","created_at":"2025-12-17T09:02:31.7709689-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk","title":"Phase 2.5: Storage Layer Gaps","description":"Address missing storage layer components required by later phases. Phase 2 (SQLite/SQLCipher storage) must be complete before starting.\n\nComponents needed:\n- store.Update method for modifying existing secrets (needed by P4 edit, P7 PUT)\n- store.Search method with FTS5 query support (needed by P4 search, P7 GET /search)\n- FTS5 virtual table verification in schema migration\n- Domain error types: ErrNotFound, ErrAlreadyExists, ErrInvalidPassword\n- JSON tags on SecretObject and Field types for API serialization\n- SecretObject.Redacted() method for masking sensitive values\n- Comprehensive unit tests for store package\n\nACCEPTANCE:\n- All store methods compile and pass unit tests\n- Error types properly defined and used\n- JSON serialization works for API responses\n- bd ready --json returns empty when complete","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:33:16.4984742-05:00","updated_at":"2025-12-17T01:33:16.4984742-05:00"}
{"id":"keyp-nlk.1","title":"Add store.Update method for modifying existing secrets","description":"PROBLEM: Phase 4 edit command and Phase 7 PUT endpoint need to modify existing secrets, but store only has Create/Get/Delete.\n\nLOCATION: internal/store/store.go\n\nAPPROACH:\n1. Add Update method to Store interface and SQLiteStore implementation\n2. Accept secret ID and updated SecretObject\n3. Update secrets table (name, tags, notes, updated_at)\n4. Replace all fields for that secret (delete old, insert new with correct sort_order)\n5. Update FTS index via triggers or manual sync\n6. Return ErrNotFound if secret doesn't exist\n\nSIGNATURE:\nfunc (s *SQLiteStore) Update(ctx context.Context, secret *model.SecretObject) error\n\nACCEPTANCE:\n- Update method compiles\n- Modifying name/tags/notes works\n- Adding/removing/reordering fields works\n- FTS index reflects changes\n- Returns ErrNotFound for non-existent secret","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:33:53.6066799-05:00","updated_at":"2025-12-17T01:33:53.6066799-05:00","dependencies":[{"issue_id":"keyp-nlk.1","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:33:53.6092999-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.2","title":"Add store.Search method with FTS5 query support","description":"PROBLEM: Phase 4 search command and Phase 7 GET /search endpoint need full-text search, but store doesn't expose Search method.\n\nLOCATION: internal/store/store.go\n\nAPPROACH:\n1. Add Search method to Store interface and SQLiteStore implementation\n2. Accept query string and optional filters (tags, limit)\n3. Use FTS5 MATCH syntax for the query\n4. Return slice of matching SecretObject (without field values for list display)\n5. Include match highlights or snippets if feasible\n\nSIGNATURE:\nfunc (s *SQLiteStore) Search(ctx context.Context, query string, opts SearchOptions) ([]*model.SecretObject, error)\n\ntype SearchOptions struct {\n    Tags   []string\n    Limit  int\n}\n\nACCEPTANCE:\n- Search method compiles\n- Finds secrets by name, tags, notes\n- Empty query returns all (or error)\n- Respects limit option\n- Returns empty slice (not error) for no matches","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:34:30.688594-05:00","updated_at":"2025-12-17T01:34:30.688594-05:00","dependencies":[{"issue_id":"keyp-nlk.2","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:34:30.6918953-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.3","title":"Verify FTS5 virtual table created in schema migration","description":"PROBLEM: Search depends on FTS5 virtual table secrets_fts. Need to verify it exists and is properly synced.\n\nLOCATION: internal/store/schema.sql and internal/store/store.go\n\nAPPROACH:\n1. Review schema.sql to confirm secrets_fts virtual table definition\n2. Verify triggers exist to keep FTS in sync with secrets table\n3. If missing, add CREATE VIRTUAL TABLE and sync triggers\n4. Test that inserts/updates/deletes properly update FTS index\n\nSCHEMA (expected):\nCREATE VIRTUAL TABLE secrets_fts USING fts5(\n    name, tags, notes,\n    content='secrets',\n    content_rowid='rowid'\n);\n\nCREATE TRIGGER secrets_ai AFTER INSERT ON secrets BEGIN\n    INSERT INTO secrets_fts(rowid, name, tags, notes) \n    VALUES (new.rowid, new.name, new.tags, new.notes);\nEND;\n\nCREATE TRIGGER secrets_ad AFTER DELETE ON secrets BEGIN\n    INSERT INTO secrets_fts(secrets_fts, rowid, name, tags, notes) \n    VALUES('delete', old.rowid, old.name, old.tags, old.notes);\nEND;\n\nCREATE TRIGGER secrets_au AFTER UPDATE ON secrets BEGIN\n    INSERT INTO secrets_fts(secrets_fts, rowid, name, tags, notes) \n    VALUES('delete', old.rowid, old.name, old.tags, old.notes);\n    INSERT INTO secrets_fts(rowid, name, tags, notes) \n    VALUES (new.rowid, new.name, new.tags, new.notes);\nEND;\n\nACCEPTANCE:\n- FTS5 virtual table exists in schema\n- Triggers keep FTS in sync\n- Search returns correct results after insert/update/delete","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:35:19.7517146-05:00","updated_at":"2025-12-17T01:35:19.7517146-05:00","dependencies":[{"issue_id":"keyp-nlk.3","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:35:19.7543598-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.3","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T08:58:33.2640224-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.4","title":"Define domain error types in internal/store/errors.go","description":"PROBLEM: Store operations need typed errors for proper error handling in CLI and HTTP layers.\n\nLOCATION: internal/store/errors.go (create new file)\n\nAPPROACH:\nCreate sentinel errors and error types:\n\nvar (\n    ErrNotFound       = errors.New(\"secret not found\")\n    ErrAlreadyExists  = errors.New(\"secret already exists\")\n    ErrInvalidPassword = errors.New(\"invalid password\")\n    ErrDatabaseLocked = errors.New(\"database is locked\")\n    ErrVaultClosed    = errors.New(\"vault is closed\")\n)\n\n// Optional: wrap with context\ntype NotFoundError struct {\n    Name string\n}\n\nfunc (e *NotFoundError) Error() string {\n    return fmt.Sprintf(\"secret not found: %s\", e.Name)\n}\n\nfunc (e *NotFoundError) Is(target error) bool {\n    return target == ErrNotFound\n}\n\nACCEPTANCE:\n- errors.go file exists with all error types\n- Errors support errors.Is() for comparison\n- Store methods return appropriate errors\n- go build ./internal/store/ compiles","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-17T01:36:01.5102443-05:00","updated_at":"2025-12-17T01:36:01.5102443-05:00","dependencies":[{"issue_id":"keyp-nlk.4","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:36:01.5140211-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.5","title":"Add json tags to SecretObject and Field types","description":"PROBLEM: Phase 7 HTTP API needs JSON serialization of secrets. Model types need json struct tags.\n\nLOCATION: internal/model/secret.go\n\nAPPROACH:\nReview existing types and ensure all exported fields have json tags:\n\ntype SecretObject struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    Fields    []Field   `json:\"fields\"`\n    Notes     string    `json:\"notes\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\ntype Field struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type\"`\n}\n\nACCEPTANCE:\n- All exported fields have json tags\n- Tags use snake_case convention\n- json.Marshal produces expected output\n- go build ./internal/model/ compiles","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:36:41.7638518-05:00","updated_at":"2025-12-17T01:36:41.7638518-05:00","dependencies":[{"issue_id":"keyp-nlk.5","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:36:41.7665128-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.6","title":"Add SecretObject.Redacted method for masking sensitive values","description":"PROBLEM: API responses and CLI show commands need to display secrets without exposing sensitive field values.\n\nLOCATION: internal/model/secret.go\n\nAPPROACH:\nAdd Redacted() method that returns a copy with sensitive field values masked:\n\nconst RedactedValue = \"********\"\n\nfunc (s *SecretObject) Redacted() *SecretObject {\n    copy := *s\n    copy.Fields = make([]Field, len(s.Fields))\n    for i, f := range s.Fields {\n        copy.Fields[i] = f\n        if f.Sensitive {\n            copy.Fields[i].Value = RedactedValue\n        }\n    }\n    return \u0026copy\n}\n\nACCEPTANCE:\n- Redacted() method exists on SecretObject\n- Returns new object (doesn't modify original)\n- Sensitive field values replaced with ********\n- Non-sensitive fields unchanged\n- go test ./internal/model/ passes","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:37:19.4347884-05:00","updated_at":"2025-12-17T01:37:19.4347884-05:00","dependencies":[{"issue_id":"keyp-nlk.6","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:37:19.4374587-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.7","title":"Add store package unit tests for CRUD, search, and error cases","description":"PROBLEM: Store package needs comprehensive unit tests before CLI and HTTP layers depend on it.\n\nLOCATION: internal/store/store_test.go\n\nTEST CASES:\n1. CRUD Operations:\n   - Create secret, verify Get returns it\n   - Create duplicate name returns ErrAlreadyExists\n   - Get non-existent returns ErrNotFound\n   - Update existing secret (change name, tags, fields)\n   - Update non-existent returns ErrNotFound\n   - Delete existing secret\n   - Delete non-existent returns ErrNotFound\n   - List returns all secrets\n\n2. Search:\n   - Search by name (partial match)\n   - Search by tag\n   - Search by notes content\n   - Search with no matches returns empty slice\n   - Search with limit option\n\n3. Field Operations:\n   - Create secret with multiple fields\n   - Fields preserve sort_order\n   - Update replaces all fields\n\n4. Error Handling:\n   - Operations on closed store return error\n   - Invalid input handling\n\nAPPROACH:\nUse table-driven tests where appropriate. Create test database in temp directory.\n\nACCEPTANCE:\n- go test ./internal/store/ passes\n- Coverage includes happy path and error cases\n- Tests clean up temp files","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-17T01:38:08.3746789-05:00","updated_at":"2025-12-17T01:38:08.3746789-05:00","dependencies":[{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:38:08.3784214-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T08:58:34.5214942-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T08:58:35.7782291-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.4","type":"blocks","created_at":"2025-12-17T08:58:37.0392485-05:00","created_by":"daemon"}]}
