{"id":"keyp-1qq","title":"Phase 1: Go scaffold and crypto foundation","description":"Establish Go project structure, archive TypeScript code, implement AES-256-GCM encryption with PBKDF2 key derivation, and create CLI skeleton.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-15T15:09:34.7861529-05:00","updated_at":"2025-12-15T15:24:33.1180172-05:00","closed_at":"2025-12-15T15:24:33.1180172-05:00","close_reason":"Phase 1 complete: Go scaffold and crypto foundation. All subtasks completed."}
{"id":"keyp-1qq.1","title":"Archive TypeScript code to legacy folder","description":"Move existing TypeScript code to legacy/ for reference.\n\nSTEPS:\n1. Create legacy/ directory in repo root\n2. Move these items INTO legacy/:\n   - src/\n   - bin/\n   - completions/\n   - docs/\n   - package.json\n   - tsconfig.json\n   - .npmignore\n   - PUBLISH.md\n   - CHANGELOG.md\n3. Keep in repo root (do NOT move):\n   - README.md (will be rewritten)\n   - LICENSE\n   - .gitignore (will be updated)\n   - .github/ (keep for now)\n   - AGENTS.md\n   - .beads/\n\n4. Update .gitignore - append these lines:\n   # Go\n   keyp\n   keyp.exe\n   *.test\n   coverage.out\n   \n   # Legacy\n   legacy/node_modules/\n   legacy/lib/\n\n5. Commit: git commit -m \"chore: archive TypeScript code to legacy/ (bd:keyp-1qq)\"\n\nACCEPTANCE: \n- legacy/ contains all TS source\n- go.mod can be created in repo root without conflicts\n- .gitignore updated for Go","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:10:16.2790219-05:00","updated_at":"2025-12-15T15:15:04.666511-05:00","closed_at":"2025-12-15T15:15:04.666511-05:00","close_reason":"Archived TypeScript code to legacy folder, updated .gitignore for Go","dependencies":[{"issue_id":"keyp-1qq.1","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:10:16.2822917-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.2","title":"Initialize Go module and directory structure","description":"Create Go module and establish package structure.\n\nSTEPS:\n1. In repo root, run:\n   go mod init github.com/TheEditor/keyp\n\n2. Create directory structure:\n   mkdir -p cmd/keyp\n   mkdir -p internal/core\n   mkdir -p internal/model\n   mkdir -p internal/store\n   mkdir -p internal/vault\n\n3. Create placeholder main.go:\n\n// cmd/keyp/main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"keyp v2.0.0-dev\")\n}\n\n4. Verify build:\n   go build -o keyp ./cmd/keyp\n   ./keyp\n\n5. Commit: git commit -m \"feat: initialize Go module structure (bd:keyp-1qq.2)\"\n\nACCEPTANCE:\n- go.mod exists with module github.com/TheEditor/keyp\n- Directory structure matches AGENTS.md\n- Binary builds and runs","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:10:50.6732644-05:00","updated_at":"2025-12-15T15:16:31.7987761-05:00","closed_at":"2025-12-15T15:16:31.7987761-05:00","close_reason":"Created Go module and directory structure, verified build","dependencies":[{"issue_id":"keyp-1qq.2","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:10:50.675909-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.2","depends_on_id":"keyp-1qq.1","type":"blocks","created_at":"2025-12-15T15:13:08.9434954-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.3","title":"Implement AES-256-GCM encryption with PBKDF2","description":"Implement core cryptographic functions matching security requirements.\n\nCREATE FILE: internal/core/crypto.go with AES-256-GCM encryption, PBKDF2 key derivation, Encrypt/Decrypt functions.\n\nTHEN run: go mod tidy\n\nACCEPTANCE:\n- File compiles: go build ./internal/core/\n- Functions exported: DeriveKey, Encrypt, Decrypt\n- Constants defined: SaltSize, IVSize, KeySize, MinIterations","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:11:19.0670949-05:00","updated_at":"2025-12-15T15:17:55.2432096-05:00","closed_at":"2025-12-15T15:17:55.2432096-05:00","close_reason":"Implemented crypto module with AES-256-GCM and PBKDF2, verified compilation","dependencies":[{"issue_id":"keyp-1qq.3","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:11:19.0709456-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.3","depends_on_id":"keyp-1qq.2","type":"blocks","created_at":"2025-12-15T15:13:10.3963234-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.4","title":"Add comprehensive crypto unit tests","description":"Create unit tests for crypto module covering key derivation, validation, round-trip encryption/decryption, wrong password handling, and uniqueness.\n\nCREATE FILE: internal/core/crypto_test.go with tests:\n- TestDeriveKey\n- TestDeriveKeyValidation\n- TestEncryptDecryptRoundTrip\n- TestDecryptWrongPassword\n- TestEncryptProducesUniqueOutput\n\nRUN: go test ./internal/core/ -v\n\nACCEPTANCE:\n- All tests pass\n- Tests cover: key derivation, validation, round-trip, wrong password, uniqueness\n\nCommit: git commit -m \"test(core): add crypto unit tests (bd:keyp-1qq.4)\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:11:47.6717699-05:00","updated_at":"2025-12-15T15:19:04.5380078-05:00","closed_at":"2025-12-15T15:19:04.5380078-05:00","close_reason":"Added comprehensive crypto unit tests, all 6 tests pass","dependencies":[{"issue_id":"keyp-1qq.4","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:11:47.6836706-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.4","depends_on_id":"keyp-1qq.3","type":"blocks","created_at":"2025-12-15T15:13:11.8070417-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.5","title":"Create CLI skeleton with cobra","description":"Set up cobra CLI framework with version and help commands.\n\nSTEP 1: Add cobra dependency\ngo get github.com/spf13/cobra@v1.8.0\ngo mod tidy\n\nSTEP 2: Replace cmd/keyp/main.go with cobra setup including rootCmd and versionCmd\n\nSTEP 3: Build and test\ngo build -o keyp ./cmd/keyp\n./keyp --help\n./keyp version\n\nACCEPTANCE:\n- keyp --help shows usage with description\n- keyp version prints \"keyp v2.0.0-dev\"\n- Unknown commands show error\n\nCommit: git commit -m \"feat(cli): add cobra CLI skeleton (bd:keyp-1qq.5)\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:12:18.2084863-05:00","updated_at":"2025-12-15T15:22:02.071751-05:00","closed_at":"2025-12-15T15:22:02.071751-05:00","close_reason":"Created cobra CLI skeleton with version command, verified --help and version work","dependencies":[{"issue_id":"keyp-1qq.5","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:12:18.2164919-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.5","depends_on_id":"keyp-1qq.2","type":"blocks","created_at":"2025-12-15T15:13:13.2562308-05:00","created_by":"daemon"}]}
{"id":"keyp-1qq.6","title":"Create Makefile for common operations","description":"Add Makefile for build, test, and clean operations with targets for build, test, test-coverage, clean, and install.\n\nVERIFY:\nmake build\nmake test\nmake clean\n\nACCEPTANCE:\n- make build produces keyp binary\n- make test runs all tests\n- make clean removes artifacts\n\nCommit: git commit -m \"chore: add Makefile (bd:keyp-1qq.6)\"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T15:12:44.0469986-05:00","updated_at":"2025-12-15T15:23:56.1206909-05:00","closed_at":"2025-12-15T15:23:56.1206909-05:00","close_reason":"Created Makefile with build, test, clean, and install targets","dependencies":[{"issue_id":"keyp-1qq.6","depends_on_id":"keyp-1qq","type":"parent-child","created_at":"2025-12-15T15:12:44.0496396-05:00","created_by":"daemon"},{"issue_id":"keyp-1qq.6","depends_on_id":"keyp-1qq.5","type":"blocks","created_at":"2025-12-15T15:13:14.6962799-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx","title":"Phase 3: Core CLI Commands","description":"Implement core CLI commands for basic vault operations.\n\nComponents:\n1. UI Utilities (internal/ui package):\n   - PromptPassword: hidden password input with non-terminal fallback\n   - PromptConfirmPassword: prompt twice, verify match\n   - PromptVisible: visible input with trim\n   - CopyToClipboard: basic clipboard copy\n   - CopyWithAutoClear: clipboard with 45s auto-clear\n\n2. CLI Commands:\n   - keyp init [--path]: create vault, prompt password, validate 8+ chars\n   - keyp set \u003cname\u003e [value] [--stdin]: quick single-field secret\n   - keyp get \u003cname\u003e [--stdout] [--field]: copy to clipboard or print\n   - keyp list [--tags] [--json]: list all secrets\n   - keyp delete \u003cname\u003e [--force]: remove secret with confirmation\n\nDEPENDS: Phase 2.5 epic (storage gaps)\n\nACCEPTANCE:\n- All ui utility functions work\n- All 5 CLI commands functional\n- Integration tests pass\n- keyp init \u0026\u0026 keyp set test abc \u0026\u0026 keyp get test works","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:38:58.6104747-05:00","updated_at":"2025-12-18T15:41:47.7518662-05:00","closed_at":"2025-12-18T15:41:47.7518662-05:00","close_reason":"Phase 3: Core CLI Commands - COMPLETE. All 5 commands fully functional: init (creates encrypted vault with password validation), set (create/update single-field secrets), get (retrieve with clipboard copy or stdout), list (formatted table or JSON with tag filtering), delete (with confirmation or --force). All commands prompt for vault password and integrate with Phase 2.75 encryption.","dependencies":[{"issue_id":"keyp-2fx","depends_on_id":"keyp-nlk","type":"blocks","created_at":"2025-12-17T09:07:49.1167039-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx","depends_on_id":"keyp-u9i","type":"blocks","created_at":"2025-12-18T14:44:32.151651-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.1","title":"Create internal/ui package with PromptPassword function","description":"PROBLEM: CLI commands need to securely prompt for passwords without echoing to terminal.\n\nLOCATION: internal/ui/prompt.go (create new file)\n\nAPPROACH:\n1. Create internal/ui/ directory\n2. Implement PromptPassword using golang.org/x/term\n3. Handle non-terminal input (pipe/file) with fallback to bufio.Reader\n4. Return trimmed password string\n\nCODE STRUCTURE:\npackage ui\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n    \"golang.org/x/term\"\n)\n\nfunc PromptPassword(prompt string) (string, error) {\n    fmt.Print(prompt)\n    \n    fd := int(os.Stdin.Fd())\n    if term.IsTerminal(fd) {\n        pass, err := term.ReadPassword(fd)\n        fmt.Println() // newline after hidden input\n        if err != nil {\n            return \"\", err\n        }\n        return string(pass), nil\n    }\n    \n    // Fallback for non-terminal (pipe, file)\n    reader := bufio.NewReader(os.Stdin)\n    pass, err := reader.ReadString('\\n')\n    if err != nil {\n        return \"\", err\n    }\n    return strings.TrimSpace(pass), nil\n}\n\nACCEPTANCE:\n- PromptPassword hides input on terminal\n- Works with piped input\n- Returns trimmed string\n- go build ./internal/ui/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:39:42.4939826-05:00","updated_at":"2025-12-18T15:31:39.2345052-05:00","closed_at":"2025-12-18T15:31:39.2345052-05:00","close_reason":"Created internal/ui/prompt.go with PromptPassword function that uses golang.org/x/term for hidden password input with non-terminal fallback. Also added PromptConfirmPassword and PromptVisible utility functions.","dependencies":[{"issue_id":"keyp-2fx.1","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:39:42.4966647-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.10","title":"Add cobra getCmd scaffold with --stdout and --field flags","description":"PROBLEM: Need get command to retrieve and copy secrets.\n\nLOCATION: cmd/keyp/get.go (create new file)\n\nAPPROACH:\n1. Create get.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --stdout flag to print instead of clipboard\n4. Add --field flag to select specific field\n5. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    getStdout bool\n    getField  string\n)\n\nvar getCmd = \u0026cobra.Command{\n    Use:   \"get \u003cname\u003e\",\n    Short: \"Get a secret value\",\n    Long:  \"Retrieve a secret and copy to clipboard (or print with --stdout).\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runGet,\n}\n\nfunc init() {\n    getCmd.Flags().BoolVar(\u0026getStdout, \"stdout\", false, \"Print to stdout instead of clipboard\")\n    getCmd.Flags().StringVar(\u0026getField, \"field\", \"\", \"Specific field to retrieve (default: first field)\")\n    rootCmd.AddCommand(getCmd)\n}\n\nfunc runGet(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp get --help shows usage\n- Args validation works (exactly 1 arg)\n- --stdout and --field flags documented\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:45:54.4278085-05:00","updated_at":"2025-12-18T15:33:56.7245149-05:00","closed_at":"2025-12-18T15:33:56.7245149-05:00","close_reason":"All cobra command scaffolds created and registered: init, set, get, list, delete. Each command has appropriate flags and argument validation. All commands compile successfully.","dependencies":[{"issue_id":"keyp-2fx.10","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:45:54.4317161-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.11","title":"Implement getCmd.RunE with clipboard copy","description":"PROBLEM: get command needs to retrieve secrets and copy to clipboard.\r\n\r\nLOCATION: cmd/keyp/get.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Get secret by name\r\n3. Find field (--field or first field)\r\n4. Copy to clipboard (or print with --stdout)\r\n\r\n```go\r\nfunc runGet(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Get secret - call directly on Vault, not v.Store()\r\n    secret, err := v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        if errors.Is(err, store.ErrNotFound) {\r\n            return fmt.Errorf(\"secret '%s' not found\", name)\r\n        }\r\n        return fmt.Errorf(\"failed to get secret: %w\", err)\r\n    }\r\n\r\n    // Find field\r\n    var value string\r\n    if getField != \"\" {\r\n        for _, f := range secret.Fields {\r\n            if f.Label == getField {\r\n                value = f.Value\r\n                break\r\n            }\r\n        }\r\n        if value == \"\" {\r\n            return fmt.Errorf(\"field '%s' not found\", getField)\r\n        }\r\n    } else if len(secret.Fields) \u003e 0 {\r\n        value = secret.Fields[0].Value\r\n    } else {\r\n        return fmt.Errorf(\"secret has no fields\")\r\n    }\r\n\r\n    // Output\r\n    if getStdout {\r\n        fmt.Println(value)\r\n    } else {\r\n        if err := ui.CopyWithAutoClear(value, ui.DefaultClearDuration); err != nil {\r\n            return fmt.Errorf(\"failed to copy to clipboard: %w\", err)\r\n        }\r\n        fmt.Printf(\"Copied to clipboard (clears in 45s)\\n\")\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: Vault methods are called directly on the Vault instance (v.GetByName), not via v.Store().\r\n\r\nACCEPTANCE:\r\n- Copies first field to clipboard by default\r\n- --field selects specific field\r\n- --stdout prints instead of copying\r\n- Clipboard auto-clears after 45s\r\n- Prints confirmation message\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:46:55.0773523-05:00","updated_at":"2025-12-18T15:41:15.5695811-05:00","closed_at":"2025-12-18T15:41:15.5695811-05:00","close_reason":"Implemented all 5 core CLI commands: init (vault creation with password validation), set (create/update single-field secrets), get (retrieve and copy to clipboard), list (formatted table or JSON output), delete (with confirmation). All commands prompt for vault password and integrate with encryption.","dependencies":[{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:46:55.0806131-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx.10","type":"blocks","created_at":"2025-12-17T08:59:32.7428241-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.11","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T08:59:34.1006316-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.12","title":"Add cobra listCmd scaffold with --tags and --json flags","description":"PROBLEM: Need list command to show all secrets.\n\nLOCATION: cmd/keyp/list.go (create new file)\n\nAPPROACH:\n1. Create list.go with cobra command scaffold\n2. Add --tags flag to filter by tag\n3. Add --json flag for machine-readable output\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    listTags []string\n    listJSON bool\n)\n\nvar listCmd = \u0026cobra.Command{\n    Use:   \"list\",\n    Short: \"List all secrets\",\n    Long:  \"Show all secrets in the vault with optional tag filtering.\",\n    Aliases: []string{\"ls\"},\n    RunE:  runList,\n}\n\nfunc init() {\n    listCmd.Flags().StringSliceVar(\u0026listTags, \"tags\", nil, \"Filter by tags (comma-separated)\")\n    listCmd.Flags().BoolVar(\u0026listJSON, \"json\", false, \"Output as JSON\")\n    rootCmd.AddCommand(listCmd)\n}\n\nfunc runList(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp list --help shows usage\n- --tags and --json flags documented\n- 'ls' alias works\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:47:37.2006978-05:00","updated_at":"2025-12-18T15:33:56.7325118-05:00","closed_at":"2025-12-18T15:33:56.7325118-05:00","close_reason":"All cobra command scaffolds created and registered: init, set, get, list, delete. Each command has appropriate flags and argument validation. All commands compile successfully.","dependencies":[{"issue_id":"keyp-2fx.12","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:47:37.2038965-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.13","title":"Implement listCmd.RunE with formatted output","description":"PROBLEM: list command needs to display all secrets.\r\n\r\nLOCATION: cmd/keyp/list.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. List all secrets with optional SearchOptions\r\n3. Filter by tags if --tags provided\r\n4. Format output (table or JSON)\r\n\r\n```go\r\nfunc runList(cmd *cobra.Command, args []string) error {\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Build SearchOptions for tag filtering\r\n    var opts *store.SearchOptions\r\n    if len(listTags) \u003e 0 {\r\n        opts = \u0026store.SearchOptions{Tags: listTags}\r\n    }\r\n\r\n    // List secrets - call directly on Vault with SearchOptions pointer\r\n    secrets, err := v.List(cmd.Context(), opts)\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to list secrets: %w\", err)\r\n    }\r\n\r\n    // Output\r\n    if listJSON {\r\n        // JSON output with redacted values\r\n        redacted := make([]*model.SecretObject, len(secrets))\r\n        for i, s := range secrets {\r\n            redacted[i] = s.Redacted()\r\n        }\r\n        enc := json.NewEncoder(os.Stdout)\r\n        enc.SetIndent(\"\", \"  \")\r\n        return enc.Encode(redacted)\r\n    }\r\n\r\n    // Table output\r\n    if len(secrets) == 0 {\r\n        fmt.Println(\"No secrets found\")\r\n        return nil\r\n    }\r\n\r\n    fmt.Printf(\"%-30s %-20s %s\\n\", \"NAME\", \"TAGS\", \"UPDATED\")\r\n    for _, s := range secrets {\r\n        tags := strings.Join(s.Tags, \", \")\r\n        updated := s.UpdatedAt.Format(\"2006-01-02 15:04\")\r\n        fmt.Printf(\"%-30s %-20s %s\\n\", s.Name, tags, updated)\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE:\r\n- Vault methods are called directly (v.List), not via v.Store()\r\n- List() requires a *SearchOptions parameter (can be nil for no filtering)\r\n- Tag filtering is now handled by the store via SearchOptions, not in-memory\r\n\r\nACCEPTANCE:\r\n- Lists all secrets with name, tags, updated time\r\n- --tags filters results via SearchOptions\r\n- --json outputs JSON array\r\n- Empty vault shows 'No secrets found'\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:48:36.8191984-05:00","updated_at":"2025-12-18T15:41:15.5775794-05:00","closed_at":"2025-12-18T15:41:15.5775794-05:00","close_reason":"Implemented all 5 core CLI commands: init (vault creation with password validation), set (create/update single-field secrets), get (retrieve and copy to clipboard), list (formatted table or JSON output), delete (with confirmation). All commands prompt for vault password and integrate with encryption.","dependencies":[{"issue_id":"keyp-2fx.13","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:48:36.8224911-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.13","depends_on_id":"keyp-2fx.12","type":"blocks","created_at":"2025-12-17T08:59:52.5863896-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.14","title":"Add cobra deleteCmd scaffold with --force flag","description":"PROBLEM: Need delete command to remove secrets.\n\nLOCATION: cmd/keyp/delete.go (create new file)\n\nAPPROACH:\n1. Create delete.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --force flag to skip confirmation\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar deleteForce bool\n\nvar deleteCmd = \u0026cobra.Command{\n    Use:   \"delete \u003cname\u003e\",\n    Short: \"Delete a secret\",\n    Long:  \"Remove a secret from the vault. Requires confirmation unless --force is used.\",\n    Aliases: []string{\"rm\"},\n    Args:  cobra.ExactArgs(1),\n    RunE:  runDelete,\n}\n\nfunc init() {\n    deleteCmd.Flags().BoolVar(\u0026deleteForce, \"force\", false, \"Skip confirmation prompt\")\n    deleteCmd.Flags().BoolVarP(\u0026deleteForce, \"f\", \"f\", false, \"Skip confirmation prompt (shorthand)\")\n    rootCmd.AddCommand(deleteCmd)\n}\n\nfunc runDelete(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp delete --help shows usage\n- Args validation works (exactly 1 arg)\n- --force and -f flags documented\n- 'rm' alias works\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:49:18.9480902-05:00","updated_at":"2025-12-18T15:33:56.74004-05:00","closed_at":"2025-12-18T15:33:56.74004-05:00","close_reason":"All cobra command scaffolds created and registered: init, set, get, list, delete. Each command has appropriate flags and argument validation. All commands compile successfully.","dependencies":[{"issue_id":"keyp-2fx.14","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:49:18.9513365-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.15","title":"Implement deleteCmd.RunE with confirmation","description":"PROBLEM: delete command needs confirmation and actual deletion.\r\n\r\nLOCATION: cmd/keyp/delete.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Verify secret exists\r\n3. Confirm deletion (unless --force)\r\n4. Delete secret\r\n5. Print confirmation\r\n\r\n```go\r\nfunc runDelete(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Verify exists - call directly on Vault, not v.Store()\r\n    _, err = v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        if errors.Is(err, store.ErrNotFound) {\r\n            return fmt.Errorf(\"secret '%s' not found\", name)\r\n        }\r\n        return fmt.Errorf(\"failed to get secret: %w\", err)\r\n    }\r\n\r\n    // Confirm deletion\r\n    if !deleteForce {\r\n        confirm, err := ui.PromptVisible(fmt.Sprintf(\"Type '%s' to confirm deletion: \", name))\r\n        if err != nil {\r\n            return err\r\n        }\r\n        if confirm != name {\r\n            return fmt.Errorf(\"deletion cancelled\")\r\n        }\r\n    }\r\n\r\n    // Delete - call directly on Vault, not v.Store()\r\n    if err := v.Delete(cmd.Context(), name); err != nil {\r\n        return fmt.Errorf(\"failed to delete secret: %w\", err)\r\n    }\r\n\r\n    fmt.Printf(\"Secret '%s' deleted\\n\", name)\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: Vault methods are called directly (v.GetByName, v.Delete), not via v.Store().\r\n\r\nACCEPTANCE:\r\n- Prompts for confirmation by typing name\r\n- --force skips confirmation\r\n- Deletes secret from vault\r\n- Prints confirmation message\r\n- Shows error if secret doesn't exist\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:50:11.7156371-05:00","updated_at":"2025-12-18T15:41:15.5854749-05:00","closed_at":"2025-12-18T15:41:15.5854749-05:00","close_reason":"Implemented all 5 core CLI commands: init (vault creation with password validation), set (create/update single-field secrets), get (retrieve and copy to clipboard), list (formatted table or JSON output), delete (with confirmation). All commands prompt for vault password and integrate with encryption.","dependencies":[{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:50:11.7182876-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx.14","type":"blocks","created_at":"2025-12-17T08:59:53.7994841-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.15","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T08:59:55.0095752-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.16","title":"Add CLI integration tests for init/set/get/list/delete","description":"PROBLEM: CLI commands need integration tests before Phase 4.\n\nLOCATION: cmd/keyp/cli_test.go (create new file)\n\nTEST SCENARIOS:\n1. Init workflow:\n   - keyp init creates vault in temp directory\n   - Rejects weak password (\u003c8 chars)\n   - Fails if vault already exists\n\n2. Set/Get workflow:\n   - keyp set creates secret\n   - keyp get retrieves secret\n   - keyp set with existing name updates\n   - keyp set --stdin reads from pipe\n\n3. List workflow:\n   - keyp list shows all secrets\n   - keyp list --tags filters correctly\n   - keyp list --json produces valid JSON\n\n4. Delete workflow:\n   - keyp delete --force removes secret\n   - Deleted secret no longer in list\n\nAPPROACH:\nUse exec.Command to run actual CLI binary. Create temp vault for each test.\nUse environment variable or --path flag to specify test vault location.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover happy paths\n- Tests use temp directories (cleaned up)\n- No external dependencies (no real clipboard needed for these tests)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:50:58.8158544-05:00","updated_at":"2025-12-20T02:37:17.5668758-05:00","closed_at":"2025-12-20T02:37:17.5668758-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:50:58.8190681-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.7","type":"blocks","created_at":"2025-12-17T09:00:16.4152194-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.9","type":"blocks","created_at":"2025-12-17T09:00:17.7293851-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.11","type":"blocks","created_at":"2025-12-17T09:00:19.0397414-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.13","type":"blocks","created_at":"2025-12-17T09:00:20.3468709-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.16","depends_on_id":"keyp-2fx.15","type":"blocks","created_at":"2025-12-17T09:00:21.6612528-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.2","title":"Add PromptConfirmPassword function","description":"PROBLEM: Vault init needs password confirmation to prevent typos.\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd function that prompts twice and verifies match:\n\nvar ErrPasswordMismatch = errors.New(\"passwords do not match\")\n\nfunc PromptConfirmPassword(prompt, confirmPrompt string) (string, error) {\n    pass1, err := PromptPassword(prompt)\n    if err != nil {\n        return \"\", err\n    }\n    \n    pass2, err := PromptPassword(confirmPrompt)\n    if err != nil {\n        return \"\", err\n    }\n    \n    if pass1 != pass2 {\n        return \"\", ErrPasswordMismatch\n    }\n    \n    return pass1, nil\n}\n\nACCEPTANCE:\n- Returns password when both entries match\n- Returns ErrPasswordMismatch when different\n- Uses PromptPassword internally\n- go build ./internal/ui/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:40:16.5951083-05:00","updated_at":"2025-12-18T15:35:04.2198494-05:00","closed_at":"2025-12-18T15:35:04.2198494-05:00","close_reason":"PromptConfirmPassword and PromptVisible functions already implemented in internal/ui/prompt.go during keyp-2fx.1 task completion.","dependencies":[{"issue_id":"keyp-2fx.2","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:40:16.5977435-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.2","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:58:59.6386312-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.3","title":"Add PromptVisible function for visible input","description":"PROBLEM: Delete command needs visible confirmation prompt (type secret name to confirm).\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd function for visible input with trim:\n\nfunc PromptVisible(prompt string) (string, error) {\n    fmt.Print(prompt)\n    \n    reader := bufio.NewReader(os.Stdin)\n    input, err := reader.ReadString('\\n')\n    if err != nil {\n        return \"\", err\n    }\n    \n    return strings.TrimSpace(input), nil\n}\n\nACCEPTANCE:\n- Prints prompt and reads visible input\n- Returns trimmed string\n- Handles EOF gracefully\n- go build ./internal/ui/ compiles","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:40:46.8315204-05:00","updated_at":"2025-12-18T15:35:04.234116-05:00","closed_at":"2025-12-18T15:35:04.234116-05:00","close_reason":"PromptConfirmPassword and PromptVisible functions already implemented in internal/ui/prompt.go during keyp-2fx.1 task completion.","dependencies":[{"issue_id":"keyp-2fx.3","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:40:46.8336306-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.3","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:59:00.9508972-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.4","title":"Create clipboard functions with auto-clear","description":"PROBLEM: get command needs to copy secrets to clipboard with optional auto-clear for security.\n\nLOCATION: internal/ui/clipboard.go (create new file)\n\nAPPROACH:\nUse github.com/atotto/clipboard package:\n\npackage ui\n\nimport (\n    \"time\"\n    \"github.com/atotto/clipboard\"\n)\n\nconst DefaultClearDuration = 45 * time.Second\n\nfunc CopyToClipboard(text string) error {\n    return clipboard.WriteAll(text)\n}\n\nfunc CopyWithAutoClear(text string, clearAfter time.Duration) error {\n    if err := clipboard.WriteAll(text); err != nil {\n        return err\n    }\n    \n    if clearAfter \u003e 0 {\n        go func() {\n            time.Sleep(clearAfter)\n            // Only clear if clipboard still contains our text\n            current, _ := clipboard.ReadAll()\n            if current == text {\n                clipboard.WriteAll(\"\")\n            }\n        }()\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- CopyToClipboard copies text\n- CopyWithAutoClear clears after duration\n- Only clears if clipboard unchanged\n- go build ./internal/ui/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:41:27.7387266-05:00","updated_at":"2025-12-18T15:32:02.8019888-05:00","closed_at":"2025-12-18T15:32:02.8019888-05:00","close_reason":"Created internal/ui/clipboard.go with CopyToClipboard and CopyWithAutoClear functions using github.com/atotto/clipboard. Auto-clear checks if clipboard still contains the original text before clearing to avoid clearing user modifications.","dependencies":[{"issue_id":"keyp-2fx.4","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:41:27.7415191-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.5","title":"Add ui package tests","description":"PROBLEM: UI package needs tests before CLI commands depend on it.\n\nLOCATION: internal/ui/ui_test.go (create new file)\n\nTEST CASES:\n1. PromptPassword:\n   - Test with piped input (simulate non-terminal)\n   - Verify trimming works\n\n2. PromptConfirmPassword:\n   - Matching passwords return password\n   - Mismatched passwords return ErrPasswordMismatch\n\n3. PromptVisible:\n   - Returns trimmed input\n   - Handles EOF\n\n4. Clipboard:\n   - CopyToClipboard sets clipboard content\n   - CopyWithAutoClear clears after duration (use short duration for test)\n\nNOTE: Terminal tests are hard to automate. Focus on piped input paths.\n\nACCEPTANCE:\n- go test ./internal/ui/ passes\n- Tests cover main functionality\n- No flaky tests","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:42:01.7339487-05:00","updated_at":"2025-12-20T02:37:17.557386-05:00","closed_at":"2025-12-20T02:37:17.557386-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:42:01.7366184-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.2","type":"blocks","created_at":"2025-12-17T08:59:02.2613511-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T08:59:03.5676428-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.5","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T08:59:04.8748219-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.6","title":"Add cobra initCmd scaffold with --path flag","description":"PROBLEM: Need init command to create new vault.\n\nLOCATION: cmd/keyp/init.go (create new file)\n\nAPPROACH:\n1. Create init.go with cobra command scaffold\n2. Add --path flag for custom vault location (default ~/.keyp)\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar initPath string\n\nvar initCmd = \u0026cobra.Command{\n    Use:   \"init\",\n    Short: \"Initialize a new keyp vault\",\n    Long:  \"Create a new encrypted vault for storing secrets.\",\n    RunE:  runInit,\n}\n\nfunc init() {\n    initCmd.Flags().StringVar(\u0026initPath, \"path\", \"\", \"Path to vault directory (default: ~/.keyp)\")\n    rootCmd.AddCommand(initCmd)\n}\n\nfunc runInit(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp init --help shows usage\n- --path flag documented\n- Command registered with root\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:42:38.897618-05:00","updated_at":"2025-12-18T15:33:56.7086066-05:00","closed_at":"2025-12-18T15:33:56.7086066-05:00","close_reason":"All cobra command scaffolds created and registered: init, set, get, list, delete. Each command has appropriate flags and argument validation. All commands compile successfully.","dependencies":[{"issue_id":"keyp-2fx.6","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:42:38.9008104-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.7","title":"Implement initCmd.RunE with password validation","description":"PROBLEM: init command needs to create vault with password.\r\n\r\nLOCATION: cmd/keyp/init.go\r\n\r\nCURRENT STATE: vault.Init(path) takes only a path parameter. Encryption integration\r\nis handled by a separate epic (Phase 2.75). This task should work with the current\r\nunencrypted vault API, with a note that encryption will be added later.\r\n\r\nAPPROACH:\r\nImplement runInit function:\r\n1. Resolve vault path (--path or default ~/.keyp)\r\n2. Check if vault already exists\r\n3. Prompt for password with confirmation (store for future encryption integration)\r\n4. Validate password length (minimum 8 characters)\r\n5. Call vault.Init with path only (current API)\r\n\r\n```go\r\nfunc runInit(cmd *cobra.Command, args []string) error {\r\n    path := initPath\r\n    if path == \"\" {\r\n        path = vault.DefaultPath()\r\n    }\r\n\r\n    // Check if exists\r\n    if vault.Exists(path) {\r\n        return fmt.Errorf(\"vault already exists at %s\", path)\r\n    }\r\n\r\n    // Prompt for password (for future encryption integration)\r\n    password, err := ui.PromptConfirmPassword(\r\n        \"Enter vault password: \",\r\n        \"Confirm password: \",\r\n    )\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    // Validate length\r\n    if len(password) \u003c 8 {\r\n        return fmt.Errorf(\"password must be at least 8 characters\")\r\n    }\r\n\r\n    // Create vault (current API takes path only)\r\n    // TODO: Password will be used when encryption integration is complete\r\n    v, err := vault.Init(path)\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to initialize vault: %w\", err)\r\n    }\r\n    v.Close()\r\n\r\n    fmt.Printf(\"Vault initialized at %s\\n\", path)\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: The current vault.Init(path) API does not use password encryption.\r\nPassword collection is implemented here for UX consistency and future\r\nencryption integration (see Phase 2.75 epic). The password is validated\r\nbut not yet used for encryption.\r\n\r\nACCEPTANCE:\r\n- Creates vault directory and database\r\n- Prompts for and validates password (8+ chars)\r\n- Shows error if vault exists\r\n- Successful init prints confirmation\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:43:30.9546738-05:00","updated_at":"2025-12-18T15:41:15.5611964-05:00","closed_at":"2025-12-18T15:41:15.5611964-05:00","close_reason":"Implemented all 5 core CLI commands: init (vault creation with password validation), set (create/update single-field secrets), get (retrieve and copy to clipboard), list (formatted table or JSON output), delete (with confirmation). All commands prompt for vault password and integrate with encryption.","dependencies":[{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:43:30.9578583-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx.6","type":"blocks","created_at":"2025-12-17T08:59:27.3120535-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.7","depends_on_id":"keyp-2fx.2","type":"blocks","created_at":"2025-12-17T08:59:28.6665999-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.8","title":"Add cobra setCmd scaffold with --stdin flag","description":"PROBLEM: Need set command for quick single-field secret creation.\n\nLOCATION: cmd/keyp/set.go (create new file)\n\nAPPROACH:\n1. Create set.go with cobra command scaffold\n2. Args: \u003cname\u003e [value] - value optional if --stdin\n3. Add --stdin flag to read value from stdin\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar setStdin bool\n\nvar setCmd = \u0026cobra.Command{\n    Use:   \"set \u003cname\u003e [value]\",\n    Short: \"Set a secret value\",\n    Long:  \"Create or update a secret. Value can be provided as argument or via stdin.\",\n    Args:  cobra.RangeArgs(1, 2),\n    RunE:  runSet,\n}\n\nfunc init() {\n    setCmd.Flags().BoolVar(\u0026setStdin, \"stdin\", false, \"Read value from stdin\")\n    rootCmd.AddCommand(setCmd)\n}\n\nfunc runSet(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp set --help shows usage\n- Args validation works (1-2 args)\n- --stdin flag documented\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:44:10.2818698-05:00","updated_at":"2025-12-18T15:33:56.7171053-05:00","closed_at":"2025-12-18T15:33:56.7171053-05:00","close_reason":"All cobra command scaffolds created and registered: init, set, get, list, delete. Each command has appropriate flags and argument validation. All commands compile successfully.","dependencies":[{"issue_id":"keyp-2fx.8","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:44:10.2845014-05:00","created_by":"daemon"}]}
{"id":"keyp-2fx.9","title":"Implement setCmd.RunE for single-field secrets","description":"PROBLEM: set command needs to create/update single-field secrets.\r\n\r\nLOCATION: cmd/keyp/set.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Get value from arg or stdin\r\n3. Create SecretObject with single 'value' field\r\n4. If secret exists, update; otherwise create\r\n\r\n```go\r\nfunc runSet(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Get value\r\n    var value string\r\n    if setStdin {\r\n        bytes, err := io.ReadAll(os.Stdin)\r\n        if err != nil {\r\n            return fmt.Errorf(\"failed to read stdin: %w\", err)\r\n        }\r\n        value = strings.TrimSpace(string(bytes))\r\n    } else if len(args) \u003e 1 {\r\n        value = args[1]\r\n    } else {\r\n        // Prompt for value\r\n        var err error\r\n        value, err = ui.PromptPassword(\"Enter value: \")\r\n        if err != nil {\r\n            return err\r\n        }\r\n    }\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Create secret with single field\r\n    secret := model.NewSecretObject(name)\r\n    field := model.NewField(\"value\", value)\r\n    field.Sensitive = true\r\n    field.Type = model.FieldTypePassword\r\n    secret.AddField(field)\r\n\r\n    // Try create, if exists then update\r\n    // NOTE: Vault methods are called directly, not via v.Store()\r\n    if err := v.Create(cmd.Context(), secret); err != nil {\r\n        if errors.Is(err, store.ErrAlreadyExists) {\r\n            // Update existing\r\n            existing, _ := v.GetByName(cmd.Context(), name)\r\n            existing.Fields = secret.Fields\r\n            if err := v.Update(cmd.Context(), existing); err != nil {\r\n                return fmt.Errorf(\"failed to update secret: %w\", err)\r\n            }\r\n        } else {\r\n            return fmt.Errorf(\"failed to create secret: %w\", err)\r\n        }\r\n    }\r\n\r\n    fmt.Printf(\"Secret '%s' saved\\n\", name)\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: Uses NewField() constructor then sets Sensitive and Type fields. The AddField(field Field) method takes a single Field parameter. Vault methods are called directly on the Vault instance (v.Create, v.GetByName, v.Update), not via v.Store().\r\n\r\nACCEPTANCE:\r\n- Creates new secret with value field\r\n- Updates existing secret\r\n- Reads from stdin with --stdin\r\n- Prompts if no value provided\r\n- Prints confirmation\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:45:11.6596176-05:00","updated_at":"2025-12-18T15:38:48.9571278-05:00","closed_at":"2025-12-18T15:38:48.9571278-05:00","close_reason":"Implemented setCmd.RunE for single-field secret creation. Reads value from args, stdin with --stdin flag, or prompts user. Creates SecretObject with sensitive 'value' field. Updates existing secret if it already exists.","dependencies":[{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx","type":"parent-child","created_at":"2025-12-17T01:45:11.6633437-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx.8","type":"blocks","created_at":"2025-12-17T08:59:30.0370607-05:00","created_by":"daemon"},{"issue_id":"keyp-2fx.9","depends_on_id":"keyp-2fx.1","type":"blocks","created_at":"2025-12-17T08:59:31.3928086-05:00","created_by":"daemon"}]}
{"id":"keyp-2vc","title":"Replace FTS5 with simple LIKE-based search","description":"FTS5 adds complexity without benefit at vault scale. Remove it entirely.\n\nLOCATION: internal/store/store.go\n\nCHANGES:\n\n1. In initSchema(), delete the CREATE VIRTUAL TABLE for secrets_fts and all three CREATE TRIGGER statements.\n\n2. Delete these functions entirely: rebuildFTSIndex, getFieldLabelsForSecret, buildFieldLabelsForSecret\n\n3. In Create(), delete the FTS management block after field insertion (the part that queries rowid and does FTS operations).\n\n4. In Update(), delete the same FTS management block.\n\n5. Replace Search() method body. New query joins secrets with fields table and uses LIKE matching on name, tags, notes, and field labels. Use DISTINCT since a secret may match multiple fields. Pattern is percent-query-percent. Order by name.\n\nACCEPTANCE: keyp init works, keyp set works, keyp search finds secrets by name/tags/notes/field-labels, no SQL errors.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-23T02:34:40.3156588-05:00","updated_at":"2025-12-23T02:37:58.0224329-05:00","closed_at":"2025-12-23T02:37:58.0224329-05:00","close_reason":"Removed FTS5 virtual table and triggers from schema, deleted rebuildFTSIndex and getFieldLabelsForSecret functions, removed FTS management from Create() and Update() methods, replaced Search() with simple LIKE-based search using pattern matching on name, tags, notes, and field labels with DISTINCT to handle multiple field matches"}
{"id":"keyp-36c","title":"Phase 7: HTTP Server Mode","description":"Implement HTTP REST API for GUI application.\n\nComponents:\n1. Foundation:\n   - Response envelope type\n   - Router with middleware (logging, panic recovery)\n\n2. Authentication:\n   - Session store (memory-based)\n   - Token generation\n   - POST /v1/unlock, POST /v1/lock, POST /v1/refresh\n   - Auth middleware\n\n3. Public Endpoints (no auth):\n   - GET /health\n   - GET /version\n\n4. Protected Endpoints (require auth):\n   - GET/POST /v1/secrets\n   - GET/PUT/DELETE /v1/secrets/:name\n   - GET /v1/search?q=\n   - POST /v1/secrets/:name/clipboard\n\n5. Server Lifecycle:\n   - keyp serve command\n   - Graceful shutdown\n\nDEPENDS: Phase 3 epic, Phase 6 epic (VaultHandle)\n\nACCEPTANCE:\n- All endpoints respond correctly\n- Auth flow works\n- Integration tests pass\n- keyp serve starts and handles requests","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:37:38.0669699-05:00","updated_at":"2025-12-20T00:57:39.7424112-05:00","closed_at":"2025-12-20T00:57:39.7424112-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-36c","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:54.5095599-05:00","created_by":"daemon"},{"issue_id":"keyp-36c","depends_on_id":"keyp-elp","type":"blocks","created_at":"2025-12-17T09:07:55.8597843-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.1","title":"Define API response envelope in internal/server/types.go","description":"PROBLEM: Need consistent JSON response format for API.\n\nLOCATION: internal/server/types.go (create new file and directory)\n\nAPPROACH:\nCreate response envelope types:\n\npackage server\n\n// Response is the standard API response envelope\ntype Response struct {\n    OK    bool        `json:\"ok\"`\n    Data  interface{} `json:\"data,omitempty\"`\n    Error *APIError   `json:\"error,omitempty\"`\n}\n\n// APIError represents an error response\ntype APIError struct {\n    Code    string `json:\"code\"`\n    Message string `json:\"message\"`\n}\n\n// Common error codes\nconst (\n    ErrCodeUnauthorized    = \"UNAUTHORIZED\"\n    ErrCodeNotFound        = \"NOT_FOUND\"\n    ErrCodeBadRequest      = \"BAD_REQUEST\"\n    ErrCodeConflict        = \"CONFLICT\"\n    ErrCodeInternalError   = \"INTERNAL_ERROR\"\n)\n\n// Helper functions\nfunc SuccessResponse(data interface{}) Response {\n    return Response{OK: true, Data: data}\n}\n\nfunc ErrorResponse(code, message string) Response {\n    return Response{OK: false, Error: \u0026APIError{Code: code, Message: message}}\n}\n\nACCEPTANCE:\n- Response struct defined with json tags\n- APIError struct defined\n- Error code constants defined\n- Helper functions for creating responses\n- go build ./internal/server/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:38:22.9492552-05:00","updated_at":"2025-12-18T16:34:21.7915794-05:00","closed_at":"2025-12-18T16:34:21.7915794-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.1","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:38:22.9519135-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.10","title":"Implement POST /v1/refresh handler","description":"PROBLEM: Need endpoint to extend session without re-entering password.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\nPOST /v1/refresh\nAuthorization: Bearer \u003ctoken\u003e\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"expires_at\": \"2025-01-01T13:00:00Z\"}}\n\nAPPROACH:\ntype RefreshResponse struct {\n    ExpiresAt time.Time `json:\"expires_at\"`\n}\n\nfunc (s *Server) handleRefresh(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    \n    // Extend session expiry (not VaultHandle timeout)\n    if err := s.sessions.Refresh(session.Token, s.sessionTimeout); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to refresh session\"))\n        return\n    }\n    \n    // Get updated session\n    session, _ = s.sessions.Get(session.Token)\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(RefreshResponse{\n        ExpiresAt: session.ExpiresAt,\n    }))\n}\n\nACCEPTANCE:\n- Extends session expiry\n- Returns new expiry time\n- Requires auth (via middleware)\n- Does NOT extend VaultHandle timeout (that's separate)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:44:33.8667073-05:00","updated_at":"2025-12-18T16:34:21.8414219-05:00","closed_at":"2025-12-18T16:34:21.8414219-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.10","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:44:33.8693638-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.10","depends_on_id":"keyp-36c.8","type":"blocks","created_at":"2025-12-17T09:04:38.0546522-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.11","title":"Implement GET /health endpoint","description":"PROBLEM: Need health check endpoint for monitoring.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"status\": \"ok\"}}\n\nAPPROACH:\ntype HealthResponse struct {\n    Status string `json:\"status\"`\n}\n\nfunc (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {\n    writeJSON(w, http.StatusOK, SuccessResponse(HealthResponse{\n        Status: \"ok\",\n    }))\n}\n\nACCEPTANCE:\n- Returns 200 with status ok\n- No auth required\n- Simple and fast","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:45:02.9347428-05:00","updated_at":"2025-12-18T16:34:21.8477672-05:00","closed_at":"2025-12-18T16:34:21.8477672-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.11","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:45:02.9373949-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.11","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:04:39.5091411-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.12","title":"Implement GET /version endpoint","description":"PROBLEM: Need version endpoint for client compatibility checking.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"version\": \"2.0.0\", \"go_version\": \"go1.21\", \"build_time\": \"2025-01-01T00:00:00Z\"}}\n\nAPPROACH:\nvar (\n    Version   = \"dev\"\n    GoVersion = runtime.Version()\n    BuildTime = \"unknown\"\n)\n\ntype VersionResponse struct {\n    Version   string `json:\"version\"`\n    GoVersion string `json:\"go_version\"`\n    BuildTime string `json:\"build_time\"`\n}\n\nfunc (s *Server) handleVersion(w http.ResponseWriter, r *http.Request) {\n    writeJSON(w, http.StatusOK, SuccessResponse(VersionResponse{\n        Version:   Version,\n        GoVersion: GoVersion,\n        BuildTime: BuildTime,\n    }))\n}\n\nACCEPTANCE:\n- Returns version info\n- No auth required\n- Variables can be set via ldflags at build time","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:45:38.3794434-05:00","updated_at":"2025-12-18T16:34:21.8546731-05:00","closed_at":"2025-12-18T16:34:21.8546731-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.12","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:45:38.3827034-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.12","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:56.3639769-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.13","title":"Define SecretListItem and SecretDetail types for API responses","description":"PROBLEM: Need response types for secrets endpoints.\n\nLOCATION: internal/server/types.go\n\nAPPROACH:\nAdd API response types:\n\n// SecretListItem is used in list responses (minimal info)\ntype SecretListItem struct {\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\n// SecretDetail is used in get responses (full info, redacted by default)\ntype SecretDetail struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    Fields    []Field   `json:\"fields\"`\n    Notes     string    `json:\"notes\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\n// Field matches model.Field\ntype Field struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type\"`\n}\n\n// Conversion helpers\nfunc ToSecretListItem(s *model.SecretObject) SecretListItem { ... }\nfunc ToSecretDetail(s *model.SecretObject, redact bool) SecretDetail { ... }\n\nACCEPTANCE:\n- List item type with minimal fields\n- Detail type with all fields\n- Conversion helpers from model types\n- Uses SecretObject.Redacted() for masking","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:46:25.0289477-05:00","updated_at":"2025-12-18T16:34:21.860483-05:00","closed_at":"2025-12-18T16:34:21.860483-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.13","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:46:25.0316077-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.13","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:57.5402347-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.14","title":"Implement GET /v1/secrets endpoint","description":"PROBLEM: Need endpoint to list all secrets.\r\n\r\nLOCATION: internal/server/handlers.go\r\n\r\nRESPONSE:\r\n{\"ok\": true, \"data\": [{\"name\": \"github\", \"tags\": [\"dev\"], \"created_at\": \"...\", \"updated_at\": \"...\"}]}\r\n\r\nAPPROACH:\r\n```go\r\nfunc (s *Server) handleListSecrets(w http.ResponseWriter, r *http.Request) {\r\n    session := getSessionFromContext(r.Context())\r\n    st := session.Handle.Store()\r\n\r\n    // List() requires *SearchOptions parameter - pass nil for no filtering\r\n    secrets, err := st.List(r.Context(), nil)\r\n    if err != nil {\r\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to list secrets\"))\r\n        return\r\n    }\r\n\r\n    // Convert to API types\r\n    items := make([]SecretListItem, len(secrets))\r\n    for i, sec := range secrets {\r\n        items[i] = ToSecretListItem(sec)\r\n    }\r\n\r\n    writeJSON(w, http.StatusOK, SuccessResponse(items))\r\n}\r\n```\r\n\r\nNOTE:\r\n- store.List() signature: `List(ctx context.Context, opts *SearchOptions) ([]*model.SecretObject, error)`\r\n- Pass nil for no filtering, or \u0026store.SearchOptions{Tags: [...], Limit: N} for filtering\r\n\r\nACCEPTANCE:\r\n- Returns list of secrets\r\n- Uses SecretListItem (minimal fields)\r\n- Requires auth\r\n- Empty list returns []\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:47:03.1925642-05:00","updated_at":"2025-12-18T16:34:21.8674551-05:00","closed_at":"2025-12-18T16:34:21.8674551-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.14","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:47:03.1951859-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.14","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:05:19.7783138-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.14","depends_on_id":"keyp-nlk.6","type":"blocks","created_at":"2025-12-17T09:05:21.1308442-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.15","title":"Implement GET /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to get secret details.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc\", \"name\": \"github\", \"tags\": [], \"fields\": [{\"label\": \"value\", \"value\": \"********\", \"sensitive\": true}], ...}}\n\nAPPROACH:\nfunc (s *Server) handleGetSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Return redacted by default (sensitive values masked)\n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusOK, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Returns secret with all fields\n- Sensitive values masked by default\n- Returns 404 if not found\n- Uses path parameter for name","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:47:45.5559366-05:00","updated_at":"2025-12-18T16:34:21.8737972-05:00","closed_at":"2025-12-18T16:34:21.8737972-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:47:45.5586131-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:22.4832394-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.15","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:05:23.856098-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.16","title":"Define CreateSecretRequest and UpdateSecretRequest types","description":"PROBLEM: Need request types for POST/PUT secrets.\n\nLOCATION: internal/server/types.go\n\nAPPROACH:\nAdd request types:\n\ntype CreateSecretRequest struct {\n    Name   string        `json:\"name\"`\n    Tags   []string      `json:\"tags,omitempty\"`\n    Fields []FieldInput  `json:\"fields\"`\n    Notes  string        `json:\"notes,omitempty\"`\n}\n\ntype FieldInput struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type,omitempty\"` // defaults to \"text\"\n}\n\ntype UpdateSecretRequest struct {\n    Tags   *[]string     `json:\"tags,omitempty\"`\n    Fields *[]FieldInput `json:\"fields,omitempty\"`\n    Notes  *string       `json:\"notes,omitempty\"`\n}\n\n// Conversion helper\nfunc (r *CreateSecretRequest) ToSecretObject() *model.SecretObject { ... }\n\nNOTE: UpdateSecretRequest uses pointers to distinguish \"not provided\" from \"empty\"\n\nACCEPTANCE:\n- CreateSecretRequest for POST\n- UpdateSecretRequest for PUT (partial updates)\n- Conversion helpers to model types\n- go build ./internal/server/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:48:39.0236809-05:00","updated_at":"2025-12-18T16:34:21.8796647-05:00","closed_at":"2025-12-18T16:34:21.8796647-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:48:39.0263219-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:25.2038743-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.16","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:05:26.5640479-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.17","title":"Implement POST /v1/secrets endpoint","description":"PROBLEM: Need endpoint to create secrets.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\n{\"name\": \"github\", \"fields\": [{\"label\": \"token\", \"value\": \"ghp_xxx\", \"sensitive\": true}]}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc123\", \"name\": \"github\", ...}}\n\nAPPROACH:\nfunc (s *Server) handleCreateSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    var req CreateSecretRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Validate\n    if req.Name == \"\" {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Name is required\"))\n        return\n    }\n    if len(req.Fields) == 0 {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"At least one field is required\"))\n        return\n    }\n    \n    // Convert and create\n    secret := req.ToSecretObject()\n    if err := store.Create(r.Context(), secret); err != nil {\n        if errors.Is(err, storeErr.ErrAlreadyExists) {\n            writeJSON(w, http.StatusConflict, ErrorResponse(ErrCodeConflict, \"Secret already exists\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to create secret\"))\n        return\n    }\n    \n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusCreated, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Creates secret from JSON body\n- Returns 201 on success\n- Returns 409 if name exists\n- Validates required fields","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:49:30.7083884-05:00","updated_at":"2025-12-18T16:34:21.8866496-05:00","closed_at":"2025-12-18T16:34:21.8866496-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.17","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:49:30.7110385-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.17","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:05:50.851562-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.18","title":"Implement PUT /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to update secrets.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\n{\"tags\": [\"new-tag\"], \"fields\": [{\"label\": \"token\", \"value\": \"new-value\", \"sensitive\": true}]}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"id\": \"abc123\", \"name\": \"github\", ...}}\n\nAPPROACH:\nfunc (s *Server) handleUpdateSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    // Get existing secret\n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Parse update request\n    var req UpdateSecretRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Apply updates (only non-nil fields)\n    if req.Tags != nil {\n        secret.Tags = *req.Tags\n    }\n    if req.Fields != nil {\n        secret.Fields = convertFields(*req.Fields)\n    }\n    if req.Notes != nil {\n        secret.Notes = *req.Notes\n    }\n    \n    // Update\n    if err := store.Update(r.Context(), secret); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to update secret\"))\n        return\n    }\n    \n    detail := ToSecretDetail(secret, true)\n    writeJSON(w, http.StatusOK, SuccessResponse(detail))\n}\n\nACCEPTANCE:\n- Updates existing secret\n- Partial updates (only provided fields)\n- Returns 404 if not found\n- Uses store.Update","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:50:25.1305792-05:00","updated_at":"2025-12-18T16:34:21.8933558-05:00","closed_at":"2025-12-18T16:34:21.8933558-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:50:25.133196-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:52.2463093-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.18","depends_on_id":"keyp-36c.17","type":"blocks","created_at":"2025-12-17T09:05:53.6780741-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.19","title":"Implement DELETE /v1/secrets/:name endpoint","description":"PROBLEM: Need endpoint to delete secrets.\n\nLOCATION: internal/server/handlers.go\n\nRESPONSE: 204 No Content\n\nAPPROACH:\nfunc (s *Server) handleDeleteSecret(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    if err := store.Delete(r.Context(), name); err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to delete secret\"))\n        return\n    }\n    \n    w.WriteHeader(http.StatusNoContent)\n}\n\nACCEPTANCE:\n- Deletes secret by name\n- Returns 204 on success (no body)\n- Returns 404 if not found\n- Requires auth","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:51:00.1925796-05:00","updated_at":"2025-12-18T16:34:21.9006172-05:00","closed_at":"2025-12-18T16:34:21.9006172-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:51:00.1952043-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:55.1217952-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-36c.17","type":"blocks","created_at":"2025-12-17T09:05:56.5408558-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.19","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T09:05:57.9559246-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.2","title":"Create internal/server/router.go with middleware chain","description":"PROBLEM: Need HTTP router with middleware support.\n\nLOCATION: internal/server/router.go (create new file)\n\nREQUIREMENT: Go 1.22+ is required. This implementation uses the new http.ServeMux routing patterns introduced in Go 1.22:\n- Method prefix: \"GET /health\" instead of separate method check\n- Path parameters: \"{name}\" captured via r.PathValue(\"name\")\n\nAPPROACH:\nUse stdlib http.ServeMux (Go 1.22+):\n\npackage server\n\nimport (\n    \"net/http\"\n)\n\ntype Server struct {\n    mux      *http.ServeMux\n    address  string\n    vault    *vault.VaultHandle\n    sessions *SessionStore\n}\n\nfunc NewServer(address string, vaultPath string) *Server {\n    s := \u0026Server{\n        mux:      http.NewServeMux(),\n        address:  address,\n        sessions: NewSessionStore(),\n    }\n    \n    s.setupRoutes()\n    return s\n}\n\nfunc (s *Server) setupRoutes() {\n    // Public routes\n    s.mux.HandleFunc(\"GET /health\", s.handleHealth)\n    s.mux.HandleFunc(\"GET /version\", s.handleVersion)\n    \n    // Auth routes\n    s.mux.HandleFunc(\"POST /v1/unlock\", s.handleUnlock)\n    s.mux.HandleFunc(\"POST /v1/lock\", s.withAuth(s.handleLock))\n    s.mux.HandleFunc(\"POST /v1/refresh\", s.withAuth(s.handleRefresh))\n    \n    // Protected routes\n    s.mux.HandleFunc(\"GET /v1/secrets\", s.withAuth(s.handleListSecrets))\n    s.mux.HandleFunc(\"POST /v1/secrets\", s.withAuth(s.handleCreateSecret))\n    s.mux.HandleFunc(\"GET /v1/secrets/{name}\", s.withAuth(s.handleGetSecret))\n    s.mux.HandleFunc(\"PUT /v1/secrets/{name}\", s.withAuth(s.handleUpdateSecret))\n    s.mux.HandleFunc(\"DELETE /v1/secrets/{name}\", s.withAuth(s.handleDeleteSecret))\n    s.mux.HandleFunc(\"GET /v1/search\", s.withAuth(s.handleSearch))\n    s.mux.HandleFunc(\"POST /v1/secrets/{name}/clipboard\", s.withAuth(s.handleClipboard))\n}\n\n// Handler returns the http.Handler with middleware\nfunc (s *Server) Handler() http.Handler {\n    return s.withLogging(s.withRecovery(s.mux))\n}\n\nNOTE: In handlers, use r.PathValue(\"name\") to get path parameters.\n\nACCEPTANCE:\n- Server struct with router\n- Routes registered for all endpoints\n- Middleware chain applied\n- Uses Go 1.22+ routing patterns\n- go build ./internal/server/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:39:16.3544757-05:00","updated_at":"2025-12-18T16:34:21.8014886-05:00","closed_at":"2025-12-18T16:34:21.8014886-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.2","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:39:16.3570956-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.2","depends_on_id":"keyp-36c.1","type":"blocks","created_at":"2025-12-17T09:03:57.8937505-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.20","title":"Implement GET /v1/search endpoint","description":"PROBLEM: Need endpoint for full-text search.\r\n\r\nLOCATION: internal/server/handlers.go\r\n\r\nREQUEST: GET /v1/search?q=github\r\n\r\nRESPONSE:\r\n{\"ok\": true, \"data\": [{\"name\": \"github\", \"tags\": [\"dev\"], ...}]}\r\n\r\nAPPROACH:\r\n```go\r\nfunc (s *Server) handleSearch(w http.ResponseWriter, r *http.Request) {\r\n    session := getSessionFromContext(r.Context())\r\n    st := session.Handle.Store()\r\n\r\n    query := r.URL.Query().Get(\"q\")\r\n    if query == \"\" {\r\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Query parameter 'q' is required\"))\r\n        return\r\n    }\r\n\r\n    // Search() requires *SearchOptions parameter - pass nil for no filtering\r\n    results, err := st.Search(r.Context(), query, nil)\r\n    if err != nil {\r\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Search failed\"))\r\n        return\r\n    }\r\n\r\n    // Convert to list items\r\n    items := make([]SecretListItem, len(results))\r\n    for i, sec := range results {\r\n        items[i] = ToSecretListItem(sec)\r\n    }\r\n\r\n    writeJSON(w, http.StatusOK, SuccessResponse(items))\r\n}\r\n```\r\n\r\nNOTE:\r\n- store.Search() signature: `Search(ctx context.Context, query string, opts *SearchOptions) ([]*model.SecretObject, error)`\r\n- Pass nil for no tag filtering/limit, or \u0026store.SearchOptions{...} for filtering\r\n- SearchOptions is a pointer type, not a value type\r\n\r\nACCEPTANCE:\r\n- Searches via query parameter q\r\n- Returns matching secrets as list items\r\n- Returns 400 if q missing\r\n- Uses store.Search (FTS5)\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:51:44.2089116-05:00","updated_at":"2025-12-18T16:34:21.9071223-05:00","closed_at":"2025-12-18T16:34:21.9071223-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.20","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:51:44.2121709-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.20","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:05:59.3741497-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.21","title":"Implement POST /v1/secrets/:name/clipboard endpoint","description":"PROBLEM: Need endpoint to copy secret field to server clipboard.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST: POST /v1/secrets/:name/clipboard\n{\"field\": \"password\"}\n\nRESPONSE:\n{\"ok\": true}\n\nAPPROACH:\ntype ClipboardRequest struct {\n    Field string `json:\"field,omitempty\"` // defaults to first field\n}\n\nfunc (s *Server) handleClipboard(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    store := session.Handle.Store()\n    \n    name := r.PathValue(\"name\")\n    \n    // Get secret\n    secret, err := store.GetByName(r.Context(), name)\n    if err != nil {\n        if errors.Is(err, storeErr.ErrNotFound) {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Secret not found\"))\n            return\n        }\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to get secret\"))\n        return\n    }\n    \n    // Parse request\n    var req ClipboardRequest\n    json.NewDecoder(r.Body).Decode(\u0026req) // OK if empty\n    \n    // Find field value\n    var value string\n    if req.Field != \"\" {\n        for _, f := range secret.Fields {\n            if f.Label == req.Field {\n                value = f.Value\n                break\n            }\n        }\n        if value == \"\" {\n            writeJSON(w, http.StatusNotFound, ErrorResponse(ErrCodeNotFound, \"Field not found\"))\n            return\n        }\n    } else if len(secret.Fields) \u003e 0 {\n        value = secret.Fields[0].Value\n    }\n    \n    // Copy to clipboard (server-side)\n    if err := ui.CopyWithAutoClear(value, ui.DefaultClearDuration); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to copy to clipboard\"))\n        return\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(nil))\n}\n\nACCEPTANCE:\n- Copies field value to server clipboard\n- Optional field parameter (defaults to first)\n- Auto-clears after 45s\n- Returns 404 if secret/field not found","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:52:39.1152053-05:00","updated_at":"2025-12-18T17:02:30.7377101-05:00","closed_at":"2025-12-18T17:02:30.7377101-05:00","close_reason":"Implemented all remaining Phase 7 tasks: logging middleware, panic recovery, clipboard endpoint, integration tests","dependencies":[{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:52:39.1178804-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:06:24.1863955-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-36c.14","type":"blocks","created_at":"2025-12-17T09:06:25.4986847-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.21","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T09:06:26.8134145-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.22","title":"Add cobra serveCmd scaffold with --port, --bind, --timeout flags","description":"PROBLEM: Need serve command to start HTTP server.\n\nLOCATION: cmd/keyp/serve.go (create new file)\n\nAPPROACH:\nCreate serve command:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar (\n    servePort    int\n    serveBind    string\n    serveTimeout string\n)\n\nvar serveCmd = \u0026cobra.Command{\n    Use:   \"serve\",\n    Short: \"Start HTTP server\",\n    Long:  \"Start the keyp HTTP server for GUI access.\",\n    RunE:  runServe,\n}\n\nfunc init() {\n    serveCmd.Flags().IntVar(\u0026servePort, \"port\", 9999, \"Port to listen on\")\n    serveCmd.Flags().StringVar(\u0026serveBind, \"bind\", \"127.0.0.1\", \"Address to bind to\")\n    serveCmd.Flags().StringVar(\u0026serveTimeout, \"timeout\", \"15m\", \"Session timeout\")\n    rootCmd.AddCommand(serveCmd)\n}\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp serve --help shows usage\n- --port, --bind, --timeout flags documented\n- Defaults: port 9999, bind 127.0.0.1, timeout 15m\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:53:27.7235439-05:00","updated_at":"2025-12-18T16:34:21.9136955-05:00","closed_at":"2025-12-18T16:34:21.9136955-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.22","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:53:27.7256425-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.22","depends_on_id":"keyp-36c.10","type":"blocks","created_at":"2025-12-17T09:06:28.1145986-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.22","depends_on_id":"keyp-2fx.4","type":"blocks","created_at":"2025-12-17T09:06:29.4234222-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.23","title":"Implement Server.Start to begin listening","description":"PROBLEM: Need to start HTTP server.\n\nLOCATION: internal/server/server.go and cmd/keyp/serve.go\n\nAPPROACH:\nIn internal/server/server.go:\n\nfunc (s *Server) Start() error {\n    s.httpServer = \u0026http.Server{\n        Addr:    s.address,\n        Handler: s.Handler(),\n    }\n    \n    log.Printf(\"Starting server on %s\", s.address)\n    \n    if err := s.httpServer.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n        return fmt.Errorf(\"server error: %w\", err)\n    }\n    \n    return nil\n}\n\nIn cmd/keyp/serve.go:\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    timeout, err := time.ParseDuration(serveTimeout)\n    if err != nil {\n        return fmt.Errorf(\"invalid timeout: %w\", err)\n    }\n    \n    address := fmt.Sprintf(\"%s:%d\", serveBind, servePort)\n    \n    srv := server.NewServer(address, getVaultPath())\n    srv.SetSessionTimeout(timeout)\n    \n    fmt.Printf(\"Server starting on http://%s\\n\", address)\n    fmt.Println(\"Press Ctrl+C to stop\")\n    \n    return srv.Start()\n}\n\nACCEPTANCE:\n- Server binds to specified address\n- Logs startup message\n- ListenAndServe blocks until stopped\n- Returns error on bind failure","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:54:17.0767352-05:00","updated_at":"2025-12-18T16:34:21.919779-05:00","closed_at":"2025-12-18T16:34:21.919779-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.23","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:54:17.0793499-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.24","title":"Implement Server.Shutdown for graceful termination","description":"PROBLEM: Need graceful shutdown on SIGINT/SIGTERM.\n\nLOCATION: internal/server/server.go and cmd/keyp/serve.go\n\nAPPROACH:\nIn internal/server/server.go:\n\nfunc (s *Server) Shutdown(ctx context.Context) error {\n    log.Println(\"Shutting down server...\")\n    \n    // Lock all active sessions' vault handles\n    s.sessions.LockAll()\n    \n    // Shutdown HTTP server\n    if err := s.httpServer.Shutdown(ctx); err != nil {\n        return fmt.Errorf(\"shutdown error: %w\", err)\n    }\n    \n    log.Println(\"Server stopped\")\n    return nil\n}\n\nIn cmd/keyp/serve.go (update runServe):\n\nfunc runServe(cmd *cobra.Command, args []string) error {\n    // ... server setup ...\n    \n    // Setup signal handling\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n    \n    // Start server in goroutine\n    errCh := make(chan error, 1)\n    go func() {\n        errCh \u003c- srv.Start()\n    }()\n    \n    // Wait for signal or error\n    select {\n    case \u003c-sigCh:\n        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n        defer cancel()\n        return srv.Shutdown(ctx)\n    case err := \u003c-errCh:\n        return err\n    }\n}\n\nACCEPTANCE:\n- Handles SIGINT and SIGTERM\n- Graceful shutdown with timeout\n- Locks all vault handles before exit\n- Drains active connections","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:55:00.4936526-05:00","updated_at":"2025-12-18T16:34:21.9258751-05:00","closed_at":"2025-12-18T16:34:21.9258751-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:55:00.4962735-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.23","type":"blocks","created_at":"2025-12-17T09:06:56.3838534-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:06:57.9010309-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.15","type":"blocks","created_at":"2025-12-17T09:06:59.4237107-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.16","type":"blocks","created_at":"2025-12-17T09:07:00.9544806-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.18","type":"blocks","created_at":"2025-12-17T09:07:02.4887928-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.19","type":"blocks","created_at":"2025-12-17T09:07:04.0108349-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.20","type":"blocks","created_at":"2025-12-17T09:07:05.5583031-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.21","type":"blocks","created_at":"2025-12-17T09:07:07.1621527-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.24","depends_on_id":"keyp-36c.22","type":"blocks","created_at":"2025-12-17T09:07:08.6800679-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.25","title":"Add HTTP server integration tests","description":"PROBLEM: HTTP server needs integration tests.\n\nLOCATION: internal/server/server_test.go (create new file)\n\nTEST SCENARIOS:\n1. Auth Flow:\n   - POST /v1/unlock with correct password returns token\n   - POST /v1/unlock with wrong password returns 401\n   - Protected endpoints without token return 401\n   - Protected endpoints with invalid token return 401\n   - POST /v1/lock invalidates session\n   - POST /v1/refresh extends session\n\n2. Public Endpoints:\n   - GET /health returns ok\n   - GET /version returns version info\n\n3. CRUD Operations:\n   - POST /v1/secrets creates secret\n   - GET /v1/secrets lists secrets\n   - GET /v1/secrets/:name returns secret\n   - PUT /v1/secrets/:name updates secret\n   - DELETE /v1/secrets/:name deletes secret\n   - Operations on non-existent return 404\n\n4. Search:\n   - GET /v1/search?q=... returns matches\n   - Empty query returns 400\n\n5. Error Handling:\n   - Invalid JSON returns 400\n   - Missing required fields returns 400\n\nAPPROACH:\nUse httptest.Server for testing. Create test vault.\n\nACCEPTANCE:\n- go test ./internal/server/ passes\n- Tests cover auth flow, CRUD, search, errors\n- Tests clean up resources","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:55:54.7428142-05:00","updated_at":"2025-12-18T17:02:30.7440278-05:00","closed_at":"2025-12-18T17:02:30.7440278-05:00","close_reason":"Implemented all remaining Phase 7 tasks: logging middleware, panic recovery, clipboard endpoint, integration tests","dependencies":[{"issue_id":"keyp-36c.25","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:55:54.7454534-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.25","depends_on_id":"keyp-36c.24","type":"blocks","created_at":"2025-12-17T09:07:26.2824306-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.3","title":"Add request logging middleware","description":"PROBLEM: Need to log HTTP requests for debugging.\n\nLOCATION: internal/server/middleware.go (create new file)\n\nAPPROACH:\nCreate logging middleware:\n\npackage server\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"time\"\n)\n\n// responseWriter wraps http.ResponseWriter to capture status code\ntype responseWriter struct {\n    http.ResponseWriter\n    status int\n}\n\nfunc (rw *responseWriter) WriteHeader(code int) {\n    rw.status = code\n    rw.ResponseWriter.WriteHeader(code)\n}\n\nfunc (s *Server) withLogging(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        \n        rw := \u0026responseWriter{ResponseWriter: w, status: http.StatusOK}\n        next.ServeHTTP(rw, r)\n        \n        duration := time.Since(start)\n        log.Printf(\"%s %s %d %v\", r.Method, r.URL.Path, rw.status, duration)\n    })\n}\n\nACCEPTANCE:\n- Logs method, path, status, duration\n- Captures actual status code\n- Doesn't interfere with response\n- go build ./internal/server/ compiles","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:39:55.2852505-05:00","updated_at":"2025-12-18T17:02:30.7215328-05:00","closed_at":"2025-12-18T17:02:30.7215328-05:00","close_reason":"Implemented all remaining Phase 7 tasks: logging middleware, panic recovery, clipboard endpoint, integration tests","dependencies":[{"issue_id":"keyp-36c.3","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:39:55.2873559-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.3","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:03:59.0989926-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.4","title":"Add panic recovery middleware","description":"PROBLEM: Need to catch panics and return 500 error.\n\nLOCATION: internal/server/middleware.go\n\nAPPROACH:\nAdd recovery middleware:\n\nfunc (s *Server) withRecovery(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"panic: %v\", err)\n                \n                w.Header().Set(\"Content-Type\", \"application/json\")\n                w.WriteHeader(http.StatusInternalServerError)\n                \n                resp := ErrorResponse(ErrCodeInternalError, \"Internal server error\")\n                json.NewEncoder(w).Encode(resp)\n            }\n        }()\n        \n        next.ServeHTTP(w, r)\n    })\n}\n\nACCEPTANCE:\n- Catches panics\n- Returns 500 with error envelope\n- Logs panic for debugging\n- Doesn't crash server\n- go build ./internal/server/ compiles","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:40:29.7426079-05:00","updated_at":"2025-12-18T17:02:30.7314662-05:00","closed_at":"2025-12-18T17:02:30.7314662-05:00","close_reason":"Implemented all remaining Phase 7 tasks: logging middleware, panic recovery, clipboard endpoint, integration tests","dependencies":[{"issue_id":"keyp-36c.4","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:40:29.7452896-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.4","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:00.3162976-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.5","title":"Define SessionStore interface and MemorySessionStore","description":"PROBLEM: Need session management for API authentication.\n\nLOCATION: internal/server/session.go (create new file)\n\nAPPROACH:\nCreate session store with in-memory implementation:\n\npackage server\n\nimport (\n    \"sync\"\n    \"time\"\n    \"github.com/TheEditor/keyp/internal/vault\"\n)\n\ntype Session struct {\n    Token     string\n    Handle    *vault.VaultHandle\n    CreatedAt time.Time\n    ExpiresAt time.Time\n}\n\ntype SessionStore interface {\n    Create(handle *vault.VaultHandle, expiry time.Duration) (*Session, error)\n    Get(token string) (*Session, error)\n    Delete(token string) error\n    Refresh(token string, expiry time.Duration) error\n    Cleanup() // Remove expired sessions\n}\n\ntype MemorySessionStore struct {\n    mu       sync.RWMutex\n    sessions map[string]*Session\n}\n\nfunc NewSessionStore() *MemorySessionStore {\n    store := \u0026MemorySessionStore{\n        sessions: make(map[string]*Session),\n    }\n    \n    // Start cleanup goroutine\n    go store.cleanupLoop()\n    \n    return store\n}\n\nfunc (m *MemorySessionStore) cleanupLoop() {\n    ticker := time.NewTicker(time.Minute)\n    for range ticker.C {\n        m.Cleanup()\n    }\n}\n\nACCEPTANCE:\n- Session struct with token, handle, timestamps\n- SessionStore interface defined\n- MemorySessionStore implements interface\n- Thread-safe with mutex\n- go build ./internal/server/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:41:11.265588-05:00","updated_at":"2025-12-18T16:34:21.808109-05:00","closed_at":"2025-12-18T16:34:21.808109-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.5","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:41:11.2677233-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.6","title":"Add token generation using crypto/rand","description":"PROBLEM: Need secure token generation for sessions.\n\nLOCATION: internal/server/session.go\n\nAPPROACH:\nAdd token generation function:\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n)\n\nconst TokenBytes = 32 // 256 bits\n\nfunc generateToken() (string, error) {\n    bytes := make([]byte, TokenBytes)\n    if _, err := rand.Read(bytes); err != nil {\n        return \"\", fmt.Errorf(\"failed to generate token: %w\", err)\n    }\n    return hex.EncodeToString(bytes), nil\n}\n\n// Used in SessionStore.Create\nfunc (m *MemorySessionStore) Create(handle *vault.VaultHandle, expiry time.Duration) (*Session, error) {\n    token, err := generateToken()\n    if err != nil {\n        return nil, err\n    }\n    \n    session := \u0026Session{\n        Token:     token,\n        Handle:    handle,\n        CreatedAt: time.Now(),\n        ExpiresAt: time.Now().Add(expiry),\n    }\n    \n    m.mu.Lock()\n    m.sessions[token] = session\n    m.mu.Unlock()\n    \n    return session, nil\n}\n\nACCEPTANCE:\n- Generates 32 bytes (256 bits) of randomness\n- Returns hex-encoded string (64 chars)\n- Uses crypto/rand (not math/rand)\n- go build ./internal/server/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:41:51.2034473-05:00","updated_at":"2025-12-18T16:34:21.8154858-05:00","closed_at":"2025-12-18T16:34:21.8154858-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.6","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:41:51.207313-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.6","depends_on_id":"keyp-36c.5","type":"blocks","created_at":"2025-12-17T09:04:29.1142115-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.6","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:04:30.5675369-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.7","title":"Implement POST /v1/unlock handler","description":"PROBLEM: Need endpoint to unlock vault and get session token.\n\nLOCATION: internal/server/handlers.go (create new file)\n\nREQUEST:\nPOST /v1/unlock\n{\"password\": \"vault-password\"}\n\nRESPONSE:\n{\"ok\": true, \"data\": {\"token\": \"abc123...\", \"expires_at\": \"2025-01-01T12:00:00Z\"}}\n\nAPPROACH:\ntype UnlockRequest struct {\n    Password string `json:\"password\"`\n}\n\ntype UnlockResponse struct {\n    Token     string    `json:\"token\"`\n    ExpiresAt time.Time `json:\"expires_at\"`\n}\n\nfunc (s *Server) handleUnlock(w http.ResponseWriter, r *http.Request) {\n    var req UnlockRequest\n    if err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n        writeJSON(w, http.StatusBadRequest, ErrorResponse(ErrCodeBadRequest, \"Invalid JSON\"))\n        return\n    }\n    \n    // Create vault handle and unlock\n    handle := vault.NewHandle(s.vaultPath)\n    if err := handle.Unlock(req.Password); err != nil {\n        writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Invalid password\"))\n        return\n    }\n    \n    // Create session\n    session, err := s.sessions.Create(handle, s.sessionTimeout)\n    if err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to create session\"))\n        return\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(UnlockResponse{\n        Token:     session.Token,\n        ExpiresAt: session.ExpiresAt,\n    }))\n}\n\nACCEPTANCE:\n- Accepts password in JSON body\n- Returns token and expiry on success\n- Returns 401 for wrong password\n- Creates session in store","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:42:38.7991609-05:00","updated_at":"2025-12-18T16:34:21.8218696-05:00","closed_at":"2025-12-18T16:34:21.8218696-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.7","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:42:38.8018168-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.7","depends_on_id":"keyp-36c.6","type":"blocks","created_at":"2025-12-17T09:04:32.0172146-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.8","title":"Implement POST /v1/lock handler","description":"PROBLEM: Need endpoint to lock vault and invalidate session.\n\nLOCATION: internal/server/handlers.go\n\nREQUEST:\nPOST /v1/lock\nAuthorization: Bearer \u003ctoken\u003e\n\nRESPONSE:\n{\"ok\": true}\n\nAPPROACH:\nfunc (s *Server) handleLock(w http.ResponseWriter, r *http.Request) {\n    session := getSessionFromContext(r.Context())\n    \n    // Lock the vault handle\n    if err := session.Handle.Lock(); err != nil {\n        writeJSON(w, http.StatusInternalServerError, ErrorResponse(ErrCodeInternalError, \"Failed to lock vault\"))\n        return\n    }\n    \n    // Delete session\n    if err := s.sessions.Delete(session.Token); err != nil {\n        // Log but don't fail - vault is locked\n        log.Printf(\"failed to delete session: %v\", err)\n    }\n    \n    writeJSON(w, http.StatusOK, SuccessResponse(nil))\n}\n\nACCEPTANCE:\n- Locks vault handle\n- Deletes session from store\n- Returns 200 on success\n- Requires auth (via middleware)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:43:14.3927604-05:00","updated_at":"2025-12-18T16:34:21.8281783-05:00","closed_at":"2025-12-18T16:34:21.8281783-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:43:14.3953804-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c.7","type":"blocks","created_at":"2025-12-17T09:04:33.5700584-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.8","depends_on_id":"keyp-36c.2","type":"blocks","created_at":"2025-12-17T09:04:35.0897039-05:00","created_by":"daemon"}]}
{"id":"keyp-36c.9","title":"Add auth middleware for Bearer token extraction","description":"PROBLEM: Protected endpoints need auth verification.\n\nLOCATION: internal/server/middleware.go\n\nAPPROACH:\nCreate auth middleware:\n\ntype contextKey string\n\nconst sessionKey contextKey = \"session\"\n\nfunc (s *Server) withAuth(next http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Extract Bearer token\n        auth := r.Header.Get(\"Authorization\")\n        if !strings.HasPrefix(auth, \"Bearer \") {\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Missing or invalid Authorization header\"))\n            return\n        }\n        \n        token := strings.TrimPrefix(auth, \"Bearer \")\n        \n        // Lookup session\n        session, err := s.sessions.Get(token)\n        if err != nil {\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Invalid or expired token\"))\n            return\n        }\n        \n        // Check expiry\n        if time.Now().After(session.ExpiresAt) {\n            s.sessions.Delete(token)\n            writeJSON(w, http.StatusUnauthorized, ErrorResponse(ErrCodeUnauthorized, \"Session expired\"))\n            return\n        }\n        \n        // Add session to context\n        ctx := context.WithValue(r.Context(), sessionKey, session)\n        next.ServeHTTP(w, r.WithContext(ctx))\n    }\n}\n\nfunc getSessionFromContext(ctx context.Context) *Session {\n    return ctx.Value(sessionKey).(*Session)\n}\n\nACCEPTANCE:\n- Extracts Bearer token from Authorization header\n- Looks up session in store\n- Returns 401 for invalid/expired tokens\n- Adds session to request context\n- Helper to get session from context","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:43:58.5758484-05:00","updated_at":"2025-12-18T16:34:21.8350958-05:00","closed_at":"2025-12-18T16:34:21.8350958-05:00","close_reason":"Implemented in Phase 7 server infrastructure","dependencies":[{"issue_id":"keyp-36c.9","depends_on_id":"keyp-36c","type":"parent-child","created_at":"2025-12-17T08:43:58.5786207-05:00","created_by":"daemon"},{"issue_id":"keyp-36c.9","depends_on_id":"keyp-36c.8","type":"blocks","created_at":"2025-12-17T09:04:36.5743545-05:00","created_by":"daemon"}]}
{"id":"keyp-4vr","title":"Index field labels in FTS5 for search","description":"Search for 'PIN' returns no results even though secret has fields labeled 'Account PIN' and 'Support PIN'. FTS5 index only covers secret name/tags/notes, not field labels. Add field labels to FTS index so 'keyp search PIN' finds secrets with PIN fields.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-22T17:41:14.8969018-05:00","updated_at":"2025-12-22T17:55:15.2201025-05:00","closed_at":"2025-12-22T17:55:15.2201025-05:00","close_reason":"Added field labels to FTS5 index. Modified schema to add field_labels column to secrets_fts virtual table. Updated Create and Update functions to populate field_labels with space-separated field labels. Added rebuildFTSIndex and getFieldLabelsForSecret helper functions to migrate existing data and populate field labels for all secrets. Now searching for 'PIN' will find secrets with fields labeled 'Account PIN', 'Support PIN', etc."}
{"id":"keyp-5za","title":"init.go does not save session after unlock","description":"init.go unlocks vault but does not save session to disk. Subsequent commands prompt for password because session file does not exist.\n\nLOCATION: cmd/keyp/init.go around line 47\n\nFIND the block after successful unlock:\n    setVaultHandle(handle)\n\nADD after setVaultHandle:\n    if derivedKey := handle.GetDerivedKey(); derivedKey != nil {\n        sessionMgr.Save(derivedKey)\n    }\n\nACCEPTANCE: After keyp init, running keyp list does not prompt for password.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-23T17:26:17.1218296-05:00","updated_at":"2025-12-23T17:34:10.8204146-05:00","closed_at":"2025-12-23T17:34:10.8204146-05:00","close_reason":"Added session persistence after unlock in init.go. After setVaultHandle(), the derived key is saved via sessionMgr.Save() to persist the session to disk, preventing password prompts on subsequent commands."}
{"id":"keyp-8wy","title":"Phase 2: SQLite storage and data model","description":"Implement SecretObject/Field model types, SQLite storage with FTS5 full-text search, and vault lifecycle management.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-15T15:53:33.8534241-05:00","updated_at":"2025-12-15T16:06:09.3011272-05:00","closed_at":"2025-12-15T16:06:09.3011272-05:00","close_reason":"Phase 2 complete: SQLite storage and data model. All model, store, vault, and sync components implemented."}
{"id":"keyp-8wy.1","title":"Implement SecretObject and Field model types","description":"Create domain model types for structured secrets with SecretObject containing Fields, plus factory functions and helper methods.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:54:00.3436226-05:00","updated_at":"2025-12-15T15:58:28.0239955-05:00","closed_at":"2025-12-15T15:58:28.0239955-05:00","close_reason":"Implemented model types with SecretObject and Field, factory functions, and JSON serialization","dependencies":[{"issue_id":"keyp-8wy.1","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:00.346373-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.2","title":"Implement SQLite store with FTS5 search","description":"Create SQLite storage layer with full-text search using FTS5 virtual table, schema initialization, CRUD operations, and search functionality.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-15T15:54:28.0531579-05:00","updated_at":"2025-12-15T16:01:42.808729-05:00","closed_at":"2025-12-15T16:01:42.808729-05:00","close_reason":"Implemented SQLite store with FTS5, schema initialization, CRUD operations, and full-text search","dependencies":[{"issue_id":"keyp-8wy.2","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:28.057009-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.2","depends_on_id":"keyp-8wy.1","type":"blocks","created_at":"2025-12-15T15:56:07.4203974-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.3","title":"Add store unit tests","description":"Create comprehensive tests for SQLite store covering create, get, list, search, delete operations and error cases.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:54:53.5112156-05:00","updated_at":"2025-12-15T16:02:44.8984634-05:00","closed_at":"2025-12-15T16:02:44.8984634-05:00","close_reason":"Added comprehensive store tests covering create, get, list, search, delete and error cases","dependencies":[{"issue_id":"keyp-8wy.3","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:54:53.5138695-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.3","depends_on_id":"keyp-8wy.2","type":"blocks","created_at":"2025-12-15T15:56:08.9283899-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.4","title":"Implement vault lifecycle manager","description":"Create vault manager handling init, unlock, lock operations with store lifecycle and locked state checking.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T15:55:18.7213627-05:00","updated_at":"2025-12-15T16:03:57.6889325-05:00","closed_at":"2025-12-15T16:03:57.6889325-05:00","close_reason":"Implemented vault lifecycle manager with init, open, lock, and store delegation","dependencies":[{"issue_id":"keyp-8wy.4","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:55:18.7235388-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.4","depends_on_id":"keyp-8wy.2","type":"blocks","created_at":"2025-12-15T15:56:10.4521036-05:00","created_by":"daemon"}]}
{"id":"keyp-8wy.5","title":"Define git sync interface with placeholder implementation","description":"Create sync interface to isolate future git dependency with NoopSyncer placeholder implementation.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T15:55:44.9482487-05:00","updated_at":"2025-12-15T16:05:18.5312202-05:00","closed_at":"2025-12-15T16:05:18.5312202-05:00","close_reason":"Implemented sync interface with NoopSyncer placeholder for Phase 3 git implementation","dependencies":[{"issue_id":"keyp-8wy.5","depends_on_id":"keyp-8wy","type":"parent-child","created_at":"2025-12-15T15:55:44.9508875-05:00","created_by":"daemon"},{"issue_id":"keyp-8wy.5","depends_on_id":"keyp-8wy.4","type":"blocks","created_at":"2025-12-15T15:56:11.9399496-05:00","created_by":"daemon"}]}
{"id":"keyp-d7o","title":"Add session persistence to avoid repeated password prompts","description":"Every command prompts for vault password. After unlock or init, subsequent commands should use cached session until lock or timeout.\n\nApproach: File-based session with timeout.\n\nNew file: internal/session/session.go\n\nSession file: ~/.keyp/session containing derived key in hex plus expiry timestamp. File permissions 0600. Default timeout 15 minutes.\n\nFunctions: Save writes key and timeout. Load returns key or error if expired or missing. Clear deletes session file.\n\nChanges: unlock.go calls Save after success. init.go calls Save after success. lock.go calls Clear. Password prompt logic checks Load first and only prompts if no valid session.\n\nAcceptance: keyp init followed by keyp list does not prompt. keyp lock followed by keyp list does prompt. After 15 minutes idle the next command prompts.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-23T12:37:35.0261305-05:00","updated_at":"2025-12-23T12:41:44.73126-05:00","closed_at":"2025-12-23T12:41:44.73126-05:00","close_reason":"Implemented file-based session persistence with 15-minute default timeout. Created internal/session/session.go with Save, Load, and Clear methods. Modified vault_helper.go to check session before prompting for password and save derived key after unlock. Added GetDerivedKey() and UnlockWithKey() methods to VaultHandle. Session stored in ~/.keyp/session with restricted permissions (0600)"}
{"id":"keyp-dbf","title":"CLI polish and scriptability enhancements","description":"Post-session-persistence polish pass. Includes output formatting fixes, scriptability features, and configuration support.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-23T20:41:36.127295-05:00","updated_at":"2025-12-23T20:41:36.127295-05:00"}
{"id":"keyp-dbf.1","title":"Fix tag command output formatting","description":"Tag add output shows array syntax like [telecom family]. Change to comma-separated format matching list output: Tags added: telecom, family. Location: cmd/keyp/tag.go. Use strings.Join with comma-space separator.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-24T02:33:05.4377157-05:00","updated_at":"2025-12-24T12:43:05.1921573-05:00","closed_at":"2025-12-24T12:43:05.1921573-05:00","close_reason":"Changed tag command output from array format to comma-separated format using strings.Join(). Multiple tags now display as 'Tags added: tag1, tag2' instead of array syntax.","dependencies":[{"issue_id":"keyp-dbf.1","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:33:05.4419542-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.2","title":"Fix search output redundancy and pluralization","description":"Search says Found 1 secret(s) which is ugly. Location: cmd/keyp/search.go. Zero results: No secrets match X. One result: Found 1 secret matching X. Multiple: Found N secrets matching X. Remove the (s) hack.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-24T02:33:30.3399389-05:00","updated_at":"2025-12-24T12:45:20.4661789-05:00","closed_at":"2025-12-24T12:45:20.4661789-05:00","close_reason":"Fixed search output pluralization - now displays 'Found 1 secret matching X' (singular) or 'Found N secrets matching X' (plural). Zero results show 'No secrets match X'. Removed the (s) hack.","dependencies":[{"issue_id":"keyp-dbf.2","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:33:30.3425717-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.3","title":"Implement distinct exit codes","description":"Add exit codes for scripting. New file internal/cli/exitcodes.go with constants: ExitSuccess=0, ExitError=1, ExitNotFound=2, ExitAuthFailed=3, ExitVaultLocked=4. In main.go error handler, check error type and call os.Exit with appropriate code. Test: keyp get nonexistent should return exit code 2.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-24T02:33:52.8523523-05:00","updated_at":"2025-12-24T12:23:41.7725758-05:00","closed_at":"2025-12-24T12:23:41.7725758-05:00","close_reason":"Implemented distinct exit codes with ExitSuccess=0, ExitError=1, ExitNotFound=2, ExitAuthFailed=3, ExitVaultLocked=4. Added getExitCode function in main.go that maps error types to appropriate exit codes.","dependencies":[{"issue_id":"keyp-dbf.3","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:33:52.854451-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.4","title":"Add --json flag for structured output","description":"Add persistent --json flag to root command. When set, list/search output JSON array of secrets, show outputs JSON object with fields, get outputs JSON object with value. Locations: root.go for flag, list.go search.go show.go get.go for output logic. Use encoding/json Marshal.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-24T02:34:13.9459661-05:00","updated_at":"2025-12-24T12:33:46.373392-05:00","closed_at":"2025-12-24T12:33:46.373392-05:00","close_reason":"Added persistent --json flag to root command. Updated list, search, show, and get commands to output JSON format. List and search output JSON arrays, show outputs JSON object with fields, get outputs JSON object with value.","dependencies":[{"issue_id":"keyp-dbf.4","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:34:13.9485923-05:00","created_by":"daemon"},{"issue_id":"keyp-dbf.4","depends_on_id":"keyp-dbf.3","type":"blocks","created_at":"2025-12-24T03:21:11.2346525-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.5","title":"Add stdout mode for get command","description":"Add --stdout flag to get command. When set, print value to stdout instead of copying to clipboard. Location: cmd/keyp/get.go. Enables piping: keyp get token --stdout | somecommand","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-24T02:34:36.2438861-05:00","updated_at":"2025-12-24T12:26:53.2180028-05:00","closed_at":"2025-12-24T12:26:53.2180028-05:00","close_reason":"Already implemented - get command has --stdout flag that prints value to stdout instead of clipboard, enabling piping like 'keyp get token --stdout | somecommand'","dependencies":[{"issue_id":"keyp-dbf.5","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:34:36.2465228-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.6","title":"Add --field selector to get command","description":"Add --field flag to get command. When set, return specific field by label instead of first field. Location: cmd/keyp/get.go. If field not found, return error and exit code 2. Example: keyp get ATT --field AccountPIN","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-24T02:34:37.9825358-05:00","updated_at":"2025-12-24T12:36:43.4595695-05:00","closed_at":"2025-12-24T12:36:43.4595695-05:00","close_reason":"Already implemented - get command has --field flag to retrieve specific field by label. Returns exit code 2 (ExitNotFound) when field not found.","dependencies":[{"issue_id":"keyp-dbf.6","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:34:37.9851663-05:00","created_by":"daemon"},{"issue_id":"keyp-dbf.6","depends_on_id":"keyp-dbf.5","type":"blocks","created_at":"2025-12-24T03:21:14.5784877-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.7","title":"Add --porcelain flag for stable output","description":"Add --porcelain flag to list and search commands. Output tab-separated values with no headers. Format: name TAB tags TAB updated. Tags comma-joined, date as YYYY-MM-DD. Locations: cmd/keyp/list.go and cmd/keyp/search.go","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-24T02:34:58.8187606-05:00","updated_at":"2025-12-24T12:47:11.2819494-05:00","dependencies":[{"issue_id":"keyp-dbf.7","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:34:58.821383-05:00","created_by":"daemon"},{"issue_id":"keyp-dbf.7","depends_on_id":"keyp-dbf.4","type":"blocks","created_at":"2025-12-24T03:21:12.9189233-05:00","created_by":"daemon"}]}
{"id":"keyp-dbf.8","title":"Add config file support for session timeout","description":"New file internal/config/config.go. Load ~/.keyp/config.yaml if exists. Support session_timeout as duration string like 30m or 1h. Environment variable KEYP_SESSION_TIMEOUT overrides config. Update internal/session/session.go to use config instead of hardcoded default.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-24T02:35:00.5588201-05:00","updated_at":"2025-12-24T02:35:00.5588201-05:00","dependencies":[{"issue_id":"keyp-dbf.8","depends_on_id":"keyp-dbf","type":"parent-child","created_at":"2025-12-24T02:35:00.5614542-05:00","created_by":"daemon"}]}
{"id":"keyp-ecl","title":"Auto-unlock vault after init","description":"After 'keyp init' creates a new vault, user must immediately run unlock or re-enter password for next command. Vault should remain unlocked after successful init since user just proved they know the password. Return unlocked handle from vault.Init() or auto-unlock in runInit().","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T17:40:58.9541172-05:00","updated_at":"2025-12-22T17:52:34.1198279-05:00","closed_at":"2025-12-22T17:52:34.1198279-05:00","close_reason":"Auto-unlock vault after init. Modified runInit() to create and unlock a VaultHandle immediately after successful vault initialization, storing it in the global handle. User no longer needs to re-enter password for the next command after init."}
{"id":"keyp-elp","title":"Phase 6: Vault Lock/Unlock UX","description":"Implement VaultHandle for persistent unlock and CLI lock/unlock commands.\n\nComponents:\n1. VaultHandle struct (shared by CLI and HTTP server):\n   - Holds open db, derived key, unlock timestamp\n   - Unlock/Lock/IsExpired methods\n\n2. CLI Commands:\n   - keyp unlock [--timeout]: unlock vault, keep handle\n   - keyp lock: explicitly lock vault\n   - Auto-lock: check expiry before each command\n\nDEPENDS: Phase 3 epic (core CLI)\n\nACCEPTANCE:\n- VaultHandle manages unlock state\n- unlock/lock commands work\n- Auto-lock after timeout works\n- Unit and integration tests pass","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:29:58.9695451-05:00","updated_at":"2025-12-18T16:12:17.7024071-05:00","closed_at":"2025-12-18T16:12:17.7024071-05:00","close_reason":"Completed Phase 6 - VaultHandle with Unlock/Lock commands implemented, along with keyp unlock and keyp lock CLI commands for vault session management","dependencies":[{"issue_id":"keyp-elp","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:53.1615882-05:00","created_by":"daemon"},{"issue_id":"keyp-elp","depends_on_id":"keyp-u9i","type":"blocks","created_at":"2025-12-18T14:44:33.5632411-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.1","title":"Define VaultHandle struct in internal/vault/handle.go","description":"PROBLEM: Need shared handle for persistent vault unlock state.\r\n\r\nLOCATION: internal/vault/handle.go (create new file)\r\n\r\nAPPROACH:\r\nCreate VaultHandle struct:\r\n\r\n```go\r\npackage vault\r\n\r\nimport (\r\n    \"sync\"\r\n    \"time\"\r\n    \"github.com/TheEditor/keyp/internal/store\"\r\n)\r\n\r\ntype VaultHandle struct {\r\n    mu         sync.RWMutex\r\n    store      *store.Store  // NOTE: Type is store.Store, not SQLiteStore\r\n    key        []byte        // Derived encryption key (for future use)\r\n    unlockedAt time.Time\r\n    timeout    time.Duration\r\n    path       string\r\n}\r\n\r\n// NewHandle creates a handle (call Unlock to actually unlock)\r\nfunc NewHandle(path string) *VaultHandle {\r\n    return \u0026VaultHandle{path: path}\r\n}\r\n\r\n// Path returns the vault path\r\nfunc (h *VaultHandle) Path() string {\r\n    return h.path\r\n}\r\n\r\n// Store returns the store (nil if locked)\r\nfunc (h *VaultHandle) Store() *store.Store {\r\n    h.mu.RLock()\r\n    defer h.mu.RUnlock()\r\n    return h.store\r\n}\r\n\r\n// IsUnlocked returns true if vault is currently unlocked\r\nfunc (h *VaultHandle) IsUnlocked() bool {\r\n    h.mu.RLock()\r\n    defer h.mu.RUnlock()\r\n    return h.store != nil\r\n}\r\n```\r\n\r\nNOTE: The store type is `*store.Store` (not SQLiteStore). The `key` field\r\nis reserved for future encryption integration but not used until Phase 2.75\r\nis complete.\r\n\r\nACCEPTANCE:\r\n- VaultHandle struct defined\r\n- Basic accessors implemented\r\n- Thread-safe with mutex\r\n- go build ./internal/vault/ compiles\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:30:40.4152864-05:00","updated_at":"2025-12-18T16:11:28.4893068-05:00","closed_at":"2025-12-18T16:11:28.4893068-05:00","close_reason":"Implemented VaultHandle struct with Unlock/Lock/IsExpired methods and timeout support","dependencies":[{"issue_id":"keyp-elp.1","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:30:40.4227006-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.10","title":"Add CLI lock/unlock integration tests","description":"PROBLEM: Lock/unlock functionality needs integration tests.\n\nLOCATION: cmd/keyp/cli_test.go (add to existing)\n\nTEST SCENARIOS:\n1. Unlock:\n   - Unlocks vault with correct password\n   - Fails with wrong password\n   - Subsequent commands don't prompt\n\n2. Lock:\n   - Locks unlocked vault\n   - No error if already locked\n   - Commands prompt after lock\n\n3. Auto-lock:\n   - Vault auto-locks after timeout\n   - User prompted on next command\n\n4. Session persistence:\n   - Multiple commands use same session\n   - Session extended on each use\n\nAPPROACH:\nUse test vault and simulate multiple command invocations.\nMay need to mock time for timeout tests.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover lock/unlock/auto-lock scenarios\n- Tests verify security behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:36:52.0305462-05:00","updated_at":"2025-12-20T02:28:09.9117356-05:00","closed_at":"2025-12-20T02:28:09.9117356-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:36:52.0337055-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.7","type":"blocks","created_at":"2025-12-17T09:03:36.8612075-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.6","type":"blocks","created_at":"2025-12-17T09:03:38.3222935-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.10","depends_on_id":"keyp-elp.9","type":"blocks","created_at":"2025-12-17T09:03:39.7708399-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.2","title":"Add VaultHandle.Unlock method","description":"PROBLEM: Need to unlock vault with password.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement Unlock method:\n\nfunc (h *VaultHandle) Unlock(password string) error {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    \n    if h.store != nil {\n        return nil // Already unlocked\n    }\n    \n    // Derive key from password\n    key, err := core.DeriveKey(password, h.getSalt())\n    if err != nil {\n        return fmt.Errorf(\"failed to derive key: %w\", err)\n    }\n    \n    // Open store with derived key\n    dbPath := filepath.Join(h.path, \"vault.db\")\n    s, err := store.Open(dbPath, key)\n    if err != nil {\n        // Zero key memory on failure\n        for i := range key {\n            key[i] = 0\n        }\n        return fmt.Errorf(\"failed to open vault: %w\", err)\n    }\n    \n    h.store = s\n    h.key = key\n    h.unlockedAt = time.Now()\n    \n    return nil\n}\n\n// Helper to get salt from vault\nfunc (h *VaultHandle) getSalt() []byte {\n    saltPath := filepath.Join(h.path, \"salt\")\n    salt, _ := os.ReadFile(saltPath)\n    return salt\n}\n\nACCEPTANCE:\n- Derives key from password\n- Opens store connection\n- Stores unlock timestamp\n- Returns nil if already unlocked\n- Zeros key on failure","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:31:23.3708923-05:00","updated_at":"2025-12-20T02:08:14.6595553-05:00","closed_at":"2025-12-20T02:08:14.6595553-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.2","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:31:23.379507-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.2","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:55.0328153-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.3","title":"Add VaultHandle.Lock method","description":"PROBLEM: Need to securely lock vault.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement Lock method that securely clears sensitive data:\n\nfunc (h *VaultHandle) Lock() error {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    \n    if h.store == nil {\n        return nil // Already locked\n    }\n    \n    // Close store connection\n    if err := h.store.Close(); err != nil {\n        return fmt.Errorf(\"failed to close store: %w\", err)\n    }\n    \n    // Zero key memory\n    for i := range h.key {\n        h.key[i] = 0\n    }\n    \n    // Clear state\n    h.store = nil\n    h.key = nil\n    h.unlockedAt = time.Time{}\n    \n    return nil\n}\n\nACCEPTANCE:\n- Closes database connection\n- Zeros key memory\n- Clears all sensitive state\n- Returns nil if already locked\n- Thread-safe","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:31:57.7955119-05:00","updated_at":"2025-12-20T02:08:14.6669354-05:00","closed_at":"2025-12-20T02:08:14.6669354-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.3","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:31:57.7993021-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.3","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:56.3923926-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.4","title":"Add VaultHandle.IsExpired method for timeout check","description":"PROBLEM: Need to check if vault unlock has expired.\n\nLOCATION: internal/vault/handle.go\n\nAPPROACH:\nImplement IsExpired method:\n\nconst DefaultTimeout = 15 * time.Minute\n\nfunc (h *VaultHandle) IsExpired(timeout time.Duration) bool {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    \n    if h.store == nil {\n        return true // Locked is considered expired\n    }\n    \n    if timeout \u003c= 0 {\n        timeout = DefaultTimeout\n    }\n    \n    return time.Since(h.unlockedAt) \u003e timeout\n}\n\n// UnlockedAt returns when vault was unlocked\nfunc (h *VaultHandle) UnlockedAt() time.Time {\n    h.mu.RLock()\n    defer h.mu.RUnlock()\n    return h.unlockedAt\n}\n\n// RefreshUnlock resets the unlock timestamp (extends session)\nfunc (h *VaultHandle) RefreshUnlock() {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    if h.store != nil {\n        h.unlockedAt = time.Now()\n    }\n}\n\nACCEPTANCE:\n- IsExpired returns true if timeout exceeded\n- Locked vault returns true (expired)\n- Uses default 15m timeout if not specified\n- RefreshUnlock extends session\n- Thread-safe","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:32:38.4766338-05:00","updated_at":"2025-12-20T02:08:14.6733597-05:00","closed_at":"2025-12-20T02:08:14.6733597-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.4","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:32:38.4797944-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.4","depends_on_id":"keyp-elp.1","type":"blocks","created_at":"2025-12-17T09:02:57.7499191-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.5","title":"Add vault handle unit tests","description":"PROBLEM: VaultHandle needs unit tests.\n\nLOCATION: internal/vault/handle_test.go (create new file)\n\nTEST CASES:\n1. NewHandle:\n   - Creates handle with correct path\n   - Initially locked (IsUnlocked returns false)\n\n2. Unlock:\n   - Returns nil on success\n   - Sets unlock timestamp\n   - IsUnlocked returns true after unlock\n   - Returns nil if already unlocked\n\n3. Lock:\n   - Returns nil on success\n   - IsUnlocked returns false after lock\n   - Returns nil if already locked\n   - Key memory zeroed\n\n4. IsExpired:\n   - Returns true if locked\n   - Returns false immediately after unlock\n   - Returns true after timeout\n   - Respects custom timeout\n\n5. RefreshUnlock:\n   - Resets expiry timer\n\nAPPROACH:\nUse test vault with known password.\nMock time for expiry tests if needed.\n\nACCEPTANCE:\n- go test ./internal/vault/ passes\n- Tests cover all methods\n- Tests verify security (key zeroing)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:33:20.3099971-05:00","updated_at":"2025-12-20T02:28:09.9038496-05:00","closed_at":"2025-12-20T02:28:09.9038496-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:33:20.3137725-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.2","type":"blocks","created_at":"2025-12-17T09:02:59.1078021-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.3","type":"blocks","created_at":"2025-12-17T09:03:00.473616-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.5","depends_on_id":"keyp-elp.4","type":"blocks","created_at":"2025-12-17T09:03:01.845018-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.6","title":"Add cobra unlockCmd with --timeout flag","description":"PROBLEM: Need unlock command for persistent vault session.\n\nLOCATION: cmd/keyp/unlock.go (create new file)\n\nSCOPE: IN-PROCESS ONLY. This command validates the password and prepares VaultHandle for HTTP server mode. Cross-CLI-invocation session persistence is NOT implemented (each CLI invocation is a fresh process). The primary use case is validating credentials before starting the HTTP server.\n\nAPPROACH:\nCreate unlock command that validates password and stores VaultHandle in process:\n\npackage main\n\nimport (\n    \"time\"\n    \"github.com/spf13/cobra\"\n)\n\nvar unlockTimeout string\n\nvar unlockCmd = \u0026cobra.Command{\n    Use:   \"unlock\",\n    Short: \"Unlock the vault\",\n    Long:  \"Unlock the vault and validate credentials. For CLI, each command prompts for password. For HTTP server, use 'keyp serve' which handles sessions.\",\n    RunE:  runUnlock,\n}\n\nfunc init() {\n    unlockCmd.Flags().StringVar(\u0026unlockTimeout, \"timeout\", \"15m\", \"Session timeout (used by HTTP server)\")\n    rootCmd.AddCommand(unlockCmd)\n}\n\nfunc runUnlock(cmd *cobra.Command, args []string) error {\n    // Parse timeout (for future HTTP server use)\n    timeout, err := time.ParseDuration(unlockTimeout)\n    if err != nil {\n        return fmt.Errorf(\"invalid timeout: %w\", err)\n    }\n    \n    // Prompt for password\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return err\n    }\n    \n    // Validate by attempting unlock\n    handle := vault.NewHandle(getVaultPath())\n    if err := handle.Unlock(password); err != nil {\n        return fmt.Errorf(\"failed to unlock vault: %w\", err)\n    }\n    \n    // Store in process-global (for commands in same process)\n    setVaultHandle(handle)\n    \n    fmt.Printf(\"Vault unlocked (timeout: %s)\\n\", timeout)\n    fmt.Println(\"Note: CLI commands prompt for password each invocation. Use 'keyp serve' for persistent sessions.\")\n    return nil\n}\n\nACCEPTANCE:\n- Prompts for password\n- Validates credentials by attempting unlock\n- --timeout flag documented (used by HTTP server)\n- Prints informative message about CLI vs HTTP behavior\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:34:12.6000713-05:00","updated_at":"2025-12-20T02:08:14.6828614-05:00","closed_at":"2025-12-20T02:08:14.6828614-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.6","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:34:12.6032678-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.6","depends_on_id":"keyp-elp.2","type":"blocks","created_at":"2025-12-17T09:03:29.542914-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.7","title":"Add cobra lockCmd","description":"PROBLEM: Need lock command to explicitly lock vault.\n\nLOCATION: cmd/keyp/lock.go (create new file)\n\nSCOPE: IN-PROCESS ONLY. Locks the process-global VaultHandle. For CLI, this is mainly useful for testing or explicitly clearing credentials from memory before the process exits. The HTTP server manages its own session lifecycle.\n\nAPPROACH:\nCreate lock command:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar lockCmd = \u0026cobra.Command{\n    Use:   \"lock\",\n    Short: \"Lock the vault\",\n    Long:  \"Explicitly lock the vault, clearing sensitive data from memory.\",\n    RunE:  runLock,\n}\n\nfunc init() {\n    rootCmd.AddCommand(lockCmd)\n}\n\nfunc runLock(cmd *cobra.Command, args []string) error {\n    handle := getVaultHandle()\n    \n    if handle == nil || !handle.IsUnlocked() {\n        fmt.Println(\"Vault is already locked\")\n        return nil\n    }\n    \n    if err := handle.Lock(); err != nil {\n        return fmt.Errorf(\"failed to lock vault: %w\", err)\n    }\n    \n    // Clear process-global handle\n    clearVaultHandle()\n    \n    fmt.Println(\"Vault locked\")\n    return nil\n}\n\nACCEPTANCE:\n- Calls VaultHandle.Lock\n- Clears process-global handle reference\n- Prints confirmation\n- No error if already locked\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:34:48.9451038-05:00","updated_at":"2025-12-20T02:08:14.689788-05:00","closed_at":"2025-12-20T02:08:14.689788-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.7","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:34:48.9531251-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.7","depends_on_id":"keyp-elp.3","type":"blocks","created_at":"2025-12-17T09:03:31.0202439-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.8","title":"Refactor CLI commands to use stored VaultHandle","description":"PROBLEM: CLI commands should use a shared helper for vault access.\n\nLOCATION: cmd/keyp/*.go (multiple files)\n\nSCOPE: IN-PROCESS ONLY. Since each CLI invocation is a new process, there is no cross-invocation session persistence. The helper simplifies code but still prompts for password on each command.\n\nAPPROACH:\n1. Create shared function to get or unlock vault:\n\n// In cmd/keyp/vault_helper.go\nvar globalHandle *vault.VaultHandle\n\nfunc getOrUnlockVault(cmd *cobra.Command) (*vault.VaultHandle, error) {\n    // Check process-global handle (only useful within same process)\n    if globalHandle != nil \u0026\u0026 globalHandle.IsUnlocked() {\n        return globalHandle, nil\n    }\n    \n    // Need to unlock - prompt for password\n    password, err := ui.PromptPassword(\"Vault password: \")\n    if err != nil {\n        return nil, err\n    }\n    \n    handle := vault.NewHandle(getVaultPath())\n    if err := handle.Unlock(password); err != nil {\n        return nil, fmt.Errorf(\"failed to unlock vault: %w\", err)\n    }\n    \n    globalHandle = handle\n    return handle, nil\n}\n\nfunc setVaultHandle(h *vault.VaultHandle) {\n    globalHandle = h\n}\n\nfunc clearVaultHandle() {\n    globalHandle = nil\n}\n\n2. Update all commands (get, set, list, delete, show, edit, search, tag):\n   - Replace vault.Open() calls with getOrUnlockVault()\n   - Use handle.Store() instead of v.Store()\n   - Remove defer v.Close() (handle manages lifecycle)\n\nACCEPTANCE:\n- Commands use getOrUnlockVault helper\n- Helper prompts for password (no cross-process persistence)\n- All commands still work correctly\n- Code is cleaner and more consistent\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:35:32.2537456-05:00","updated_at":"2025-12-20T02:23:34.4886055-05:00","closed_at":"2025-12-20T02:23:34.4886055-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.8","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:35:32.2622006-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.8","depends_on_id":"keyp-elp.6","type":"blocks","created_at":"2025-12-17T09:03:32.4728044-05:00","created_by":"daemon"}]}
{"id":"keyp-elp.9","title":"Add CLI auto-lock: check expiry before each command","description":"PROBLEM: Need to auto-lock when timeout expires.\n\nLOCATION: cmd/keyp/root.go or cmd/keyp/vault.go\n\nAPPROACH:\nAdd pre-run hook to check expiry and lock if needed:\n\n// In root.go, add PersistentPreRunE\nvar rootCmd = \u0026cobra.Command{\n    Use:   \"keyp\",\n    Short: \"A local-first secret manager\",\n    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n        // Skip for commands that don't need vault\n        if cmd.Name() == \"init\" || cmd.Name() == \"version\" || cmd.Name() == \"help\" {\n            return nil\n        }\n        \n        handle := getVaultHandle()\n        if handle.IsUnlocked() \u0026\u0026 handle.IsExpired(getTimeout()) {\n            // Auto-lock expired session\n            if err := handle.Lock(); err \\!= nil {\n                return fmt.Errorf(\"failed to auto-lock: %w\", err)\n            }\n            // Don't print message - user will be prompted to unlock\n        }\n        \n        return nil\n    },\n}\n\nACCEPTANCE:\n- Checks expiry before each command\n- Auto-locks if expired\n- Doesn't interfere with init/version/help\n- User prompted to unlock on next command","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:36:15.4580328-05:00","updated_at":"2025-12-20T02:23:34.4976031-05:00","closed_at":"2025-12-20T02:23:34.4976031-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp","type":"parent-child","created_at":"2025-12-17T08:36:15.4622541-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp.8","type":"blocks","created_at":"2025-12-17T09:03:33.9432025-05:00","created_by":"daemon"},{"issue_id":"keyp-elp.9","depends_on_id":"keyp-elp.4","type":"blocks","created_at":"2025-12-17T09:03:35.4118516-05:00","created_by":"daemon"}]}
{"id":"keyp-laz","title":"Phase 4: Multi-Field Secrets \u0026 Search","description":"Implement advanced CLI commands for multi-field secrets, display, editing, search, and tags.\n\nComponents:\n1. Interactive Secret Creation:\n   - PromptLoop helper for multi-field input\n   - keyp add \u003cname\u003e: interactive multi-field creation\n\n2. Secret Display \u0026 Editing:\n   - keyp show \u003cname\u003e [--reveal]: display all fields (mask sensitive)\n   - keyp edit \u003cname\u003e [--field]: modify fields\n\n3. Search \u0026 Tags:\n   - keyp search \u003cquery\u003e: FTS5 full-text search\n   - keyp tag add|rm|list: manage tags\n\nDEPENDS: Phase 3 epic (core CLI), Phase 2.5 store.Update and store.Search\n\nACCEPTANCE:\n- All commands functional\n- Integration tests pass\n- Multi-field secrets work correctly\n- Search returns relevant results","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:51:42.6646528-05:00","updated_at":"2025-12-18T15:58:19.8496962-05:00","closed_at":"2025-12-18T15:58:19.8496962-05:00","close_reason":"Completed all Phase 4 tasks - all advanced CLI commands (add, show, edit, search, tag) fully implemented with encryption support","dependencies":[{"issue_id":"keyp-laz","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:50.4655177-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.1","title":"Add PromptLoop helper for multi-field input","description":"PROBLEM: add command needs to prompt for multiple fields until user is done.\n\nLOCATION: internal/ui/prompt.go\n\nAPPROACH:\nAdd helper function that repeatedly prompts for input until empty line or max count:\n\nconst MaxFields = 20\n\ntype FieldInput struct {\n    Label     string\n    Value     string\n    Sensitive bool\n    Type      string\n}\n\nfunc PromptLoop(maxFields int) ([]FieldInput, error) {\n    if maxFields \u003c= 0 {\n        maxFields = MaxFields\n    }\n    \n    var fields []FieldInput\n    \n    for i := 0; i \u003c maxFields; i++ {\n        // Prompt for label\n        label, err := PromptVisible(fmt.Sprintf(\"Field %d label (empty to finish): \", i+1))\n        if err != nil {\n            return nil, err\n        }\n        if label == \"\" {\n            break\n        }\n        \n        // Prompt for type\n        fieldType, err := PromptVisible(\"  Type [text/password/pin/url] (default: text): \")\n        if err != nil {\n            return nil, err\n        }\n        if fieldType == \"\" {\n            fieldType = \"text\"\n        }\n        \n        // Prompt for sensitive\n        sensStr, err := PromptVisible(\"  Sensitive? [y/N]: \")\n        if err != nil {\n            return nil, err\n        }\n        sensitive := strings.ToLower(sensStr) == \"y\" || strings.ToLower(sensStr) == \"yes\"\n        \n        // Prompt for value\n        var value string\n        if sensitive {\n            value, err = PromptPassword(\"  Value: \")\n        } else {\n            value, err = PromptVisible(\"  Value: \")\n        }\n        if err != nil {\n            return nil, err\n        }\n        \n        fields = append(fields, FieldInput{\n            Label:     label,\n            Value:     value,\n            Sensitive: sensitive,\n            Type:      fieldType,\n        })\n    }\n    \n    return fields, nil\n}\n\nACCEPTANCE:\n- Prompts for fields until empty label\n- Collects label, type, sensitive, value for each\n- Respects maxFields limit\n- Uses hidden input for sensitive values\n- go build ./internal/ui/ compiles","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:52:45.9465837-05:00","updated_at":"2025-12-20T01:09:39.0419401-05:00","closed_at":"2025-12-20T01:09:39.0419401-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.1","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T01:52:45.9493904-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.1","depends_on_id":"keyp-2fx.3","type":"blocks","created_at":"2025-12-17T09:00:47.0245382-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.10","title":"Add cobra tagCmd scaffold with add/rm/list subcommands","description":"PROBLEM: Need tag command with subcommands to manage secret tags.\n\nLOCATION: cmd/keyp/tag.go (create new file)\n\nAPPROACH:\n1. Create tag.go with cobra command scaffold\n2. Add subcommands: add, rm, list\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar tagCmd = \u0026cobra.Command{\n    Use:   \"tag\",\n    Short: \"Manage secret tags\",\n    Long:  \"Add, remove, or list tags on secrets.\",\n}\n\nvar tagAddCmd = \u0026cobra.Command{\n    Use:   \"add \u003csecret\u003e \u003ctag\u003e\",\n    Short: \"Add a tag to a secret\",\n    Args:  cobra.ExactArgs(2),\n    RunE:  runTagAdd,\n}\n\nvar tagRmCmd = \u0026cobra.Command{\n    Use:   \"rm \u003csecret\u003e \u003ctag\u003e\",\n    Short: \"Remove a tag from a secret\",\n    Args:  cobra.ExactArgs(2),\n    RunE:  runTagRm,\n}\n\nvar tagListCmd = \u0026cobra.Command{\n    Use:   \"list [secret]\",\n    Short: \"List tags (all or for specific secret)\",\n    Args:  cobra.MaximumNArgs(1),\n    RunE:  runTagList,\n}\n\nfunc init() {\n    tagCmd.AddCommand(tagAddCmd)\n    tagCmd.AddCommand(tagRmCmd)\n    tagCmd.AddCommand(tagListCmd)\n    rootCmd.AddCommand(tagCmd)\n}\n\nACCEPTANCE:\n- keyp tag --help shows subcommands\n- keyp tag add --help shows usage\n- keyp tag rm --help shows usage\n- keyp tag list --help shows usage\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:20:12.7781974-05:00","updated_at":"2025-12-18T15:58:01.3272007-05:00","closed_at":"2025-12-18T15:58:01.3272007-05:00","close_reason":"Implemented tag add/rm/list subcommands with full support for managing secret tags","dependencies":[{"issue_id":"keyp-laz.10","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:20:12.7861603-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.11","title":"Implement tagCmd subcommands for tag management","description":"PROBLEM: tag subcommands need to modify secret.Tags array.\r\n\r\nLOCATION: cmd/keyp/tag.go\r\n\r\nAPPROACH:\r\nImplement all three tag subcommands:\r\n\r\n```go\r\nfunc runTagAdd(cmd *cobra.Command, args []string) error {\r\n    name, tag := args[0], args[1]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Get secret - call directly on Vault, not v.Store()\r\n    secret, err := v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        return fmt.Errorf(\"secret '%s' not found\", name)\r\n    }\r\n\r\n    // Check if tag already exists\r\n    for _, t := range secret.Tags {\r\n        if t == tag {\r\n            return fmt.Errorf(\"tag '%s' already exists on '%s'\", tag, name)\r\n        }\r\n    }\r\n\r\n    secret.Tags = append(secret.Tags, tag)\r\n\r\n    // Update - call directly on Vault, not v.Store()\r\n    if err := v.Update(cmd.Context(), secret); err != nil {\r\n        return err\r\n    }\r\n\r\n    fmt.Printf(\"Added tag '%s' to '%s'\\n\", tag, name)\r\n    return nil\r\n}\r\n\r\nfunc runTagRm(cmd *cobra.Command, args []string) error {\r\n    name, tag := args[0], args[1]\r\n\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    secret, err := v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        return fmt.Errorf(\"secret '%s' not found\", name)\r\n    }\r\n\r\n    // Find and remove tag\r\n    found := false\r\n    newTags := make([]string, 0, len(secret.Tags))\r\n    for _, t := range secret.Tags {\r\n        if t == tag {\r\n            found = true\r\n        } else {\r\n            newTags = append(newTags, t)\r\n        }\r\n    }\r\n\r\n    if !found {\r\n        return fmt.Errorf(\"tag '%s' not found on '%s'\", tag, name)\r\n    }\r\n\r\n    secret.Tags = newTags\r\n    if err := v.Update(cmd.Context(), secret); err != nil {\r\n        return err\r\n    }\r\n\r\n    fmt.Printf(\"Removed tag '%s' from '%s'\\n\", tag, name)\r\n    return nil\r\n}\r\n\r\nfunc runTagList(cmd *cobra.Command, args []string) error {\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    if len(args) \u003e 0 {\r\n        // Show tags for specific secret\r\n        secret, err := v.GetByName(cmd.Context(), args[0])\r\n        if err != nil {\r\n            return fmt.Errorf(\"secret '%s' not found\", args[0])\r\n        }\r\n        if len(secret.Tags) == 0 {\r\n            fmt.Printf(\"Secret '%s' has no tags\\n\", args[0])\r\n        } else {\r\n            fmt.Printf(\"Tags for '%s': %s\\n\", args[0], strings.Join(secret.Tags, \", \"))\r\n        }\r\n    } else {\r\n        // List all unique tags - use v.List with nil options\r\n        secrets, err := v.List(cmd.Context(), nil)\r\n        if err != nil {\r\n            return err\r\n        }\r\n        tagSet := make(map[string]bool)\r\n        for _, s := range secrets {\r\n            for _, t := range s.Tags {\r\n                tagSet[t] = true\r\n            }\r\n        }\r\n        if len(tagSet) == 0 {\r\n            fmt.Println(\"No tags found\")\r\n        } else {\r\n            tags := make([]string, 0, len(tagSet))\r\n            for t := range tagSet {\r\n                tags = append(tags, t)\r\n            }\r\n            sort.Strings(tags)\r\n            fmt.Println(\"All tags:\")\r\n            for _, t := range tags {\r\n                fmt.Printf(\"  %s\\n\", t)\r\n            }\r\n        }\r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE:\r\n- Vault methods are called directly (v.GetByName, v.Update, v.List), not via v.Store()\r\n- v.List(ctx, nil) takes *SearchOptions pointer, pass nil for no filtering\r\n\r\nACCEPTANCE:\r\n- tag add appends tag to secret.Tags\r\n- tag add rejects duplicate tags\r\n- tag rm removes tag from secret.Tags\r\n- tag list shows tags for specific secret\r\n- tag list (no args) shows all unique tags\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:21:07.6373528-05:00","updated_at":"2025-12-20T01:09:39.0789722-05:00","closed_at":"2025-12-20T01:09:39.0789722-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.11","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:21:07.6458323-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.11","depends_on_id":"keyp-laz.10","type":"blocks","created_at":"2025-12-17T09:01:25.4355434-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.12","title":"Add Phase 4 integration tests","description":"PROBLEM: Phase 4 commands need integration tests.\n\nLOCATION: cmd/keyp/cli_test.go (add to existing)\n\nTEST SCENARIOS:\n1. Add workflow:\n   - keyp add creates multi-field secret\n   - Requires at least one field\n   - Rejects duplicate names\n\n2. Show workflow:\n   - keyp show displays all fields\n   - Sensitive fields masked by default\n   - --reveal shows actual values\n\n3. Edit workflow:\n   - keyp edit modifies field values\n   - --field targets specific field\n   - Empty input preserves value\n\n4. Search workflow:\n   - keyp search finds by name\n   - keyp search finds by tag\n   - No results shows message\n\n5. Tag workflow:\n   - keyp tag add adds tag\n   - keyp tag rm removes tag\n   - keyp tag list shows tags\n\nAPPROACH:\nExtend existing cli_test.go with new test cases.\nUse test vault from Phase 3 tests.\n\nACCEPTANCE:\n- go test ./cmd/keyp/ passes\n- Tests cover Phase 4 commands\n- Tests are independent (can run in any order)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:21:50.2737891-05:00","updated_at":"2025-12-20T01:20:25.8499338-05:00","closed_at":"2025-12-20T01:20:25.8499338-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:21:50.2817433-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.3","type":"blocks","created_at":"2025-12-17T09:01:26.8794201-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.5","type":"blocks","created_at":"2025-12-17T09:01:28.3256598-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.7","type":"blocks","created_at":"2025-12-17T09:01:29.7935864-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.9","type":"blocks","created_at":"2025-12-17T09:01:31.2809868-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.12","depends_on_id":"keyp-laz.11","type":"blocks","created_at":"2025-12-17T09:01:32.737488-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.2","title":"Add cobra addCmd scaffold for interactive multi-field creation","description":"PROBLEM: Need add command for creating secrets with multiple fields interactively.\n\nLOCATION: cmd/keyp/add.go (create new file)\n\nAPPROACH:\n1. Create add.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar addCmd = \u0026cobra.Command{\n    Use:   \"add \u003cname\u003e\",\n    Short: \"Add a new secret with multiple fields\",\n    Long:  \"Create a new secret with interactive prompts for multiple fields.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runAdd,\n}\n\nfunc init() {\n    rootCmd.AddCommand(addCmd)\n}\n\nfunc runAdd(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp add --help shows usage\n- Args validation works (exactly 1 arg)\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:13:07.3526239-05:00","updated_at":"2025-12-18T15:56:52.1425817-05:00","closed_at":"2025-12-18T15:56:52.1425817-05:00","close_reason":"Implemented runAdd with interactive multi-field creation using PromptLoop helper","dependencies":[{"issue_id":"keyp-laz.2","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:13:07.3555759-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.3","title":"Implement addCmd.RunE with PromptLoop for multi-field secrets","description":"PROBLEM: add command needs to create secrets with multiple fields.\r\n\r\nLOCATION: cmd/keyp/add.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Use PromptLoop to collect fields\r\n3. Create SecretObject with all fields\r\n4. Save to store\r\n\r\n```go\r\nfunc runAdd(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Check if exists - call directly on Vault, not v.Store()\r\n    _, err = v.GetByName(cmd.Context(), name)\r\n    if err == nil {\r\n        return fmt.Errorf(\"secret '%s' already exists (use 'edit' to modify)\", name)\r\n    }\r\n\r\n    fmt.Printf(\"Creating secret '%s'\\n\", name)\r\n    fmt.Println(\"Enter fields (empty label to finish):\")\r\n\r\n    // Collect fields via PromptLoop\r\n    fieldInputs, err := ui.PromptLoop(0)\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    if len(fieldInputs) == 0 {\r\n        return fmt.Errorf(\"at least one field required\")\r\n    }\r\n\r\n    // Create secret - use NewSecretObject (not NewSecret)\r\n    secret := model.NewSecretObject(name)\r\n\r\n    // AddField takes a Field struct, not individual params\r\n    for _, f := range fieldInputs {\r\n        field := model.NewField(f.Label, f.Value)\r\n        field.Sensitive = f.Sensitive\r\n        field.Type = f.Type\r\n        secret.AddField(field)\r\n    }\r\n\r\n    // Create - call directly on Vault, not v.Store()\r\n    if err := v.Create(cmd.Context(), secret); err != nil {\r\n        return fmt.Errorf(\"failed to create secret: %w\", err)\r\n    }\r\n\r\n    fmt.Printf(\"Secret '%s' created with %d fields\\n\", name, len(fieldInputs))\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE:\r\n- Vault methods are called directly (v.GetByName, v.Create), not via v.Store()\r\n- Use model.NewSecretObject(name), not model.NewSecret(name)\r\n- AddField(field Field) takes a Field struct parameter, not individual values\r\n- Use model.NewField(label, value) to create Field, then set Sensitive and Type\r\n\r\nACCEPTANCE:\r\n- Creates multi-field secrets interactively\r\n- Requires at least one field\r\n- Rejects duplicate names\r\n- Shows field count on success\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:14:13.0126999-05:00","updated_at":"2025-12-20T01:09:39.0493542-05:00","closed_at":"2025-12-20T01:09:39.0493542-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:14:13.0164305-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz.2","type":"blocks","created_at":"2025-12-17T09:00:48.4335535-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.3","depends_on_id":"keyp-laz.1","type":"blocks","created_at":"2025-12-17T09:00:49.8383852-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.4","title":"Add cobra showCmd scaffold with --reveal flag","description":"PROBLEM: Need show command to display all fields of a secret.\n\nLOCATION: cmd/keyp/show.go (create new file)\n\nAPPROACH:\n1. Create show.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --reveal flag to show sensitive values\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar showReveal bool\n\nvar showCmd = \u0026cobra.Command{\n    Use:   \"show \u003cname\u003e\",\n    Short: \"Show secret details\",\n    Long:  \"Display all fields of a secret. Sensitive values are masked unless --reveal is used.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runShow,\n}\n\nfunc init() {\n    showCmd.Flags().BoolVar(\u0026showReveal, \"reveal\", false, \"Show sensitive values (default: masked)\")\n    rootCmd.AddCommand(showCmd)\n}\n\nfunc runShow(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp show --help shows usage\n- Args validation works (exactly 1 arg)\n- --reveal flag documented\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:14:54.2563816-05:00","updated_at":"2025-12-18T15:57:09.2726024-05:00","closed_at":"2025-12-18T15:57:09.2726024-05:00","close_reason":"Implemented runShow with field masking controlled by --reveal flag","dependencies":[{"issue_id":"keyp-laz.4","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:14:54.259061-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.5","title":"Implement showCmd.RunE with field display","description":"PROBLEM: show command needs to display all secret fields.\r\n\r\nLOCATION: cmd/keyp/show.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Get secret by name\r\n3. Display all fields, masking sensitive unless --reveal\r\n\r\n```go\r\nfunc runShow(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Get secret - call directly on Vault, not v.Store()\r\n    secret, err := v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        if errors.Is(err, store.ErrNotFound) {\r\n            return fmt.Errorf(\"secret '%s' not found\", name)\r\n        }\r\n        return fmt.Errorf(\"failed to get secret: %w\", err)\r\n    }\r\n\r\n    // Use redacted unless --reveal\r\n    display := secret\r\n    if !showReveal {\r\n        display = secret.Redacted()\r\n    }\r\n\r\n    // Display header\r\n    fmt.Printf(\"Name: %s\\n\", display.Name)\r\n    if len(display.Tags) \u003e 0 {\r\n        fmt.Printf(\"Tags: %s\\n\", strings.Join(display.Tags, \", \"))\r\n    }\r\n    fmt.Printf(\"Created: %s\\n\", display.CreatedAt.Format(time.RFC3339))\r\n    fmt.Printf(\"Updated: %s\\n\", display.UpdatedAt.Format(time.RFC3339))\r\n\r\n    // Display fields\r\n    fmt.Println(\"\\nFields:\")\r\n    for i, f := range display.Fields {\r\n        sensIndicator := \"\"\r\n        if f.Sensitive {\r\n            sensIndicator = \" [sensitive]\"\r\n        }\r\n        fmt.Printf(\"  %d. %s (%s)%s: %s\\n\", i+1, f.Label, f.Type, sensIndicator, f.Value)\r\n    }\r\n\r\n    if display.Notes != \"\" {\r\n        fmt.Printf(\"\\nNotes:\\n%s\\n\", display.Notes)\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: Vault methods are called directly (v.GetByName), not via v.Store().\r\n\r\nACCEPTANCE:\r\n- Shows all secret metadata\r\n- Displays fields with labels and types\r\n- Masks sensitive values by default\r\n- --reveal shows actual values\r\n- Shows notes if present\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:16:00.5883855-05:00","updated_at":"2025-12-20T01:09:39.0568092-05:00","closed_at":"2025-12-20T01:09:39.0568092-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.5","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:16:00.5921014-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.5","depends_on_id":"keyp-laz.4","type":"blocks","created_at":"2025-12-17T09:00:51.2412371-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.6","title":"Add cobra editCmd scaffold with --field flag","description":"PROBLEM: Need edit command to modify existing secrets.\n\nLOCATION: cmd/keyp/edit.go (create new file)\n\nAPPROACH:\n1. Create edit.go with cobra command scaffold\n2. Args: \u003cname\u003e - required\n3. Add --field flag to target specific field\n4. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar editField string\n\nvar editCmd = \u0026cobra.Command{\n    Use:   \"edit \u003cname\u003e\",\n    Short: \"Edit an existing secret\",\n    Long:  \"Modify fields of an existing secret. Use --field to target a specific field.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runEdit,\n}\n\nfunc init() {\n    editCmd.Flags().StringVar(\u0026editField, \"field\", \"\", \"Specific field to edit (by label)\")\n    rootCmd.AddCommand(editCmd)\n}\n\nfunc runEdit(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp edit --help shows usage\n- Args validation works (exactly 1 arg)\n- --field flag documented\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:16:42.0215277-05:00","updated_at":"2025-12-18T15:57:26.3459901-05:00","closed_at":"2025-12-18T15:57:26.3459901-05:00","close_reason":"Implemented runEdit with support for editing all fields or specific field via --field flag","dependencies":[{"issue_id":"keyp-laz.6","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:16:42.0241515-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.7","title":"Implement editCmd.RunE with store.Update","description":"PROBLEM: edit command needs to modify secrets using store.Update.\r\n\r\nLOCATION: cmd/keyp/edit.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Get existing secret\r\n3. If --field, edit just that field; otherwise show menu\r\n4. Call Update with modified secret\r\n\r\n```go\r\nfunc runEdit(cmd *cobra.Command, args []string) error {\r\n    name := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Get secret - call directly on Vault, not v.Store()\r\n    secret, err := v.GetByName(cmd.Context(), name)\r\n    if err != nil {\r\n        if errors.Is(err, store.ErrNotFound) {\r\n            return fmt.Errorf(\"secret '%s' not found\", name)\r\n        }\r\n        return fmt.Errorf(\"failed to get secret: %w\", err)\r\n    }\r\n\r\n    // Show current state\r\n    fmt.Printf(\"Editing '%s'\\n\", name)\r\n\r\n    if editField != \"\" {\r\n        // Edit specific field\r\n        idx := -1\r\n        for i, f := range secret.Fields {\r\n            if f.Label == editField {\r\n                idx = i\r\n                break\r\n            }\r\n        }\r\n        if idx == -1 {\r\n            return fmt.Errorf(\"field '%s' not found\", editField)\r\n        }\r\n\r\n        f := \u0026secret.Fields[idx]\r\n        var newValue string\r\n        if f.Sensitive {\r\n            newValue, err = ui.PromptPassword(fmt.Sprintf(\"New value for '%s': \", f.Label))\r\n        } else {\r\n            newValue, err = ui.PromptVisible(fmt.Sprintf(\"New value for '%s': \", f.Label))\r\n        }\r\n        if err != nil {\r\n            return err\r\n        }\r\n        f.Value = newValue\r\n    } else {\r\n        // Interactive edit - prompt for each field\r\n        for i := range secret.Fields {\r\n            f := \u0026secret.Fields[i]\r\n            fmt.Printf(\"\\nField: %s (current: %s)\\n\", f.Label, maskIfSensitive(f))\r\n\r\n            var newValue string\r\n            if f.Sensitive {\r\n                newValue, err = ui.PromptPassword(\"  New value (empty to keep): \")\r\n            } else {\r\n                newValue, err = ui.PromptVisible(\"  New value (empty to keep): \")\r\n            }\r\n            if err != nil {\r\n                return err\r\n            }\r\n            if newValue != \"\" {\r\n                f.Value = newValue\r\n            }\r\n        }\r\n    }\r\n\r\n    // Update - call directly on Vault, not v.Store()\r\n    if err := v.Update(cmd.Context(), secret); err != nil {\r\n        return fmt.Errorf(\"failed to update secret: %w\", err)\r\n    }\r\n\r\n    fmt.Printf(\"Secret '%s' updated\\n\", name)\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE: Vault methods are called directly on the Vault instance (v.GetByName, v.Update), not via v.Store().\r\n\r\nACCEPTANCE:\r\n- Edits specific field with --field\r\n- Interactive edit prompts for each field without --field\r\n- Empty input keeps existing value\r\n- Uses v.Update to save changes\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:18:06.1261221-05:00","updated_at":"2025-12-20T01:09:39.0631272-05:00","closed_at":"2025-12-20T01:09:39.0631272-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:18:06.1302615-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz.6","type":"blocks","created_at":"2025-12-17T09:00:52.6633133-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-laz.5","type":"blocks","created_at":"2025-12-17T09:00:54.1403571-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.7","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T09:00:55.5503164-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.8","title":"Add cobra searchCmd scaffold using FTS5","description":"PROBLEM: Need search command for full-text search.\n\nLOCATION: cmd/keyp/search.go (create new file)\n\nAPPROACH:\n1. Create search.go with cobra command scaffold\n2. Args: \u003cquery\u003e - required\n3. Register with root command\n\nCODE STRUCTURE:\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar searchCmd = \u0026cobra.Command{\n    Use:   \"search \u003cquery\u003e\",\n    Short: \"Search secrets\",\n    Long:  \"Full-text search across secret names, tags, and notes.\",\n    Args:  cobra.ExactArgs(1),\n    RunE:  runSearch,\n}\n\nfunc init() {\n    rootCmd.AddCommand(searchCmd)\n}\n\nfunc runSearch(cmd *cobra.Command, args []string) error {\n    // TODO: implement in next task\n    return nil\n}\n\nACCEPTANCE:\n- keyp search --help shows usage\n- Args validation works (exactly 1 arg)\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:18:40.6463336-05:00","updated_at":"2025-12-18T15:57:44.7323869-05:00","closed_at":"2025-12-18T15:57:44.7323869-05:00","close_reason":"Implemented runSearch with FTS5 full-text search across secret names, tags, and notes","dependencies":[{"issue_id":"keyp-laz.8","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:18:40.6547949-05:00","created_by":"daemon"}]}
{"id":"keyp-laz.9","title":"Implement searchCmd.RunE with store.Search","description":"PROBLEM: search command needs to query FTS5 via store.Search.\r\n\r\nLOCATION: cmd/keyp/search.go\r\n\r\nAPPROACH:\r\n1. Open vault (no password in current implementation)\r\n2. Call Search with query and nil SearchOptions\r\n3. Display matching secrets\r\n\r\n```go\r\nfunc runSearch(cmd *cobra.Command, args []string) error {\r\n    query := args[0]\r\n\r\n    // Open vault (current API takes path only, no password)\r\n    v, err := vault.Open(getVaultPath())\r\n    if err != nil {\r\n        return fmt.Errorf(\"failed to open vault: %w\", err)\r\n    }\r\n    defer v.Close()\r\n\r\n    // Search - call directly on Vault, not v.Store()\r\n    // NOTE: Search takes *SearchOptions (pointer), pass nil for no filtering\r\n    results, err := v.Search(cmd.Context(), query, nil)\r\n    if err != nil {\r\n        return fmt.Errorf(\"search failed: %w\", err)\r\n    }\r\n\r\n    if len(results) == 0 {\r\n        fmt.Printf(\"No secrets matching '%s'\\n\", query)\r\n        return nil\r\n    }\r\n\r\n    fmt.Printf(\"Found %d secrets matching '%s':\\n\\n\", len(results), query)\r\n\r\n    for _, s := range results {\r\n        fmt.Printf(\"  %s\", s.Name)\r\n        if len(s.Tags) \u003e 0 {\r\n            fmt.Printf(\" [%s]\", strings.Join(s.Tags, \", \"))\r\n        }\r\n        fmt.Println()\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNOTE:\r\n- Vault methods are called directly (v.Search), not via v.Store()\r\n- Search() signature: Search(ctx context.Context, query string, opts *SearchOptions)\r\n- SearchOptions is a pointer type - pass nil for no tag filtering/limit, or \u0026store.SearchOptions{...} for filtering\r\n\r\nACCEPTANCE:\r\n- Searches name, tags, notes via FTS5\r\n- Shows matching secret names and tags\r\n- Shows count of results\r\n- No matches shows appropriate message\r\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:19:29.2487384-05:00","updated_at":"2025-12-20T01:09:39.0731916-05:00","closed_at":"2025-12-20T01:09:39.0731916-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-laz.9","depends_on_id":"keyp-laz","type":"parent-child","created_at":"2025-12-17T08:19:29.2519189-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.9","depends_on_id":"keyp-laz.8","type":"blocks","created_at":"2025-12-17T09:01:22.5169298-05:00","created_by":"daemon"},{"issue_id":"keyp-laz.9","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T09:01:23.9685646-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz","title":"Phase 5: Git Sync","description":"Implement git-based sync for vault data using exec.Command.\r\n\r\nComponents:\r\n1. GitExecSyncer implementing Syncer interface (defined in internal/sync/sync.go)\r\n2. Git operations: init, add-remote, commit, push, pull, status\r\n3. CLI commands: keyp sync init/push/pull/status\r\n\r\nNOTE: The Syncer interface already exists in internal/sync/sync.go with methods:\r\n- Init() error\r\n- AddRemote(url string) error\r\n- Commit(message string) error\r\n- Push() error\r\n- Pull() error\r\n- Status() (*SyncStatus, error)\r\n\r\nA NoopSyncer placeholder implementation exists in internal/sync/noop.go.\r\nGitExecSyncer should implement this interface using exec.Command to call git.\r\n\r\nDEPENDS: Phase 3 epic (core CLI)\r\n\r\nACCEPTANCE:\r\n- GitExecSyncer implements Syncer interface\r\n- sync commands work with git repositories\r\n- Integration tests pass (requires git installed)\r\n","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T08:22:28.559086-05:00","updated_at":"2025-12-20T01:55:39.0124686-05:00","closed_at":"2025-12-20T01:55:39.0124686-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz","depends_on_id":"keyp-2fx","type":"blocks","created_at":"2025-12-17T09:07:51.8154526-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.1","title":"Implement GitExecSyncer using exec.Command","description":"PROBLEM: Need git sync implementation using exec.Command.\n\nLOCATION: internal/sync/gitexec.go (create new file)\n\nAPPROACH:\nCreate GitExecSyncer struct that wraps git CLI commands:\n\npackage sync\n\nimport (\n    \"os/exec\"\n    \"path/filepath\"\n)\n\ntype GitExecSyncer struct {\n    vaultPath string\n}\n\nfunc NewGitExecSyncer(vaultPath string) *GitExecSyncer {\n    return \u0026GitExecSyncer{vaultPath: vaultPath}\n}\n\n// Helper to run git commands in vault directory\nfunc (g *GitExecSyncer) git(args ...string) (string, error) {\n    cmd := exec.Command(\"git\", args...)\n    cmd.Dir = g.vaultPath\n    output, err := cmd.CombinedOutput()\n    return string(output), err\n}\n\n// Verify it implements Syncer interface\nvar _ Syncer = (*GitExecSyncer)(nil)\n\nACCEPTANCE:\n- GitExecSyncer struct created\n- Helper git() method works\n- Implements Syncer interface\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:23:04.9414371-05:00","updated_at":"2025-12-18T16:06:01.6473305-05:00","closed_at":"2025-12-18T16:06:01.6473305-05:00","close_reason":"Implemented GitExecSyncer with all Syncer interface methods using exec.Command to call git","dependencies":[{"issue_id":"keyp-mrz.1","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:23:04.9494857-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.2","title":"Add GitExecSyncer.Init for git init and .gitignore","description":"PROBLEM: Need to initialize git repository in vault directory.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Init method:\n\nfunc (g *GitExecSyncer) Init() error {\n    // Run git init\n    if _, err := g.git(\"init\"); err != nil {\n        return fmt.Errorf(\"git init failed: %w\", err)\n    }\n    \n    // Create .gitignore to exclude database file\n    gitignore := filepath.Join(g.vaultPath, \".gitignore\")\n    content := []byte(\"# Exclude SQLite database (encrypted data is in exported files)\\n*.db\\n*.db-journal\\n*.db-wal\\n*.db-shm\\n\")\n    if err := os.WriteFile(gitignore, content, 0644); err != nil {\n        return fmt.Errorf(\"failed to create .gitignore: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Creates .git directory in vault path\n- Creates .gitignore excluding *.db files\n- Returns error if git not installed\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:23:44.3607305-05:00","updated_at":"2025-12-20T01:55:19.7589485-05:00","closed_at":"2025-12-20T01:55:19.7589485-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.2","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:23:44.3644288-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.2","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:54.3093841-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.3","title":"Add GitExecSyncer.AddRemote for git remote add","description":"PROBLEM: Need to add remote repository for push/pull.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement AddRemote method:\n\nfunc (g *GitExecSyncer) AddRemote(name, url string) error {\n    if name == \"\" {\n        name = \"origin\"\n    }\n    \n    if _, err := g.git(\"remote\", \"add\", name, url); err != nil {\n        return fmt.Errorf(\"git remote add failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (g *GitExecSyncer) RemoveRemote(name string) error {\n    if _, err := g.git(\"remote\", \"remove\", name); err != nil {\n        return fmt.Errorf(\"git remote remove failed: %w\", err)\n    }\n    return nil\n}\n\nfunc (g *GitExecSyncer) GetRemoteURL(name string) (string, error) {\n    output, err := g.git(\"remote\", \"get-url\", name)\n    if err != nil {\n        return \"\", fmt.Errorf(\"git remote get-url failed: %w\", err)\n    }\n    return strings.TrimSpace(output), nil\n}\n\nACCEPTANCE:\n- AddRemote adds named remote\n- Defaults to 'origin' if name empty\n- RemoveRemote removes remote\n- GetRemoteURL returns remote URL\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:24:32.39602-05:00","updated_at":"2025-12-20T01:55:19.7682517-05:00","closed_at":"2025-12-20T01:55:19.7682517-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.3","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:24:32.4039886-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.3","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:55.6260973-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.4","title":"Add GitExecSyncer.Commit for git add and commit","description":"PROBLEM: Need to commit changes to local repository.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Commit method:\n\nfunc (g *GitExecSyncer) Commit(message string) error {\n    // Stage all changes\n    if _, err := g.git(\"add\", \".\"); err != nil {\n        return fmt.Errorf(\"git add failed: %w\", err)\n    }\n    \n    // Check if there are changes to commit\n    output, _ := g.git(\"status\", \"--porcelain\")\n    if strings.TrimSpace(output) == \"\" {\n        return nil // Nothing to commit\n    }\n    \n    // Commit\n    if message == \"\" {\n        message = \"keyp: sync vault\"\n    }\n    if _, err := g.git(\"commit\", \"-m\", message); err != nil {\n        return fmt.Errorf(\"git commit failed: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Stages all changes with git add .\n- Commits with provided message\n- Uses default message if empty\n- Returns nil if nothing to commit\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:25:14.0839693-05:00","updated_at":"2025-12-20T01:55:19.775417-05:00","closed_at":"2025-12-20T01:55:19.775417-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.4","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:25:14.0877165-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.4","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:56.9514091-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.5","title":"Add GitExecSyncer.Push and Pull methods","description":"PROBLEM: Need to sync with remote repository.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Push and Pull methods:\n\nfunc (g *GitExecSyncer) Push(remote, branch string) error {\n    if remote == \"\" {\n        remote = \"origin\"\n    }\n    if branch == \"\" {\n        branch = \"main\"\n    }\n    \n    if _, err := g.git(\"push\", remote, branch); err != nil {\n        return fmt.Errorf(\"git push failed: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (g *GitExecSyncer) Pull(remote, branch string) error {\n    if remote == \"\" {\n        remote = \"origin\"\n    }\n    if branch == \"\" {\n        branch = \"main\"\n    }\n    \n    if _, err := g.git(\"pull\", remote, branch); err != nil {\n        return fmt.Errorf(\"git pull failed: %w\", err)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- Push sends commits to remote\n- Pull fetches and merges from remote\n- Defaults to origin/main\n- Returns descriptive errors\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:25:57.6473165-05:00","updated_at":"2025-12-20T01:55:19.7864231-05:00","closed_at":"2025-12-20T01:55:19.7864231-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.5","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:25:57.6511177-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.5","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:58.2561954-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.6","title":"Add GitExecSyncer.Status for repository state","description":"PROBLEM: Need to check git repository status.\n\nLOCATION: internal/sync/gitexec.go\n\nAPPROACH:\nImplement Status method that parses git status output:\n\ntype SyncStatus struct {\n    IsRepo      bool\n    HasChanges  bool\n    Branch      string\n    Ahead       int\n    Behind      int\n    Remote      string\n}\n\nfunc (g *GitExecSyncer) Status() (*SyncStatus, error) {\n    status := \u0026SyncStatus{}\n    \n    // Check if it's a git repo\n    if _, err := os.Stat(filepath.Join(g.vaultPath, \".git\")); os.IsNotExist(err) {\n        return status, nil\n    }\n    status.IsRepo = true\n    \n    // Get current branch\n    output, err := g.git(\"branch\", \"--show-current\")\n    if err == nil {\n        status.Branch = strings.TrimSpace(output)\n    }\n    \n    // Check for uncommitted changes\n    output, _ = g.git(\"status\", \"--porcelain\")\n    status.HasChanges = strings.TrimSpace(output) != \"\"\n    \n    // Check ahead/behind\n    output, err = g.git(\"rev-list\", \"--left-right\", \"--count\", \"@{upstream}...HEAD\")\n    if err == nil {\n        parts := strings.Fields(output)\n        if len(parts) == 2 {\n            status.Behind, _ = strconv.Atoi(parts[0])\n            status.Ahead, _ = strconv.Atoi(parts[1])\n        }\n    }\n    \n    // Get remote URL\n    status.Remote, _ = g.GetRemoteURL(\"origin\")\n    \n    return status, nil\n}\n\nACCEPTANCE:\n- Returns SyncStatus with repo state\n- Detects uncommitted changes\n- Shows ahead/behind counts\n- Works even if no upstream set\n- go build ./internal/sync/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:26:49.6120632-05:00","updated_at":"2025-12-20T01:55:19.7951842-05:00","closed_at":"2025-12-20T01:55:19.7951842-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.6","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:26:49.6158593-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.6","depends_on_id":"keyp-mrz.1","type":"blocks","created_at":"2025-12-17T09:01:59.5649665-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.7","title":"Add cobra syncCmd scaffold with init/push/pull/status subcommands","description":"PROBLEM: Need sync command with subcommands for git operations.\n\nLOCATION: cmd/keyp/sync.go (create new file)\n\nAPPROACH:\nCreate sync.go with cobra command and subcommands:\n\npackage main\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar syncCmd = \u0026cobra.Command{\n    Use:   \"sync\",\n    Short: \"Sync vault with git\",\n    Long:  \"Initialize, push, pull, or check status of vault git repository.\",\n}\n\nvar syncInitCmd = \u0026cobra.Command{\n    Use:   \"init [remote-url]\",\n    Short: \"Initialize git sync\",\n    Args:  cobra.MaximumNArgs(1),\n    RunE:  runSyncInit,\n}\n\nvar syncPushCmd = \u0026cobra.Command{\n    Use:   \"push\",\n    Short: \"Push vault to remote\",\n    RunE:  runSyncPush,\n}\n\nvar syncPullCmd = \u0026cobra.Command{\n    Use:   \"pull\",\n    Short: \"Pull vault from remote\",\n    RunE:  runSyncPull,\n}\n\nvar syncStatusCmd = \u0026cobra.Command{\n    Use:   \"status\",\n    Short: \"Show sync status\",\n    RunE:  runSyncStatus,\n}\n\nfunc init() {\n    syncCmd.AddCommand(syncInitCmd)\n    syncCmd.AddCommand(syncPushCmd)\n    syncCmd.AddCommand(syncPullCmd)\n    syncCmd.AddCommand(syncStatusCmd)\n    rootCmd.AddCommand(syncCmd)\n}\n\nACCEPTANCE:\n- keyp sync --help shows subcommands\n- All subcommand --help shows usage\n- go build ./cmd/keyp/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:27:31.6576474-05:00","updated_at":"2025-12-18T16:06:17.4554674-05:00","closed_at":"2025-12-18T16:06:17.4554674-05:00","close_reason":"Implemented sync command with init/push/pull/status subcommands for git-based vault synchronization","dependencies":[{"issue_id":"keyp-mrz.7","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:27:31.6625665-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.8","title":"Wire syncCmd subcommands to GitExecSyncer methods","description":"PROBLEM: sync subcommands need to call GitExecSyncer methods.\n\nLOCATION: cmd/keyp/sync.go\n\nAPPROACH:\nImplement all subcommand RunE functions:\n\nfunc runSyncInit(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    if err := syncer.Init(); err != nil {\n        return err\n    }\n    \n    if len(args) \u003e 0 {\n        if err := syncer.AddRemote(\"origin\", args[0]); err != nil {\n            return err\n        }\n        fmt.Printf(\"Git sync initialized with remote: %s\\n\", args[0])\n    } else {\n        fmt.Println(\"Git sync initialized (no remote configured)\")\n    }\n    \n    return nil\n}\n\nfunc runSyncPush(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    // Commit any pending changes\n    if err := syncer.Commit(\"\"); err != nil {\n        return err\n    }\n    \n    if err := syncer.Push(\"\", \"\"); err != nil {\n        return err\n    }\n    \n    fmt.Println(\"Vault pushed to remote\")\n    return nil\n}\n\nfunc runSyncPull(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    if err := syncer.Pull(\"\", \"\"); err != nil {\n        return err\n    }\n    \n    fmt.Println(\"Vault pulled from remote\")\n    return nil\n}\n\nfunc runSyncStatus(cmd *cobra.Command, args []string) error {\n    syncer := sync.NewGitExecSyncer(getVaultPath())\n    \n    status, err := syncer.Status()\n    if err != nil {\n        return err\n    }\n    \n    if !status.IsRepo {\n        fmt.Println(\"Not initialized (run 'keyp sync init')\")\n        return nil\n    }\n    \n    fmt.Printf(\"Branch: %s\\n\", status.Branch)\n    if status.Remote != \"\" {\n        fmt.Printf(\"Remote: %s\\n\", status.Remote)\n    }\n    if status.HasChanges {\n        fmt.Println(\"Status: Uncommitted changes\")\n    }\n    if status.Ahead \u003e 0 {\n        fmt.Printf(\"Ahead: %d commits\\n\", status.Ahead)\n    }\n    if status.Behind \u003e 0 {\n        fmt.Printf(\"Behind: %d commits\\n\", status.Behind)\n    }\n    \n    return nil\n}\n\nACCEPTANCE:\n- sync init creates repo and optionally adds remote\n- sync push commits and pushes\n- sync pull fetches and merges\n- sync status shows repo state\n- All commands print appropriate messages","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T08:28:38.9700527-05:00","updated_at":"2025-12-20T01:55:19.8020921-05:00","closed_at":"2025-12-20T01:55:19.8020921-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:28:38.9732184-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.7","type":"blocks","created_at":"2025-12-17T09:02:23.3082077-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.2","type":"blocks","created_at":"2025-12-17T09:02:24.7160624-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.3","type":"blocks","created_at":"2025-12-17T09:02:26.1237082-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.4","type":"blocks","created_at":"2025-12-17T09:02:27.5341322-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.5","type":"blocks","created_at":"2025-12-17T09:02:28.9478339-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.8","depends_on_id":"keyp-mrz.6","type":"blocks","created_at":"2025-12-17T09:02:30.3577768-05:00","created_by":"daemon"}]}
{"id":"keyp-mrz.9","title":"Add git sync integration tests","description":"PROBLEM: Git sync commands need integration tests.\n\nLOCATION: internal/sync/sync_test.go (create new file)\n\nTEST SCENARIOS:\n1. Init:\n   - Creates .git directory\n   - Creates .gitignore with *.db\n\n2. AddRemote:\n   - Adds remote to repository\n   - GetRemoteURL returns correct URL\n\n3. Commit:\n   - Stages and commits changes\n   - No-op if nothing to commit\n\n4. Push/Pull:\n   - Requires remote repository (may skip in CI)\n\n5. Status:\n   - Returns correct branch name\n   - Detects uncommitted changes\n   - Shows ahead/behind counts\n\nAPPROACH:\nUse temp directories for test repositories.\nSome tests may need to be skipped if git not installed.\n\nACCEPTANCE:\n- go test ./internal/sync/ passes\n- Tests work in local environment\n- Gracefully skip if git not available","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T08:29:16.7019783-05:00","updated_at":"2025-12-20T01:55:19.8086018-05:00","closed_at":"2025-12-20T01:55:19.8086018-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-mrz.9","depends_on_id":"keyp-mrz","type":"parent-child","created_at":"2025-12-17T08:29:16.7057616-05:00","created_by":"daemon"},{"issue_id":"keyp-mrz.9","depends_on_id":"keyp-mrz.8","type":"blocks","created_at":"2025-12-17T09:02:31.7709689-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk","title":"Phase 2.5: Storage Layer Gaps","description":"Address missing storage layer components required by later phases. Phase 2 (SQLite/SQLCipher storage) must be complete before starting.\n\nComponents needed:\n- store.Update method for modifying existing secrets (needed by P4 edit, P7 PUT)\n- store.Search method with FTS5 query support (needed by P4 search, P7 GET /search)\n- FTS5 virtual table verification in schema migration\n- Domain error types: ErrNotFound, ErrAlreadyExists, ErrInvalidPassword\n- JSON tags on SecretObject and Field types for API serialization\n- SecretObject.Redacted() method for masking sensitive values\n- Comprehensive unit tests for store package\n\nACCEPTANCE:\n- All store methods compile and pass unit tests\n- Error types properly defined and used\n- JSON serialization works for API responses\n- bd ready --json returns empty when complete","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-17T01:33:16.4984742-05:00","updated_at":"2025-12-18T14:20:29.1518579-05:00","closed_at":"2025-12-18T14:20:29.1518579-05:00","close_reason":"Closed"}
{"id":"keyp-nlk.1","title":"Add store.Update method for modifying existing secrets","description":"PROBLEM: Phase 4 edit command and Phase 7 PUT endpoint need to modify existing secrets, but store only has Create/Get/Delete.\n\nLOCATION: internal/store/store.go\n\nAPPROACH:\n1. Add Update method to Store interface and SQLiteStore implementation\n2. Accept secret ID and updated SecretObject\n3. Update secrets table (name, tags, notes, updated_at)\n4. Replace all fields for that secret (delete old, insert new with correct sort_order)\n5. Update FTS index via triggers or manual sync\n6. Return ErrNotFound if secret doesn't exist\n\nSIGNATURE:\nfunc (s *SQLiteStore) Update(ctx context.Context, secret *model.SecretObject) error\n\nACCEPTANCE:\n- Update method compiles\n- Modifying name/tags/notes works\n- Adding/removing/reordering fields works\n- FTS index reflects changes\n- Returns ErrNotFound for non-existent secret","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:33:53.6066799-05:00","updated_at":"2025-12-18T00:25:00.3084853-05:00","closed_at":"2025-12-18T00:25:00.3084853-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-nlk.1","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:33:53.6092999-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.1","depends_on_id":"keyp-nlk.8","type":"blocks","created_at":"2025-12-17T13:43:55.184671-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.2","title":"Enhance store.Search with SearchOptions (tags filter, limit)","description":"PROBLEM: store.Search exists but lacks SearchOptions for filtering and limiting results. Phase 4 search and Phase 7 GET /search need optional parameters.\n\nLOCATION: internal/store/store.go\n\nEXISTING CODE (lines 165-187):\nfunc (s *Store) Search(query string) ([]*model.SecretObject, error)\n\nENHANCEMENT:\n1. Add SearchOptions struct with Tags []string and Limit int\n2. Update Search signature to accept SearchOptions\n3. Apply tag filtering if Tags provided\n4. Apply LIMIT if Limit \u003e 0\n\nNEW SIGNATURE:\ntype SearchOptions struct {\n    Tags  []string\n    Limit int\n}\n\nfunc (s *Store) Search(ctx context.Context, query string, opts SearchOptions) ([]*model.SecretObject, error)\n\nNOTE: Also adds context.Context parameter (see keyp-nlk.8 for full context migration).\n\nACCEPTANCE:\n- Search method accepts SearchOptions\n- Empty opts works like current behavior\n- Tag filtering works\n- Limit option works\n- Returns empty slice (not error) for no matches","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:34:30.688594-05:00","updated_at":"2025-12-18T00:25:01.4579583-05:00","closed_at":"2025-12-18T00:25:01.4579583-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-nlk.2","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:34:30.6918953-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.2","depends_on_id":"keyp-nlk.8","type":"blocks","created_at":"2025-12-17T13:44:05.3686516-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.3","title":"Verify FTS5 virtual table created in schema migration","description":"PROBLEM: Search depends on FTS5 virtual table secrets_fts. Need to verify it exists and is properly synced.\n\nLOCATION: internal/store/schema.sql and internal/store/store.go\n\nAPPROACH:\n1. Review schema.sql to confirm secrets_fts virtual table definition\n2. Verify triggers exist to keep FTS in sync with secrets table\n3. If missing, add CREATE VIRTUAL TABLE and sync triggers\n4. Test that inserts/updates/deletes properly update FTS index\n\nSCHEMA (expected):\nCREATE VIRTUAL TABLE secrets_fts USING fts5(\n    name, tags, notes,\n    content='secrets',\n    content_rowid='rowid'\n);\n\nCREATE TRIGGER secrets_ai AFTER INSERT ON secrets BEGIN\n    INSERT INTO secrets_fts(rowid, name, tags, notes) \n    VALUES (new.rowid, new.name, new.tags, new.notes);\nEND;\n\nCREATE TRIGGER secrets_ad AFTER DELETE ON secrets BEGIN\n    INSERT INTO secrets_fts(secrets_fts, rowid, name, tags, notes) \n    VALUES('delete', old.rowid, old.name, old.tags, old.notes);\nEND;\n\nCREATE TRIGGER secrets_au AFTER UPDATE ON secrets BEGIN\n    INSERT INTO secrets_fts(secrets_fts, rowid, name, tags, notes) \n    VALUES('delete', old.rowid, old.name, old.tags, old.notes);\n    INSERT INTO secrets_fts(rowid, name, tags, notes) \n    VALUES (new.rowid, new.name, new.tags, new.notes);\nEND;\n\nACCEPTANCE:\n- FTS5 virtual table exists in schema\n- Triggers keep FTS in sync\n- Search returns correct results after insert/update/delete","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:35:19.7517146-05:00","updated_at":"2025-12-17T13:39:49.8714675-05:00","closed_at":"2025-12-17T13:39:49.8714675-05:00","close_reason":"FTS5 virtual table and sync triggers already exist in store.go initSchema(). Verified lines 63-82 contain CREATE VIRTUAL TABLE secrets_fts and all three triggers (secrets_ai, secrets_ad, secrets_au).","dependencies":[{"issue_id":"keyp-nlk.3","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:35:19.7543598-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.3","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T08:58:33.2640224-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.4","title":"Add missing domain error types to internal/store/errors.go","description":"PROBLEM: Store operations need typed errors. ErrNotFound already exists in store.go line 12, but other error types are missing.\n\nLOCATION: internal/store/errors.go (create new file)\n\nEXISTING:\nvar ErrNotFound = errors.New(\"secret not found\") // in store.go:12\n\nNEEDED:\nMove ErrNotFound to errors.go and add:\n\nvar (\n    ErrNotFound        = errors.New(\"secret not found\")\n    ErrAlreadyExists   = errors.New(\"secret already exists\")\n    ErrInvalidPassword = errors.New(\"invalid password\")\n    ErrDatabaseLocked  = errors.New(\"database is locked\")\n    ErrVaultClosed     = errors.New(\"vault is closed\")\n)\n\nAPPROACH:\n1. Create internal/store/errors.go with all error types\n2. Remove ErrNotFound declaration from store.go\n3. Update store.go to use errors from errors.go\n4. Update Create method to return ErrAlreadyExists on duplicate name\n\nACCEPTANCE:\n- errors.go file exists with all error types\n- Errors support errors.Is() for comparison\n- Store methods return appropriate errors\n- go build ./internal/store/ compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T01:36:01.5102443-05:00","updated_at":"2025-12-18T00:25:02.6441232-05:00","closed_at":"2025-12-18T00:25:02.6441232-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-nlk.4","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:36:01.5140211-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.5","title":"Add json tags to SecretObject and Field types","description":"PROBLEM: Phase 7 HTTP API needs JSON serialization of secrets. Model types need json struct tags.\n\nLOCATION: internal/model/secret.go\n\nAPPROACH:\nReview existing types and ensure all exported fields have json tags:\n\ntype SecretObject struct {\n    ID        string    `json:\"id\"`\n    Name      string    `json:\"name\"`\n    Tags      []string  `json:\"tags\"`\n    Fields    []Field   `json:\"fields\"`\n    Notes     string    `json:\"notes\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n\ntype Field struct {\n    Label     string `json:\"label\"`\n    Value     string `json:\"value\"`\n    Sensitive bool   `json:\"sensitive\"`\n    Type      string `json:\"type\"`\n}\n\nACCEPTANCE:\n- All exported fields have json tags\n- Tags use snake_case convention\n- json.Marshal produces expected output\n- go build ./internal/model/ compiles","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:36:41.7638518-05:00","updated_at":"2025-12-17T13:40:26.4883814-05:00","closed_at":"2025-12-17T13:40:26.4883814-05:00","close_reason":"JSON tags already exist on SecretObject and Field types in internal/model/secret.go lines 11-29. All exported fields have proper json struct tags with snake_case convention.","dependencies":[{"issue_id":"keyp-nlk.5","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:36:41.7665128-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.6","title":"Add SecretObject.Redacted method for masking sensitive values","description":"PROBLEM: API responses and CLI show commands need to display secrets without exposing sensitive field values.\n\nLOCATION: internal/model/secret.go\n\nAPPROACH:\nAdd Redacted() method that returns a copy with sensitive field values masked:\n\nconst RedactedValue = \"********\"\n\nfunc (s *SecretObject) Redacted() *SecretObject {\n    copy := *s\n    copy.Fields = make([]Field, len(s.Fields))\n    for i, f := range s.Fields {\n        copy.Fields[i] = f\n        if f.Sensitive {\n            copy.Fields[i].Value = RedactedValue\n        }\n    }\n    return \u0026copy\n}\n\nACCEPTANCE:\n- Redacted() method exists on SecretObject\n- Returns new object (doesn't modify original)\n- Sensitive field values replaced with ********\n- Non-sensitive fields unchanged\n- go test ./internal/model/ passes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:37:19.4347884-05:00","updated_at":"2025-12-18T00:22:36.5246968-05:00","closed_at":"2025-12-18T00:22:36.5246968-05:00","close_reason":"Added Redacted() method to SecretObject that returns a copy with sensitive field values masked as ********. Also added RedactedValue constant. go build ./internal/model/ verified successfully.","dependencies":[{"issue_id":"keyp-nlk.6","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:37:19.4374587-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.7","title":"Add store package unit tests for CRUD, search, and error cases","description":"PROBLEM: Store package needs comprehensive unit tests before CLI and HTTP layers depend on it.\n\nLOCATION: internal/store/store_test.go\n\nTEST CASES:\n1. CRUD Operations:\n   - Create secret, verify Get returns it\n   - Create duplicate name returns ErrAlreadyExists\n   - Get non-existent returns ErrNotFound\n   - Update existing secret (change name, tags, fields)\n   - Update non-existent returns ErrNotFound\n   - Delete existing secret\n   - Delete non-existent returns ErrNotFound\n   - List returns all secrets\n\n2. Search:\n   - Search by name (partial match)\n   - Search by tag\n   - Search by notes content\n   - Search with no matches returns empty slice\n   - Search with limit option\n\n3. Field Operations:\n   - Create secret with multiple fields\n   - Fields preserve sort_order\n   - Update replaces all fields\n\n4. Error Handling:\n   - Operations on closed store return error\n   - Invalid input handling\n\nAPPROACH:\nUse table-driven tests where appropriate. Create test database in temp directory.\n\nACCEPTANCE:\n- go test ./internal/store/ passes\n- Coverage includes happy path and error cases\n- Tests clean up temp files","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T01:38:08.3746789-05:00","updated_at":"2025-12-18T00:31:56.8179448-05:00","closed_at":"2025-12-18T00:31:56.8179448-05:00","close_reason":"Closed","dependencies":[{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T01:38:08.3784214-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.1","type":"blocks","created_at":"2025-12-17T08:58:34.5214942-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.2","type":"blocks","created_at":"2025-12-17T08:58:35.7782291-05:00","created_by":"daemon"},{"issue_id":"keyp-nlk.7","depends_on_id":"keyp-nlk.4","type":"blocks","created_at":"2025-12-17T08:58:37.0392485-05:00","created_by":"daemon"}]}
{"id":"keyp-nlk.8","title":"Add context.Context parameter to all store methods","description":"PROBLEM: Store methods lack context.Context parameter. HTTP handlers and CLI commands need to pass context for cancellation and timeouts.\n\nLOCATION: internal/store/store.go\n\nCURRENT SIGNATURES:\nfunc (s *Store) Create(secret *model.SecretObject) error\nfunc (s *Store) GetByName(name string) (*model.SecretObject, error)\nfunc (s *Store) List() ([]*model.SecretObject, error)\nfunc (s *Store) Search(query string) ([]*model.SecretObject, error)\nfunc (s *Store) Delete(name string) error\n\nNEW SIGNATURES:\nfunc (s *Store) Create(ctx context.Context, secret *model.SecretObject) error\nfunc (s *Store) GetByName(ctx context.Context, name string) (*model.SecretObject, error)\nfunc (s *Store) List(ctx context.Context) ([]*model.SecretObject, error)\nfunc (s *Store) Search(ctx context.Context, query string, opts SearchOptions) ([]*model.SecretObject, error)\nfunc (s *Store) Delete(ctx context.Context, name string) error\nfunc (s *Store) Update(ctx context.Context, secret *model.SecretObject) error\n\nAPPROACH:\n1. Add context.Context as first parameter to all public methods\n2. Use ctx with database operations (db.QueryContext, db.ExecContext)\n3. Update internal/vault/vault.go to pass context through\n4. Update tests to use context.Background()\n\nNOTE: This should be done BEFORE keyp-nlk.1 (Update) and keyp-nlk.2 (Search enhancement) since they reference the new signatures.\n\nACCEPTANCE:\n- All store methods accept context.Context\n- Database operations use *Context variants\n- Vault wrapper passes context through\n- go build ./... compiles\n- go test ./internal/store/ passes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-17T13:43:38.1257952-05:00","updated_at":"2025-12-18T00:19:12.0118182-05:00","closed_at":"2025-12-18T00:19:12.0118182-05:00","close_reason":"Added context.Context parameter to all store methods - enables timeout and cancellation support","dependencies":[{"issue_id":"keyp-nlk.8","depends_on_id":"keyp-nlk","type":"parent-child","created_at":"2025-12-17T13:43:38.1284579-05:00","created_by":"daemon"}]}
{"id":"keyp-pby","title":"tag add: accept multiple tags (variadic)","description":"Currently 'keyp tag add \u003csecret\u003e \u003ctag\u003e' only accepts one tag. Should accept variadic: 'keyp tag add \u003csecret\u003e \u003ctag1\u003e \u003ctag2\u003e ...'. Change cobra Args from ExactArgs(2) to MinimumArgs(2), loop over args[1:] to add all tags.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T17:40:47.3068535-05:00","updated_at":"2025-12-22T17:50:24.3695764-05:00","closed_at":"2025-12-22T17:50:24.3695764-05:00","close_reason":"Implemented variadic tag support. Changed cobra.ExactArgs(2) to cobra.MinimumNArgs(2), updated Use string to reflect '[\u003ctag\u003e ...]' syntax, and modified runTagAdd to loop over args[1:] to add multiple tags at once. Tags are deduplicated to avoid duplicates."}
{"id":"keyp-pid","title":"FTS5 schema error: field_labels column not in secrets table","description":"keyp init fails with 'no such column: T.field_labels'. The FTS5 virtual table uses content='secrets' which expects all indexed columns to exist in the secrets table, but field_labels is derived from the fields table, not stored in secrets.\n\nFIX: Remove content='secrets', content_rowid='rowid' from the FTS5 definition to make it a contentless table:\n\nCREATE VIRTUAL TABLE IF NOT EXISTS secrets_fts USING fts5(\n    name, tags, notes, field_labels\n);\n\nThe triggers already manage content manually so this should work. Also update the UPDATE statements in Create() and Update() methods - they use 'UPDATE secrets_fts SET field_labels = ?' which won't work with FTS5. Use DELETE + INSERT pattern instead like the triggers do.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-23T01:47:52.237022-05:00","updated_at":"2025-12-23T01:55:00.4814084-05:00","closed_at":"2025-12-23T01:55:00.4814084-05:00","close_reason":"Fixed FTS5 schema error by removing content='secrets' from virtual table definition and switching to DELETE+INSERT pattern for FTS updates in Create() and Update() methods"}
{"id":"keyp-u9i","title":"Phase 2.75: Vault Encryption Integration","description":"Integrate existing crypto primitives (internal/core/crypto.go) with vault layer to provide password-based encryption for stored secrets.\n\nCURRENT STATE:\n- crypto.go has AES-256-GCM encryption with PBKDF2 key derivation (complete)\n- vault.go has Init(path) and Open(path) with NO password support\n- store.go uses plain unencrypted SQLite\n- CLI tasks (Phase 3) expect password prompts but vault doesn't use them\n\nGOAL: Wire encryption into the vault so passwords actually protect data.\n\nComponents:\n1. Vault Metadata Storage - store encryption params (salt, iterations)\n2. Vault API Changes - Init(path, password), Open(path, password)\n3. Encryption Strategy - SQLCipher, field-level, or file-level encryption\n4. Key Management - derive key with existing DeriveKey(), keep in memory\n\nDEPENDS: Phase 2 (SQLite storage) - COMPLETE\nBLOCKS: Phase 3 (CLI commands need password), Phase 6 (VaultHandle needs key)\n\nACCEPTANCE:\n- vault.Init(path, password) creates encrypted vault\n- vault.Open(path, password) decrypts and opens vault\n- vault.Open(path, wrongPassword) returns ErrInvalidPassword\n- Secrets are not readable without password\n- Existing crypto unit tests still pass","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-18T14:38:29.477273-05:00","updated_at":"2025-12-18T15:29:05.9162247-05:00","closed_at":"2025-12-18T15:29:05.9162247-05:00","close_reason":"Phase 2.75 complete: Vault Encryption Integration epic finished. All 6 subtasks completed: (1) vault_meta table for encryption parameters, (2) vault.Init with password support, (3) vault.Open with password support, (4) field-level encryption for sensitive values, (5) password verification on vault open, (6) comprehensive encryption integration tests. Vault now provides password-based encryption for secrets with AES-256-GCM, PBKDF2 key derivation, and full encryption/decryption cycle."}
{"id":"keyp-u9i.1","title":"Add vault metadata table for encryption parameters","description":"PROBLEM: Need to store encryption parameters (salt, iterations) for key derivation.\n\nLOCATION: internal/store/store.go (schema) or internal/vault/metadata.go\n\nAPPROACH:\nAdd metadata table to SQLite schema:\n\nCREATE TABLE IF NOT EXISTS vault_meta (\n    key TEXT PRIMARY KEY,\n    value TEXT NOT NULL\n);\n\nStore these values on Init:\n- 'salt': base64-encoded 32-byte random salt\n- 'iterations': PBKDF2 iteration count (100000+)\n- 'version': encryption format version (for future upgrades)\n\nHelper functions:\n- SetMeta(key, value string) error\n- GetMeta(key string) (string, error)\n\nACCEPTANCE:\n- vault_meta table created in schema\n- Salt and iterations stored on vault init\n- Values retrievable for Open()\n- go build compiles","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T14:39:05.7162871-05:00","updated_at":"2025-12-18T15:20:03.3534435-05:00","closed_at":"2025-12-18T15:20:03.3534435-05:00","close_reason":"Added vault_meta table to store encryption parameters (salt, iterations). Implemented SetMeta() and GetMeta() helper methods in Store for metadata operations.","dependencies":[{"issue_id":"keyp-u9i.1","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:39:05.718896-05:00","created_by":"daemon"}]}
{"id":"keyp-u9i.2","title":"Update vault.Init to accept password and derive encryption key","description":"PROBLEM: vault.Init(path) needs password parameter for encryption.\n\nLOCATION: internal/vault/vault.go\n\nAPPROACH:\nUpdate Init signature and implementation:\n\n```go\n// Init creates a new vault at the specified path with password protection\nfunc Init(path string, password string) (*Vault, error) {\n    if Exists(path) {\n        return nil, ErrAlreadyExists\n    }\n\n    // Create directory if needed\n    dir := filepath.Dir(path)\n    if err := os.MkdirAll(dir, 0700); err != nil {\n        return nil, err\n    }\n\n    // Generate random salt\n    salt := make([]byte, core.SaltSize)\n    if _, err := rand.Read(salt); err != nil {\n        return nil, fmt.Errorf(\"failed to generate salt: %w\", err)\n    }\n\n    // Derive encryption key\n    key, err := core.DeriveKey(password, salt, core.MinIterations)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to derive key: %w\", err)\n    }\n\n    // Create store (TODO: use key for encryption)\n    s, err := store.Open(path)\n    if err != nil {\n        return nil, err\n    }\n\n    // Store encryption metadata\n    if err := s.SetMeta(\"salt\", base64.StdEncoding.EncodeToString(salt)); err != nil {\n        s.Close()\n        return nil, err\n    }\n    if err := s.SetMeta(\"iterations\", fmt.Sprintf(\"%d\", core.MinIterations)); err != nil {\n        s.Close()\n        return nil, err\n    }\n\n    return \u0026Vault{\n        path:   path,\n        store:  s,\n        key:    key,\n        locked: false,\n    }, nil\n}\n```\n\nNOTE: The Vault struct needs a 'key []byte' field to hold the derived key.\n\nACCEPTANCE:\n- Init(path, password) generates salt and derives key\n- Salt and iterations stored in vault metadata\n- Key kept in Vault struct for encryption operations\n- Existing tests updated for new signature","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T14:40:06.8987718-05:00","updated_at":"2025-12-18T15:22:09.403214-05:00","closed_at":"2025-12-18T15:22:09.403214-05:00","close_reason":"Updated vault.Init() to accept password parameter. Implemented salt generation, key derivation using DeriveKey(), and storage of encryption metadata (salt, iterations) in vault_meta table.","dependencies":[{"issue_id":"keyp-u9i.2","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:40:06.9025618-05:00","created_by":"daemon"}]}
{"id":"keyp-u9i.3","title":"Update vault.Open to accept password and verify credentials","description":"PROBLEM: vault.Open(path) needs password parameter to decrypt vault.\n\nLOCATION: internal/vault/vault.go\n\nAPPROACH:\nUpdate Open signature and implementation:\n\n```go\n// Open opens an existing vault with password\nfunc Open(path string, password string) (*Vault, error) {\n    if !Exists(path) {\n        return nil, ErrNotExists\n    }\n\n    // Open store to read metadata\n    s, err := store.Open(path)\n    if err != nil {\n        return nil, err\n    }\n\n    // Read encryption parameters\n    saltB64, err := s.GetMeta(\"salt\")\n    if err != nil {\n        s.Close()\n        return nil, fmt.Errorf(\"failed to read vault metadata: %w\", err)\n    }\n    iterStr, err := s.GetMeta(\"iterations\")\n    if err != nil {\n        s.Close()\n        return nil, fmt.Errorf(\"failed to read vault metadata: %w\", err)\n    }\n\n    salt, err := base64.StdEncoding.DecodeString(saltB64)\n    if err != nil {\n        s.Close()\n        return nil, fmt.Errorf(\"corrupted vault metadata: %w\", err)\n    }\n    iterations, err := strconv.Atoi(iterStr)\n    if err != nil {\n        s.Close()\n        return nil, fmt.Errorf(\"corrupted vault metadata: %w\", err)\n    }\n\n    // Derive key from password\n    key, err := core.DeriveKey(password, salt, iterations)\n    if err != nil {\n        s.Close()\n        return nil, err\n    }\n\n    // TODO: Verify password is correct (depends on encryption strategy)\n    // For now, store the key - verification happens on first decrypt\n\n    return \u0026Vault{\n        path:   path,\n        store:  s,\n        key:    key,\n        locked: false,\n    }, nil\n}\n```\n\nACCEPTANCE:\n- Open(path, password) reads salt/iterations from metadata\n- Derives key using stored parameters\n- Returns ErrInvalidPassword on wrong password (after encryption implemented)\n- Existing tests updated for new signature","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T14:41:05.4703265-05:00","updated_at":"2025-12-18T15:22:38.0539851-05:00","closed_at":"2025-12-18T15:22:38.0539851-05:00","close_reason":"Updated vault.Open() to accept password parameter. Retrieves salt and iterations from vault_meta, derives key from password using stored parameters. Password is now required to open vault.","dependencies":[{"issue_id":"keyp-u9i.3","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:41:05.4741082-05:00","created_by":"daemon"}]}
{"id":"keyp-u9i.4","title":"Implement field-level encryption for sensitive values","description":"PROBLEM: Secret field values need to be encrypted at rest.\n\nLOCATION: internal/store/store.go or internal/vault/vault.go\n\nAPPROACH:\nEncrypt Field.Value before storage, decrypt on retrieval.\n\nOption: Add encryption at the Vault layer (simpler, keeps Store unchanged):\n\n```go\n// In vault.go - wrap store operations\n\nfunc (v *Vault) Create(ctx context.Context, secret *model.SecretObject) error {\n    if v.IsLocked() {\n        return ErrLocked\n    }\n    \n    // Encrypt sensitive field values before storage\n    encrypted := v.encryptSecret(secret)\n    return v.store.Create(ctx, encrypted)\n}\n\nfunc (v *Vault) encryptSecret(secret *model.SecretObject) *model.SecretObject {\n    copy := *secret\n    copy.Fields = make([]model.Field, len(secret.Fields))\n    for i, f := range secret.Fields {\n        copy.Fields[i] = f\n        if f.Sensitive {\n            // Encrypt using core.Encrypt with vault's derived key\n            result, _ := v.encryptValue(f.Value)\n            copy.Fields[i].Value = result // Store as JSON or structured string\n        }\n    }\n    return \u0026copy\n}\n\nfunc (v *Vault) encryptValue(plaintext string) (string, error) {\n    // Use the derived key stored in v.key\n    // Simplified: use key directly with AES-GCM (key already derived)\n    // ...\n}\n```\n\nALTERNATIVE: Use SQLCipher for transparent database encryption (requires different SQLite driver).\n\nACCEPTANCE:\n- Sensitive field values encrypted before INSERT/UPDATE\n- Values decrypted on SELECT\n- Wrong password returns ErrInvalidPassword (decryption fails)\n- Non-sensitive fields remain readable\n- Unit tests verify encryption/decryption cycle","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T14:42:00.2165793-05:00","updated_at":"2025-12-18T15:24:31.9450284-05:00","closed_at":"2025-12-18T15:24:31.9450284-05:00","close_reason":"Implemented field-level encryption for sensitive values. Added encryptSecret() and decryptSecret() methods to transparently encrypt/decrypt sensitive fields. Updated Create(), GetByName(), List(), Search(), and Update() methods to use encryption. Encryption uses AES-256-GCM with vault's derived key and format iv:ciphertext:authTag for storage.","dependencies":[{"issue_id":"keyp-u9i.4","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:42:00.219229-05:00","created_by":"daemon"}]}
{"id":"keyp-u9i.5","title":"Add password verification on vault open","description":"PROBLEM: Need to verify password is correct before allowing vault access.\n\nLOCATION: internal/vault/vault.go\n\nAPPROACH:\nStore a known verification value encrypted with the derived key. On Open, decrypt\nand verify this value to confirm password is correct.\n\n```go\nconst verificationPlaintext = \"keyp-vault-v1\"\n\n// In Init - store encrypted verification value\nfunc Init(path string, password string) (*Vault, error) {\n    // ... derive key ...\n    \n    // Create verification value\n    verifyResult, err := encryptWithKey(verificationPlaintext, key)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Store in metadata\n    if err := s.SetMeta(\"verify\", verifyResult); err != nil {\n        return nil, err\n    }\n    // ...\n}\n\n// In Open - verify password\nfunc Open(path string, password string) (*Vault, error) {\n    // ... derive key ...\n    \n    // Read and decrypt verification value\n    verifyEncrypted, err := s.GetMeta(\"verify\")\n    if err != nil {\n        return nil, err\n    }\n    \n    decrypted, err := decryptWithKey(verifyEncrypted, key)\n    if err != nil || decrypted != verificationPlaintext {\n        s.Close()\n        return nil, store.ErrInvalidPassword\n    }\n    // ...\n}\n```\n\nACCEPTANCE:\n- Verification value stored on Init\n- Wrong password returns store.ErrInvalidPassword\n- Correct password allows vault to open\n- Corrupted verification value returns appropriate error","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T14:42:51.9804041-05:00","updated_at":"2025-12-18T15:26:03.86774-05:00","closed_at":"2025-12-18T15:26:03.86774-05:00","close_reason":"Implemented password verification on vault open. Stores encrypted verification value (keyp-vault-v1) during Init. During Open, decrypts verification value using derived key - if decryption fails or value doesn't match, returns ErrInvalidPassword. Prevents vault from opening with wrong password.","dependencies":[{"issue_id":"keyp-u9i.5","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:42:51.983059-05:00","created_by":"daemon"}]}
{"id":"keyp-u9i.6","title":"Add vault encryption integration tests","description":"PROBLEM: Need tests to verify encryption works end-to-end.\n\nLOCATION: internal/vault/vault_test.go\n\nTEST CASES:\n1. Init with password creates encrypted vault\n2. Open with correct password succeeds\n3. Open with wrong password returns ErrInvalidPassword\n4. Stored secrets are not readable without decryption\n5. Create -\u003e Close -\u003e Open -\u003e GetByName returns correct decrypted value\n6. Field.Sensitive=true values are encrypted, Sensitive=false are not\n7. Migration: test behavior with pre-encryption vaults (if applicable)\n\n```go\nfunc TestVaultEncryption(t *testing.T) {\n    path := filepath.Join(t.TempDir(), \"test.db\")\n    password := \"testpassword123\"\n    \n    // Create vault\n    v, err := vault.Init(path, password)\n    require.NoError(t, err)\n    \n    // Add secret\n    secret := model.NewSecretObject(\"test\")\n    secret.AddField(model.NewField(\"password\", \"supersecret\"))\n    err = v.Create(context.Background(), secret)\n    require.NoError(t, err)\n    v.Close()\n    \n    // Reopen with correct password\n    v2, err := vault.Open(path, password)\n    require.NoError(t, err)\n    \n    retrieved, err := v2.GetByName(context.Background(), \"test\")\n    require.NoError(t, err)\n    assert.Equal(t, \"supersecret\", retrieved.Fields[0].Value)\n    v2.Close()\n    \n    // Wrong password fails\n    _, err = vault.Open(path, \"wrongpassword\")\n    assert.ErrorIs(t, err, store.ErrInvalidPassword)\n}\n```\n\nACCEPTANCE:\n- All encryption test cases pass\n- Tests run in CI (no external dependencies)\n- Coverage includes error paths","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T14:43:43.9430506-05:00","updated_at":"2025-12-18T15:28:31.7075934-05:00","closed_at":"2025-12-18T15:28:31.7075934-05:00","close_reason":"Added comprehensive vault encryption integration tests. Test coverage includes: encryption/decryption end-to-end, wrong password detection, create-close-reopen-retrieve cycle, list with decryption, update with encryption, non-sensitive field handling, file exists/already exists error cases. All tests verify encryption works correctly with field-level encryption and password verification.","dependencies":[{"issue_id":"keyp-u9i.6","depends_on_id":"keyp-u9i","type":"parent-child","created_at":"2025-12-18T14:43:43.9480435-05:00","created_by":"daemon"}]}
